# ./sdf_dom.py
# -*- coding: utf-8 -*-
# PyXB bindings for NM:e92452c8d3e28a9e27abfc9994d2007779e7f4c9
# Generated 2016-09-27 14:12:10.885297 by PyXB version 1.2.5 using Python 3.5.1.final.0
# Namespace AbsentNamespace0

from __future__ import unicode_literals
import pyxb
import pyxb.binding
import pyxb.binding.saxer
import io
import pyxb.utils.utility
import pyxb.utils.domutils
import sys
import pyxb.utils.six as _six
# Unique identifier for bindings created at the same time
_GenerationUID = pyxb.utils.utility.UniqueIdentifier('urn:uuid:977e1a08-84ab-11e6-847a-a820662556b9')

# Version of PyXB used to generate the bindings
_PyXBVersion = '1.2.5'
# Generated bindings are not compatible across PyXB versions
if pyxb.__version__ != _PyXBVersion:
    raise pyxb.PyXBVersionError(_PyXBVersion)

# A holder for module-level binding classes so we can access them from
# inside class definitions where property names may conflict.
_module_typeBindings = pyxb.utils.utility.Object()

# Import bindings for namespaces imported into schema
import pyxb.binding.datatypes

# NOTE: All namespace declarations are reserved within the binding
Namespace = pyxb.namespace.CreateAbsentNamespace()
Namespace.configureCategories(['typeBinding', 'elementBinding'])

def CreateFromDocument (xml_text, default_namespace=None, location_base=None):
    """Parse the given XML and use the document element to create a
    Python instance.

    @param xml_text An XML document.  This should be data (Python 2
    str or Python 3 bytes), or a text (Python 2 unicode or Python 3
    str) in the L{pyxb._InputEncoding} encoding.

    @keyword default_namespace The L{pyxb.Namespace} instance to use as the
    default namespace where there is no default namespace in scope.
    If unspecified or C{None}, the namespace of the module containing
    this function will be used.

    @keyword location_base: An object to be recorded as the base of all
    L{pyxb.utils.utility.Location} instances associated with events and
    objects handled by the parser.  You might pass the URI from which
    the document was obtained.
    """

    if pyxb.XMLStyle_saxer != pyxb._XMLStyle:
        dom = pyxb.utils.domutils.StringToDOM(xml_text)
        return CreateFromDOM(dom.documentElement, default_namespace=default_namespace)
    if default_namespace is None:
        default_namespace = Namespace.fallbackNamespace()
    saxer = pyxb.binding.saxer.make_parser(fallback_namespace=default_namespace, location_base=location_base)
    handler = saxer.getContentHandler()
    xmld = xml_text
    if isinstance(xmld, _six.text_type):
        xmld = xmld.encode(pyxb._InputEncoding)
    saxer.parse(io.BytesIO(xmld))
    instance = handler.rootObject()
    return instance

def CreateFromDOM (node, default_namespace=None):
    """Create a Python instance from the given DOM node.
    The node tag must correspond to an element declaration in this module.

    @deprecated: Forcing use of DOM interface is unnecessary; use L{CreateFromDocument}."""
    if default_namespace is None:
        default_namespace = Namespace.fallbackNamespace()
    return pyxb.binding.basis.element.AnyCreateFromDOM(node, default_namespace)


# Atomic simple type: vector3
class vector3 (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'vector3')
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/types.xsd', 3, 2)
    _Documentation = None
vector3._CF_pattern = pyxb.binding.facets.CF_pattern()
vector3._CF_pattern.addPattern(pattern='(\\s*(-|\\+)?(\\d+(\\.\\d*)?|\\.\\d+|\\d+\\.\\d+[eE][-\\+]?[0-9]+)\\s+){2}((-|\\+)?(\\d+(\\.\\d*)?|\\.\\d+|\\d+\\.\\d+[eE][-\\+]?[0-9]+))\\s*')
vector3._InitializeFacetMap(vector3._CF_pattern)
Namespace.addCategoryObject('typeBinding', 'vector3', vector3)
_module_typeBindings.vector3 = vector3

# Atomic simple type: quaternion
class quaternion (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'quaternion')
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/types.xsd', 9, 2)
    _Documentation = None
quaternion._CF_pattern = pyxb.binding.facets.CF_pattern()
quaternion._CF_pattern.addPattern(pattern='(\\s*(-|\\+)?(\\d+(\\.\\d*)?|\\.\\d+|\\d+\\.\\d+[eE][-\\+]?[0-9]+)\\s+){3}((-|\\+)?(\\d+(\\.\\d*)?|\\.\\d+|\\d+\\.\\d+[eE][-\\+]?[0-9]+))\\s*')
quaternion._InitializeFacetMap(quaternion._CF_pattern)
Namespace.addCategoryObject('typeBinding', 'quaternion', quaternion)
_module_typeBindings.quaternion = quaternion

# Atomic simple type: vector2d
class vector2d (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'vector2d')
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/types.xsd', 15, 2)
    _Documentation = None
vector2d._CF_pattern = pyxb.binding.facets.CF_pattern()
vector2d._CF_pattern.addPattern(pattern='(\\s*(-|\\+)?(\\d+(\\.\\d*)?|\\.\\d+|\\d+\\.\\d+[eE][-\\+]?[0-9]+)\\s+)((-|\\+)?(\\d+(\\.\\d*)?|\\.\\d+|\\d+\\.\\d+[eE][-\\+]?[0-9]+))\\s*')
vector2d._InitializeFacetMap(vector2d._CF_pattern)
Namespace.addCategoryObject('typeBinding', 'vector2d', vector2d)
_module_typeBindings.vector2d = vector2d

# Atomic simple type: vector2i
class vector2i (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'vector2i')
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/types.xsd', 21, 2)
    _Documentation = None
vector2i._CF_pattern = pyxb.binding.facets.CF_pattern()
vector2i._CF_pattern.addPattern(pattern='\\s*(-|\\+)?\\d+\\s+(-|\\+)?\\d+\\s*')
vector2i._InitializeFacetMap(vector2i._CF_pattern)
Namespace.addCategoryObject('typeBinding', 'vector2i', vector2i)
_module_typeBindings.vector2i = vector2i

# Atomic simple type: pose
class pose (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'pose')
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/types.xsd', 27, 2)
    _Documentation = None
pose._CF_pattern = pyxb.binding.facets.CF_pattern()
pose._CF_pattern.addPattern(pattern='(\\s*(-|\\+)?(\\d+(\\.\\d*)?|\\.\\d+|\\d+\\.\\d+[eE][-\\+]?[0-9]+)\\s+){5}((-|\\+)?(\\d+(\\.\\d*)?|\\.\\d+|\\d+\\.\\d+[eE][-\\+]?[0-9]+))\\s*')
pose._InitializeFacetMap(pose._CF_pattern)
Namespace.addCategoryObject('typeBinding', 'pose', pose)
_module_typeBindings.pose = pose

# Atomic simple type: time
class time (pyxb.binding.datatypes.double):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'time')
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/types.xsd', 33, 2)
    _Documentation = None
time._InitializeFacetMap()
Namespace.addCategoryObject('typeBinding', 'time', time)
_module_typeBindings.time = time

# Atomic simple type: color
class color (pyxb.binding.datatypes.string):

    """An atomic simple type."""

    _ExpandedName = pyxb.namespace.ExpandedName(Namespace, 'color')
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/types.xsd', 38, 2)
    _Documentation = None
color._CF_pattern = pyxb.binding.facets.CF_pattern()
color._CF_pattern.addPattern(pattern='(\\s*\\+?(\\d+(\\.\\d*)?|\\.\\d+|\\d+\\.\\d+[eE][-\\+]?[0-9]+)\\s+){3}\\+?(\\d+(\\.\\d*)?|\\.\\d+|\\d+\\.\\d+[eE][-\\+]?[0-9]+)\\s*')
color._InitializeFacetMap(color._CF_pattern)
Namespace.addCategoryObject('typeBinding', 'color', color)
_module_typeBindings.color = color

# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 8, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element static uses Python identifier static
    __static = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'static'), 'static', '__AbsentNamespace0_CTD_ANON_static', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 11, 8), )

    
    static = property(__static.value, __static.set, None, '\n              Actors should be static, in terms of physics simulation.\n            ')

    
    # Element pose uses Python identifier pose
    __pose = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'pose'), 'pose', '__AbsentNamespace0_CTD_ANON_pose', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 20, 8), )

    
    pose = property(__pose.value, __pose.set, None, '\n              Origin of the actor\n            ')

    
    # Element skin uses Python identifier skin
    __skin = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'skin'), 'skin', '__AbsentNamespace0_CTD_ANON_skin', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 29, 8), )

    
    skin = property(__skin.value, __skin.set, None, None)

    
    # Element animation uses Python identifier animation
    __animation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'animation'), 'animation', '__AbsentNamespace0_CTD_ANON_animation', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 45, 8), )

    
    animation = property(__animation.value, __animation.set, None, None)

    
    # Element script uses Python identifier script
    __script = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'script'), 'script', '__AbsentNamespace0_CTD_ANON_script', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 67, 8), )

    
    script = property(__script.value, __script.set, None, None)

    
    # Element joint uses Python identifier joint
    __joint = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'joint'), 'joint', '__AbsentNamespace0_CTD_ANON_joint', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 10, 2), )

    
    joint = property(__joint.value, __joint.set, None, None)

    
    # Element link uses Python identifier link
    __link = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'link'), 'link', '__AbsentNamespace0_CTD_ANON_link', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 16, 2), )

    
    link = property(__link.value, __link.set, None, None)

    
    # Element plugin uses Python identifier plugin
    __plugin = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'plugin'), 'plugin', '__AbsentNamespace0_CTD_ANON_plugin', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/plugin.xsd', 9, 2), )

    
    plugin = property(__plugin.value, __plugin.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 118, 6)
    __name._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 118, 6)
    
    name = property(__name.value, __name.set, None, None)

    _ElementMap.update({
        __static.name() : __static,
        __pose.name() : __pose,
        __skin.name() : __skin,
        __animation.name() : __animation,
        __script.name() : __script,
        __joint.name() : __joint,
        __link.name() : __link,
        __plugin.name() : __plugin
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_module_typeBindings.CTD_ANON = CTD_ANON


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_ (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 30, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element filename uses Python identifier filename
    __filename = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'filename'), 'filename', '__AbsentNamespace0_CTD_ANON__filename', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 33, 14), )

    
    filename = property(__filename.value, __filename.set, None, None)

    
    # Element scale uses Python identifier scale
    __scale = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'scale'), 'scale', '__AbsentNamespace0_CTD_ANON__scale', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 37, 14), )

    
    scale = property(__scale.value, __scale.set, None, None)

    _ElementMap.update({
        __filename.name() : __filename,
        __scale.name() : __scale
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_ = CTD_ANON_


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_2 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 46, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element filename uses Python identifier filename
    __filename = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'filename'), 'filename', '__AbsentNamespace0_CTD_ANON_2_filename', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 49, 14), )

    
    filename = property(__filename.value, __filename.set, None, None)

    
    # Element scale uses Python identifier scale
    __scale = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'scale'), 'scale', '__AbsentNamespace0_CTD_ANON_2_scale', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 53, 14), )

    
    scale = property(__scale.value, __scale.set, None, None)

    
    # Element interpolate_x uses Python identifier interpolate_x
    __interpolate_x = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'interpolate_x'), 'interpolate_x', '__AbsentNamespace0_CTD_ANON_2_interpolate_x', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 57, 14), )

    
    interpolate_x = property(__interpolate_x.value, __interpolate_x.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_2_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 61, 12)
    __name._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 61, 12)
    
    name = property(__name.value, __name.set, None, None)

    _ElementMap.update({
        __filename.name() : __filename,
        __scale.name() : __scale,
        __interpolate_x.name() : __interpolate_x
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_module_typeBindings.CTD_ANON_2 = CTD_ANON_2


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_3 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 68, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element loop uses Python identifier loop
    __loop = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'loop'), 'loop', '__AbsentNamespace0_CTD_ANON_3_loop', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 71, 14), )

    
    loop = property(__loop.value, __loop.set, None, None)

    
    # Element delay_start uses Python identifier delay_start
    __delay_start = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'delay_start'), 'delay_start', '__AbsentNamespace0_CTD_ANON_3_delay_start', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 75, 14), )

    
    delay_start = property(__delay_start.value, __delay_start.set, None, None)

    
    # Element auto_start uses Python identifier auto_start
    __auto_start = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'auto_start'), 'auto_start', '__AbsentNamespace0_CTD_ANON_3_auto_start', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 79, 14), )

    
    auto_start = property(__auto_start.value, __auto_start.set, None, None)

    
    # Element trajectory uses Python identifier trajectory
    __trajectory = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'trajectory'), 'trajectory', '__AbsentNamespace0_CTD_ANON_3_trajectory', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 83, 14), )

    
    trajectory = property(__trajectory.value, __trajectory.set, None, None)

    _ElementMap.update({
        __loop.name() : __loop,
        __delay_start.name() : __delay_start,
        __auto_start.name() : __auto_start,
        __trajectory.name() : __trajectory
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_3 = CTD_ANON_3


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_4 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 84, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element waypoint uses Python identifier waypoint
    __waypoint = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'waypoint'), 'waypoint', '__AbsentNamespace0_CTD_ANON_4_waypoint', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 87, 20), )

    
    waypoint = property(__waypoint.value, __waypoint.set, None, None)

    
    # Attribute id uses Python identifier id
    __id = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'id'), 'id', '__AbsentNamespace0_CTD_ANON_4_id', pyxb.binding.datatypes.int, required=True)
    __id._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 103, 18)
    __id._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 103, 18)
    
    id = property(__id.value, __id.set, None, None)

    
    # Attribute type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'type'), 'type', '__AbsentNamespace0_CTD_ANON_4_type', pyxb.binding.datatypes.string, required=True)
    __type._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 105, 18)
    __type._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 105, 18)
    
    type = property(__type.value, __type.set, None, None)

    _ElementMap.update({
        __waypoint.name() : __waypoint
    })
    _AttributeMap.update({
        __id.name() : __id,
        __type.name() : __type
    })
_module_typeBindings.CTD_ANON_4 = CTD_ANON_4


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_5 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 88, 22)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element time uses Python identifier time
    __time = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'time'), 'time', '__AbsentNamespace0_CTD_ANON_5_time', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 91, 26), )

    
    time = property(__time.value, __time.set, None, None)

    
    # Element pose uses Python identifier pose
    __pose = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'pose'), 'pose', '__AbsentNamespace0_CTD_ANON_5_pose', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 95, 26), )

    
    pose = property(__pose.value, __pose.set, None, None)

    _ElementMap.update({
        __time.name() : __time,
        __pose.name() : __pose
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_5 = CTD_ANON_5


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_6 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/altimeter.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element vertical_position uses Python identifier vertical_position
    __vertical_position = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'vertical_position'), 'vertical_position', '__AbsentNamespace0_CTD_ANON_6_vertical_position', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/altimeter.xsd', 13, 8), )

    
    vertical_position = property(__vertical_position.value, __vertical_position.set, None, '\n              \n      Noise parameters for vertical position\n    \n            ')

    
    # Element vertical_velocity uses Python identifier vertical_velocity
    __vertical_velocity = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'vertical_velocity'), 'vertical_velocity', '__AbsentNamespace0_CTD_ANON_6_vertical_velocity', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/altimeter.xsd', 28, 8), )

    
    vertical_velocity = property(__vertical_velocity.value, __vertical_velocity.set, None, '\n              \n      Noise parameters for vertical velocity\n    \n            ')

    _ElementMap.update({
        __vertical_position.name() : __vertical_position,
        __vertical_velocity.name() : __vertical_velocity
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_6 = CTD_ANON_6


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_7 (pyxb.binding.basis.complexTypeDefinition):
    """
              
      Noise parameters for vertical position
    
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/altimeter.xsd', 21, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_7 = CTD_ANON_7


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_8 (pyxb.binding.basis.complexTypeDefinition):
    """
              
      Noise parameters for vertical velocity
    
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/altimeter.xsd', 36, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_8 = CTD_ANON_8


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_9 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element uri uses Python identifier uri
    __uri = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'uri'), 'uri', '__AbsentNamespace0_CTD_ANON_9_uri', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 13, 8), )

    
    uri = property(__uri.value, __uri.set, None, '\n              URI of the audio media.\n            ')

    
    # Element pitch uses Python identifier pitch
    __pitch = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'pitch'), 'pitch', '__AbsentNamespace0_CTD_ANON_9_pitch', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 22, 8), )

    
    pitch = property(__pitch.value, __pitch.set, None, '\n              Pitch for the audio media, in Hz\n            ')

    
    # Element gain uses Python identifier gain
    __gain = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'gain'), 'gain', '__AbsentNamespace0_CTD_ANON_9_gain', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 31, 8), )

    
    gain = property(__gain.value, __gain.set, None, '\n              Gain for the audio media, in dB.\n            ')

    
    # Element contact uses Python identifier contact
    __contact = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'contact'), 'contact', '__AbsentNamespace0_CTD_ANON_9_contact', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 40, 8), )

    
    contact = property(__contact.value, __contact.set, None, '\n              List of collision objects that will trigger audio playback.\n            ')

    
    # Element loop uses Python identifier loop
    __loop = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'loop'), 'loop', '__AbsentNamespace0_CTD_ANON_9_loop', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 62, 8), )

    
    loop = property(__loop.value, __loop.set, None, '\n              True to make the audio source loop playback.\n            ')

    
    # Element pose uses Python identifier pose
    __pose = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'pose'), 'pose', '__AbsentNamespace0_CTD_ANON_9_pose', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 71, 8), )

    
    pose = property(__pose.value, __pose.set, None, '\n              A position and orientation in the parent coordinate frame for the audio source. Position(x,y,z) and rotation (roll, pitch yaw) in the parent coordinate frame.\n            ')

    _ElementMap.update({
        __uri.name() : __uri,
        __pitch.name() : __pitch,
        __gain.name() : __gain,
        __contact.name() : __contact,
        __loop.name() : __loop,
        __pose.name() : __pose
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_9 = CTD_ANON_9


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_10 (pyxb.binding.basis.complexTypeDefinition):
    """
              List of collision objects that will trigger audio playback.
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 46, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element collision uses Python identifier collision
    __collision = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'collision'), 'collision', '__AbsentNamespace0_CTD_ANON_10_collision', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 49, 14), )

    
    collision = property(__collision.value, __collision.set, None, '\n                    Name of child collision element that will trigger audio playback.\n                  ')

    _ElementMap.update({
        __collision.name() : __collision
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_10 = CTD_ANON_10


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_11 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/box_shape.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element size uses Python identifier size
    __size = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'size'), 'size', '__AbsentNamespace0_CTD_ANON_11_size', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/box_shape.xsd', 13, 8), )

    
    size = property(__size.value, __size.set, None, '\n              The three side lengths of the box. The origin of the box is in its geometric center (inside the center of the box).\n            ')

    _ElementMap.update({
        __size.name() : __size
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_11 = CTD_ANON_11


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_12 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element pose uses Python identifier pose
    __pose = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'pose'), 'pose', '__AbsentNamespace0_CTD_ANON_12_pose', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 13, 8), )

    
    pose = property(__pose.value, __pose.set, None, '\n              A position and orientation in the parent coordinate frame for the camera.\n            ')

    
    # Element horizontal_fov uses Python identifier horizontal_fov
    __horizontal_fov = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'horizontal_fov'), 'horizontal_fov', '__AbsentNamespace0_CTD_ANON_12_horizontal_fov', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 22, 8), )

    
    horizontal_fov = property(__horizontal_fov.value, __horizontal_fov.set, None, '\n              Horizontal field of view\n            ')

    
    # Element image uses Python identifier image
    __image = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'image'), 'image', '__AbsentNamespace0_CTD_ANON_12_image', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 31, 8), )

    
    image = property(__image.value, __image.set, None, '\n              The image size in pixels and format.\n            ')

    
    # Element clip uses Python identifier clip
    __clip = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'clip'), 'clip', '__AbsentNamespace0_CTD_ANON_12_clip', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 71, 8), )

    
    clip = property(__clip.value, __clip.set, None, '\n              The near and far clip planes. Objects closer or farther than these planes are not rendered.\n            ')

    
    # Element save uses Python identifier save
    __save = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'save'), 'save', '__AbsentNamespace0_CTD_ANON_12_save', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 102, 8), )

    
    save = property(__save.value, __save.set, None, '\n              Enable or disable saving of camera frames.\n            ')

    
    # Element depth_camera uses Python identifier depth_camera
    __depth_camera = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'depth_camera'), 'depth_camera', '__AbsentNamespace0_CTD_ANON_12_depth_camera', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 131, 8), )

    
    depth_camera = property(__depth_camera.value, __depth_camera.set, None, '\n              Depth camera parameters\n            ')

    
    # Element noise uses Python identifier noise
    __noise = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'noise'), 'noise', '__AbsentNamespace0_CTD_ANON_12_noise', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 153, 8), )

    
    noise = property(__noise.value, __noise.set, None, '\n              The properties of the noise model that should be applied to generated images\n            ')

    
    # Element distortion uses Python identifier distortion
    __distortion = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'distortion'), 'distortion', '__AbsentNamespace0_CTD_ANON_12_distortion', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 193, 8), )

    
    distortion = property(__distortion.value, __distortion.set, None, '\n              Lens distortion to be applied to camera images. See http://en.wikipedia.org/wiki/Distortion_(optics)#Software_correction\n            ')

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_12_name', pyxb.binding.datatypes.string, unicode_default='__default__')
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 260, 6)
    __name._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 260, 6)
    
    name = property(__name.value, __name.set, None, '\n            An optional name for the camera.\n          ')

    _ElementMap.update({
        __pose.name() : __pose,
        __horizontal_fov.name() : __horizontal_fov,
        __image.name() : __image,
        __clip.name() : __clip,
        __save.name() : __save,
        __depth_camera.name() : __depth_camera,
        __noise.name() : __noise,
        __distortion.name() : __distortion
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_module_typeBindings.CTD_ANON_12 = CTD_ANON_12


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_13 (pyxb.binding.basis.complexTypeDefinition):
    """
              The image size in pixels and format.
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 37, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element width uses Python identifier width
    __width = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'width'), 'width', '__AbsentNamespace0_CTD_ANON_13_width', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 40, 14), )

    
    width = property(__width.value, __width.set, None, '\n                    Width in pixels\n                  ')

    
    # Element height uses Python identifier height
    __height = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'height'), 'height', '__AbsentNamespace0_CTD_ANON_13_height', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 49, 14), )

    
    height = property(__height.value, __height.set, None, '\n                    Height in pixels \n                  ')

    
    # Element format uses Python identifier format
    __format = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'format'), 'format', '__AbsentNamespace0_CTD_ANON_13_format', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 58, 14), )

    
    format = property(__format.value, __format.set, None, '\n                    (L8|R8G8B8|B8G8R8|BAYER_RGGB8|BAYER_BGGR8|BAYER_GBRG8|BAYER_GRBG8)\n                  ')

    _ElementMap.update({
        __width.name() : __width,
        __height.name() : __height,
        __format.name() : __format
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_13 = CTD_ANON_13


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_14 (pyxb.binding.basis.complexTypeDefinition):
    """
              The near and far clip planes. Objects closer or farther than these planes are not rendered.
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 77, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element near uses Python identifier near
    __near = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'near'), 'near', '__AbsentNamespace0_CTD_ANON_14_near', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 80, 14), )

    
    near = property(__near.value, __near.set, None, '\n                    Near clipping plane\n                  ')

    
    # Element far uses Python identifier far
    __far = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'far'), 'far', '__AbsentNamespace0_CTD_ANON_14_far', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 89, 14), )

    
    far = property(__far.value, __far.set, None, '\n                    Far clipping plane\n                  ')

    _ElementMap.update({
        __near.name() : __near,
        __far.name() : __far
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_14 = CTD_ANON_14


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_15 (pyxb.binding.basis.complexTypeDefinition):
    """
              Enable or disable saving of camera frames.
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 108, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element path uses Python identifier path
    __path = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'path'), 'path', '__AbsentNamespace0_CTD_ANON_15_path', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 111, 14), )

    
    path = property(__path.value, __path.set, None, '\n                    The path name which will hold the frame data. If path name is relative, then directory is relative to current working directory.\n                  ')

    
    # Attribute enabled uses Python identifier enabled
    __enabled = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'enabled'), 'enabled', '__AbsentNamespace0_CTD_ANON_15_enabled', pyxb.binding.datatypes.boolean, required=True)
    __enabled._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 120, 12)
    __enabled._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 120, 12)
    
    enabled = property(__enabled.value, __enabled.set, None, '\n                  True = saving enabled\n                ')

    _ElementMap.update({
        __path.name() : __path
    })
    _AttributeMap.update({
        __enabled.name() : __enabled
    })
_module_typeBindings.CTD_ANON_15 = CTD_ANON_15


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_16 (pyxb.binding.basis.complexTypeDefinition):
    """
              Depth camera parameters
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 137, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element output uses Python identifier output
    __output = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'output'), 'output', '__AbsentNamespace0_CTD_ANON_16_output', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 140, 14), )

    
    output = property(__output.value, __output.set, None, '\n                    Type of output\n                  ')

    _ElementMap.update({
        __output.name() : __output
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_16 = CTD_ANON_16


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_17 (pyxb.binding.basis.complexTypeDefinition):
    """
              The properties of the noise model that should be applied to generated images
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 159, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element type uses Python identifier type
    __type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'type'), 'type', '__AbsentNamespace0_CTD_ANON_17_type', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 162, 14), )

    
    type = property(__type.value, __type.set, None, '\n                    The type of noise.  Currently supported types are: "gaussian" (draw additive noise values independently for each pixel from a Gaussian distribution).\n                  ')

    
    # Element mean uses Python identifier mean
    __mean = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'mean'), 'mean', '__AbsentNamespace0_CTD_ANON_17_mean', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 171, 14), )

    
    mean = property(__mean.value, __mean.set, None, '\n                    For type "gaussian," the mean of the Gaussian distribution from which noise values are drawn.\n                  ')

    
    # Element stddev uses Python identifier stddev
    __stddev = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'stddev'), 'stddev', '__AbsentNamespace0_CTD_ANON_17_stddev', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 180, 14), )

    
    stddev = property(__stddev.value, __stddev.set, None, '\n                    For type "gaussian," the standard deviation of the Gaussian distribution from which noise values are drawn.\n                  ')

    _ElementMap.update({
        __type.name() : __type,
        __mean.name() : __mean,
        __stddev.name() : __stddev
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_17 = CTD_ANON_17


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_18 (pyxb.binding.basis.complexTypeDefinition):
    """
              Lens distortion to be applied to camera images. See http://en.wikipedia.org/wiki/Distortion_(optics)#Software_correction
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 199, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element k1 uses Python identifier k1
    __k1 = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'k1'), 'k1', '__AbsentNamespace0_CTD_ANON_18_k1', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 202, 14), )

    
    k1 = property(__k1.value, __k1.set, None, '\n                    The radial distortion coefficient k1\n                  ')

    
    # Element k2 uses Python identifier k2
    __k2 = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'k2'), 'k2', '__AbsentNamespace0_CTD_ANON_18_k2', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 211, 14), )

    
    k2 = property(__k2.value, __k2.set, None, '\n                    The radial distortion coefficient k2\n                  ')

    
    # Element k3 uses Python identifier k3
    __k3 = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'k3'), 'k3', '__AbsentNamespace0_CTD_ANON_18_k3', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 220, 14), )

    
    k3 = property(__k3.value, __k3.set, None, '\n                    The radial distortion coefficient k3\n                  ')

    
    # Element p1 uses Python identifier p1
    __p1 = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'p1'), 'p1', '__AbsentNamespace0_CTD_ANON_18_p1', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 229, 14), )

    
    p1 = property(__p1.value, __p1.set, None, '\n                    The tangential distortion coefficient p1\n                  ')

    
    # Element p2 uses Python identifier p2
    __p2 = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'p2'), 'p2', '__AbsentNamespace0_CTD_ANON_18_p2', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 238, 14), )

    
    p2 = property(__p2.value, __p2.set, None, '\n                    The tangential distortion coefficient p2\n                  ')

    
    # Element center uses Python identifier center
    __center = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'center'), 'center', '__AbsentNamespace0_CTD_ANON_18_center', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 247, 14), )

    
    center = property(__center.value, __center.set, None, '\n                    The distortion center or principal point\n                  ')

    _ElementMap.update({
        __k1.name() : __k1,
        __k2.name() : __k2,
        __k3.name() : __k3,
        __p1.name() : __p1,
        __p2.name() : __p2,
        __center.name() : __center
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_18 = CTD_ANON_18


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_19 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/collision.xsd', 12, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element laser_retro uses Python identifier laser_retro
    __laser_retro = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'laser_retro'), 'laser_retro', '__AbsentNamespace0_CTD_ANON_19_laser_retro', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/collision.xsd', 15, 8), )

    
    laser_retro = property(__laser_retro.value, __laser_retro.set, None, '\n              intensity value returned by laser sensor.\n            ')

    
    # Element max_contacts uses Python identifier max_contacts
    __max_contacts = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'max_contacts'), 'max_contacts', '__AbsentNamespace0_CTD_ANON_19_max_contacts', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/collision.xsd', 24, 8), )

    
    max_contacts = property(__max_contacts.value, __max_contacts.set, None, '\n              Maximum number of contacts allowed between two entities. This value overrides the max_contacts element defined in physics.\n            ')

    
    # Element pose uses Python identifier pose
    __pose = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'pose'), 'pose', '__AbsentNamespace0_CTD_ANON_19_pose', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/collision.xsd', 33, 8), )

    
    pose = property(__pose.value, __pose.set, None, '\n              The reference frame of the collision element, relative to the reference frame of the link.\n            ')

    
    # Element geometry uses Python identifier geometry
    __geometry = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'geometry'), 'geometry', '__AbsentNamespace0_CTD_ANON_19_geometry', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/geometry.xsd', 17, 2), )

    
    geometry = property(__geometry.value, __geometry.set, None, None)

    
    # Element surface uses Python identifier surface
    __surface = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'surface'), 'surface', '__AbsentNamespace0_CTD_ANON_19_surface', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 9, 2), )

    
    surface = property(__surface.value, __surface.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_19_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/collision.xsd', 44, 6)
    __name._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/collision.xsd', 44, 6)
    
    name = property(__name.value, __name.set, None, '\n            Unique name for the collision element within the scope of the parent link.\n          ')

    _ElementMap.update({
        __laser_retro.name() : __laser_retro,
        __max_contacts.name() : __max_contacts,
        __pose.name() : __pose,
        __geometry.name() : __geometry,
        __surface.name() : __surface
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_module_typeBindings.CTD_ANON_19 = CTD_ANON_19


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_20 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/contact.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element collision uses Python identifier collision
    __collision = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'collision'), 'collision', '__AbsentNamespace0_CTD_ANON_20_collision', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/contact.xsd', 13, 8), )

    
    collision = property(__collision.value, __collision.set, None, '\n              name of the collision element within a link that acts as the contact sensor.\n            ')

    
    # Element topic uses Python identifier topic
    __topic = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'topic'), 'topic', '__AbsentNamespace0_CTD_ANON_20_topic', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/contact.xsd', 22, 8), )

    
    topic = property(__topic.value, __topic.set, None, '\n              Topic on which contact data is published.\n            ')

    _ElementMap.update({
        __collision.name() : __collision,
        __topic.name() : __topic
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_20 = CTD_ANON_20


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_21 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/cylinder_shape.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element radius uses Python identifier radius
    __radius = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'radius'), 'radius', '__AbsentNamespace0_CTD_ANON_21_radius', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/cylinder_shape.xsd', 13, 8), )

    
    radius = property(__radius.value, __radius.set, None, '\n              Radius of the cylinder\n            ')

    
    # Element length uses Python identifier length
    __length = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'length'), 'length', '__AbsentNamespace0_CTD_ANON_21_length', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/cylinder_shape.xsd', 22, 8), )

    
    length = property(__length.value, __length.set, None, '\n              Length of the cylinder\n            ')

    _ElementMap.update({
        __radius.name() : __radius,
        __length.name() : __length
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_21 = CTD_ANON_21


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_22 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/forcetorque.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element frame uses Python identifier frame
    __frame = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'frame'), 'frame', '__AbsentNamespace0_CTD_ANON_22_frame', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/forcetorque.xsd', 13, 8), )

    
    frame = property(__frame.value, __frame.set, None, '\n              \n      Frame in which to report the wrench values. Currently supported frames are:\n        "parent" report the wrench expressed in the orientation of the parent link frame,\n        "child" report the wrench expressed in the orientation of the child link frame,\n        "sensor" report the wrench expressed in the orientation of the joint sensor frame.\n      Note that for each option the point with respect to which the \n      torque component of the wrench is expressed is the joint origin.\n    \n            ')

    
    # Element measure_direction uses Python identifier measure_direction
    __measure_direction = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'measure_direction'), 'measure_direction', '__AbsentNamespace0_CTD_ANON_22_measure_direction', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/forcetorque.xsd', 29, 8), )

    
    measure_direction = property(__measure_direction.value, __measure_direction.set, None, '\n              \n      Direction of the wrench measured by the sensor. The supported options are:\n        "parent_to_child" if the measured wrench is the one applied by parent link on the child link,\n        "child_to_parent" if the measured wrench is the one applied by the child link on the parent link.\n    \n            ')

    _ElementMap.update({
        __frame.name() : __frame,
        __measure_direction.name() : __measure_direction
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_22 = CTD_ANON_22


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_23 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/geometry.xsd', 18, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element box uses Python identifier box
    __box = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'box'), 'box', '__AbsentNamespace0_CTD_ANON_23_box', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/box_shape.xsd', 9, 2), )

    
    box = property(__box.value, __box.set, None, None)

    
    # Element cylinder uses Python identifier cylinder
    __cylinder = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'cylinder'), 'cylinder', '__AbsentNamespace0_CTD_ANON_23_cylinder', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/cylinder_shape.xsd', 9, 2), )

    
    cylinder = property(__cylinder.value, __cylinder.set, None, None)

    
    # Element empty uses Python identifier empty
    __empty = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'empty'), 'empty', '__AbsentNamespace0_CTD_ANON_23_empty', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/geometry.xsd', 21, 8), )

    
    empty = property(__empty.value, __empty.set, None, '\n              You can use the empty tag to make empty geometries.\n            ')

    
    # Element heightmap uses Python identifier heightmap
    __heightmap = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'heightmap'), 'heightmap', '__AbsentNamespace0_CTD_ANON_23_heightmap', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 9, 2), )

    
    heightmap = property(__heightmap.value, __heightmap.set, None, None)

    
    # Element image uses Python identifier image
    __image = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'image'), 'image', '__AbsentNamespace0_CTD_ANON_23_image', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/image_shape.xsd', 9, 2), )

    
    image = property(__image.value, __image.set, None, None)

    
    # Element mesh uses Python identifier mesh
    __mesh = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'mesh'), 'mesh', '__AbsentNamespace0_CTD_ANON_23_mesh', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/mesh_shape.xsd', 9, 2), )

    
    mesh = property(__mesh.value, __mesh.set, None, None)

    
    # Element plane uses Python identifier plane
    __plane = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'plane'), 'plane', '__AbsentNamespace0_CTD_ANON_23_plane', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/plane_shape.xsd', 9, 2), )

    
    plane = property(__plane.value, __plane.set, None, None)

    
    # Element polyline uses Python identifier polyline
    __polyline = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'polyline'), 'polyline', '__AbsentNamespace0_CTD_ANON_23_polyline', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/polyline_shape.xsd', 9, 2), )

    
    polyline = property(__polyline.value, __polyline.set, None, None)

    
    # Element sphere uses Python identifier sphere
    __sphere = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'sphere'), 'sphere', '__AbsentNamespace0_CTD_ANON_23_sphere', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/sphere_shape.xsd', 9, 2), )

    
    sphere = property(__sphere.value, __sphere.set, None, None)

    _ElementMap.update({
        __box.name() : __box,
        __cylinder.name() : __cylinder,
        __empty.name() : __empty,
        __heightmap.name() : __heightmap,
        __image.name() : __image,
        __mesh.name() : __mesh,
        __plane.name() : __plane,
        __polyline.name() : __polyline,
        __sphere.name() : __sphere
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_23 = CTD_ANON_23


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_24 (pyxb.binding.basis.complexTypeDefinition):
    """
              You can use the empty tag to make empty geometries.
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/geometry.xsd', 27, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_24 = CTD_ANON_24


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_25 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element position_sensing uses Python identifier position_sensing
    __position_sensing = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'position_sensing'), 'position_sensing', '__AbsentNamespace0_CTD_ANON_25_position_sensing', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 13, 8), )

    
    position_sensing = property(__position_sensing.value, __position_sensing.set, None, '\n              \n      Parameters related to GPS position measurement.\n    \n            ')

    
    # Element velocity_sensing uses Python identifier velocity_sensing
    __velocity_sensing = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'velocity_sensing'), 'velocity_sensing', '__AbsentNamespace0_CTD_ANON_25_velocity_sensing', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 58, 8), )

    
    velocity_sensing = property(__velocity_sensing.value, __velocity_sensing.set, None, '\n              \n      Parameters related to GPS position measurement.\n    \n            ')

    _ElementMap.update({
        __position_sensing.name() : __position_sensing,
        __velocity_sensing.name() : __velocity_sensing
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_25 = CTD_ANON_25


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_26 (pyxb.binding.basis.complexTypeDefinition):
    """
              
      Parameters related to GPS position measurement.
    
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 21, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element horizontal uses Python identifier horizontal
    __horizontal = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'horizontal'), 'horizontal', '__AbsentNamespace0_CTD_ANON_26_horizontal', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 24, 14), )

    
    horizontal = property(__horizontal.value, __horizontal.set, None, '\n                    \n        Noise parameters for horizontal position measurement, in units of meters.\n      \n                  ')

    
    # Element vertical uses Python identifier vertical
    __vertical = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'vertical'), 'vertical', '__AbsentNamespace0_CTD_ANON_26_vertical', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 39, 14), )

    
    vertical = property(__vertical.value, __vertical.set, None, '\n                    \n        Noise parameters for vertical position measurement, in units of meters.\n      \n                  ')

    _ElementMap.update({
        __horizontal.name() : __horizontal,
        __vertical.name() : __vertical
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_26 = CTD_ANON_26


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_27 (pyxb.binding.basis.complexTypeDefinition):
    """
                    
        Noise parameters for horizontal position measurement, in units of meters.
      
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 32, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_27 = CTD_ANON_27


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_28 (pyxb.binding.basis.complexTypeDefinition):
    """
                    
        Noise parameters for vertical position measurement, in units of meters.
      
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 47, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_28 = CTD_ANON_28


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_29 (pyxb.binding.basis.complexTypeDefinition):
    """
              
      Parameters related to GPS position measurement.
    
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 66, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element horizontal uses Python identifier horizontal
    __horizontal = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'horizontal'), 'horizontal', '__AbsentNamespace0_CTD_ANON_29_horizontal', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 69, 14), )

    
    horizontal = property(__horizontal.value, __horizontal.set, None, '\n                    \n        Noise parameters for horizontal velocity measurement, in units of meters/second.\n      \n                  ')

    
    # Element vertical uses Python identifier vertical
    __vertical = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'vertical'), 'vertical', '__AbsentNamespace0_CTD_ANON_29_vertical', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 84, 14), )

    
    vertical = property(__vertical.value, __vertical.set, None, '\n                    \n        Noise parameters for vertical velocity measurement, in units of meters/second.\n      \n                  ')

    _ElementMap.update({
        __horizontal.name() : __horizontal,
        __vertical.name() : __vertical
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_29 = CTD_ANON_29


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_30 (pyxb.binding.basis.complexTypeDefinition):
    """
                    
        Noise parameters for horizontal velocity measurement, in units of meters/second.
      
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 77, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_30 = CTD_ANON_30


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_31 (pyxb.binding.basis.complexTypeDefinition):
    """
                    
        Noise parameters for vertical velocity measurement, in units of meters/second.
      
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 92, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_31 = CTD_ANON_31


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_32 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 5, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element grasp_check uses Python identifier grasp_check
    __grasp_check = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'grasp_check'), 'grasp_check', '__AbsentNamespace0_CTD_ANON_32_grasp_check', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 8, 8), )

    
    grasp_check = property(__grasp_check.value, __grasp_check.set, None, None)

    
    # Element gripper_link uses Python identifier gripper_link
    __gripper_link = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'gripper_link'), 'gripper_link', '__AbsentNamespace0_CTD_ANON_32_gripper_link', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 28, 8), )

    
    gripper_link = property(__gripper_link.value, __gripper_link.set, None, None)

    
    # Element palm_link uses Python identifier palm_link
    __palm_link = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'palm_link'), 'palm_link', '__AbsentNamespace0_CTD_ANON_32_palm_link', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 32, 8), )

    
    palm_link = property(__palm_link.value, __palm_link.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_32_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 36, 6)
    __name._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 36, 6)
    
    name = property(__name.value, __name.set, None, None)

    _ElementMap.update({
        __grasp_check.name() : __grasp_check,
        __gripper_link.name() : __gripper_link,
        __palm_link.name() : __palm_link
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_module_typeBindings.CTD_ANON_32 = CTD_ANON_32


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_33 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 9, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element detach_steps uses Python identifier detach_steps
    __detach_steps = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'detach_steps'), 'detach_steps', '__AbsentNamespace0_CTD_ANON_33_detach_steps', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 12, 14), )

    
    detach_steps = property(__detach_steps.value, __detach_steps.set, None, None)

    
    # Element attach_steps uses Python identifier attach_steps
    __attach_steps = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'attach_steps'), 'attach_steps', '__AbsentNamespace0_CTD_ANON_33_attach_steps', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 16, 14), )

    
    attach_steps = property(__attach_steps.value, __attach_steps.set, None, None)

    
    # Element min_contact_count uses Python identifier min_contact_count
    __min_contact_count = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'min_contact_count'), 'min_contact_count', '__AbsentNamespace0_CTD_ANON_33_min_contact_count', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 20, 14), )

    
    min_contact_count = property(__min_contact_count.value, __min_contact_count.set, None, None)

    _ElementMap.update({
        __detach_steps.name() : __detach_steps,
        __attach_steps.name() : __attach_steps,
        __min_contact_count.name() : __min_contact_count
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_33 = CTD_ANON_33


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_34 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 6, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element camera uses Python identifier camera
    __camera = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'camera'), 'camera', '__AbsentNamespace0_CTD_ANON_34_camera', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 9, 8), )

    
    camera = property(__camera.value, __camera.set, None, '\n               \n            ')

    
    # Element plugin uses Python identifier plugin
    __plugin = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'plugin'), 'plugin', '__AbsentNamespace0_CTD_ANON_34_plugin', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/plugin.xsd', 9, 2), )

    
    plugin = property(__plugin.value, __plugin.set, None, None)

    
    # Attribute fullscreen uses Python identifier fullscreen
    __fullscreen = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'fullscreen'), 'fullscreen', '__AbsentNamespace0_CTD_ANON_34_fullscreen', pyxb.binding.datatypes.boolean, unicode_default='false')
    __fullscreen._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 62, 6)
    __fullscreen._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 62, 6)
    
    fullscreen = property(__fullscreen.value, __fullscreen.set, None, None)

    _ElementMap.update({
        __camera.name() : __camera,
        __plugin.name() : __plugin
    })
    _AttributeMap.update({
        __fullscreen.name() : __fullscreen
    })
_module_typeBindings.CTD_ANON_34 = CTD_ANON_34


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_35 (pyxb.binding.basis.complexTypeDefinition):
    """
               
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 15, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element view_controller uses Python identifier view_controller
    __view_controller = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'view_controller'), 'view_controller', '__AbsentNamespace0_CTD_ANON_35_view_controller', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 18, 14), )

    
    view_controller = property(__view_controller.value, __view_controller.set, None, None)

    
    # Element projection_type uses Python identifier projection_type
    __projection_type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'projection_type'), 'projection_type', '__AbsentNamespace0_CTD_ANON_35_projection_type', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 22, 14), )

    
    projection_type = property(__projection_type.value, __projection_type.set, None, '\n                    Set the type of projection for the camera. Valid values are "perspective" and "orthographic".\n                  ')

    
    # Element pose uses Python identifier pose
    __pose = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'pose'), 'pose', '__AbsentNamespace0_CTD_ANON_35_pose', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 31, 14), )

    
    pose = property(__pose.value, __pose.set, None, None)

    
    # Element track_visual uses Python identifier track_visual
    __track_visual = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'track_visual'), 'track_visual', '__AbsentNamespace0_CTD_ANON_35_track_visual', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 35, 14), )

    
    track_visual = property(__track_visual.value, __track_visual.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_35_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 55, 12)
    __name._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 55, 12)
    
    name = property(__name.value, __name.set, None, None)

    _ElementMap.update({
        __view_controller.name() : __view_controller,
        __projection_type.name() : __projection_type,
        __pose.name() : __pose,
        __track_visual.name() : __track_visual
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_module_typeBindings.CTD_ANON_35 = CTD_ANON_35


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_36 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 36, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_36_name', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 39, 20), )

    
    name = property(__name.value, __name.set, None, None)

    
    # Element min_dist uses Python identifier min_dist
    __min_dist = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'min_dist'), 'min_dist', '__AbsentNamespace0_CTD_ANON_36_min_dist', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 43, 20), )

    
    min_dist = property(__min_dist.value, __min_dist.set, None, None)

    
    # Element max_dist uses Python identifier max_dist
    __max_dist = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'max_dist'), 'max_dist', '__AbsentNamespace0_CTD_ANON_36_max_dist', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 47, 20), )

    
    max_dist = property(__max_dist.value, __max_dist.set, None, None)

    _ElementMap.update({
        __name.name() : __name,
        __min_dist.name() : __min_dist,
        __max_dist.name() : __max_dist
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_36 = CTD_ANON_36


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_37 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element uri uses Python identifier uri
    __uri = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'uri'), 'uri', '__AbsentNamespace0_CTD_ANON_37_uri', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 13, 8), )

    
    uri = property(__uri.value, __uri.set, None, '\n              URI to a grayscale image file\n            ')

    
    # Element size uses Python identifier size
    __size = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'size'), 'size', '__AbsentNamespace0_CTD_ANON_37_size', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 22, 8), )

    
    size = property(__size.value, __size.set, None, '\n              The size of the heightmap in world units.\n      When loading an image: "size" is used if present, otherwise defaults to 1x1x1.\n      When loading a DEM: "size" is used if present, otherwise defaults to true size of DEM.\n  \n            ')

    
    # Element pos uses Python identifier pos
    __pos = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'pos'), 'pos', '__AbsentNamespace0_CTD_ANON_37_pos', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 34, 8), )

    
    pos = property(__pos.value, __pos.set, None, '\n              A position offset.\n            ')

    
    # Element texture uses Python identifier texture
    __texture = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'texture'), 'texture', '__AbsentNamespace0_CTD_ANON_37_texture', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 43, 8), )

    
    texture = property(__texture.value, __texture.set, None, '\n              The heightmap can contain multiple textures. The order of the texture matters. The first texture will appear at the lowest height, and the last texture at the highest height. Use blend to control the height thresholds and fade between textures.\n            ')

    
    # Element blend uses Python identifier blend
    __blend = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'blend'), 'blend', '__AbsentNamespace0_CTD_ANON_37_blend', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 83, 8), )

    
    blend = property(__blend.value, __blend.set, None, '\n              The blend tag controls how two adjacent textures are mixed. The number of blend elements should equal one less than the number of textures.\n            ')

    
    # Element use_terrain_paging uses Python identifier use_terrain_paging
    __use_terrain_paging = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'use_terrain_paging'), 'use_terrain_paging', '__AbsentNamespace0_CTD_ANON_37_use_terrain_paging', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 114, 8), )

    
    use_terrain_paging = property(__use_terrain_paging.value, __use_terrain_paging.set, None, '\n              Set if the rendering engine will use terrain paging\n            ')

    _ElementMap.update({
        __uri.name() : __uri,
        __size.name() : __size,
        __pos.name() : __pos,
        __texture.name() : __texture,
        __blend.name() : __blend,
        __use_terrain_paging.name() : __use_terrain_paging
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_37 = CTD_ANON_37


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_38 (pyxb.binding.basis.complexTypeDefinition):
    """
              The heightmap can contain multiple textures. The order of the texture matters. The first texture will appear at the lowest height, and the last texture at the highest height. Use blend to control the height thresholds and fade between textures.
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 49, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element size uses Python identifier size
    __size = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'size'), 'size', '__AbsentNamespace0_CTD_ANON_38_size', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 52, 14), )

    
    size = property(__size.value, __size.set, None, '\n                    Size of the applied texture in meters.\n                  ')

    
    # Element diffuse uses Python identifier diffuse
    __diffuse = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'diffuse'), 'diffuse', '__AbsentNamespace0_CTD_ANON_38_diffuse', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 61, 14), )

    
    diffuse = property(__diffuse.value, __diffuse.set, None, '\n                    Diffuse texture image filename\n                  ')

    
    # Element normal uses Python identifier normal
    __normal = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'normal'), 'normal', '__AbsentNamespace0_CTD_ANON_38_normal', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 70, 14), )

    
    normal = property(__normal.value, __normal.set, None, '\n                    Normalmap texture image filename\n                  ')

    _ElementMap.update({
        __size.name() : __size,
        __diffuse.name() : __diffuse,
        __normal.name() : __normal
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_38 = CTD_ANON_38


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_39 (pyxb.binding.basis.complexTypeDefinition):
    """
              The blend tag controls how two adjacent textures are mixed. The number of blend elements should equal one less than the number of textures.
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 89, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element min_height uses Python identifier min_height
    __min_height = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'min_height'), 'min_height', '__AbsentNamespace0_CTD_ANON_39_min_height', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 92, 14), )

    
    min_height = property(__min_height.value, __min_height.set, None, '\n                    Min height of a blend layer\n                  ')

    
    # Element fade_dist uses Python identifier fade_dist
    __fade_dist = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'fade_dist'), 'fade_dist', '__AbsentNamespace0_CTD_ANON_39_fade_dist', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 101, 14), )

    
    fade_dist = property(__fade_dist.value, __fade_dist.set, None, '\n                    Distance over which the blend occurs\n                  ')

    _ElementMap.update({
        __min_height.name() : __min_height,
        __fade_dist.name() : __fade_dist
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_39 = CTD_ANON_39


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_40 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/image_shape.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element uri uses Python identifier uri
    __uri = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'uri'), 'uri', '__AbsentNamespace0_CTD_ANON_40_uri', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/image_shape.xsd', 13, 8), )

    
    uri = property(__uri.value, __uri.set, None, '\n              URI of the grayscale image file\n            ')

    
    # Element scale uses Python identifier scale
    __scale = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'scale'), 'scale', '__AbsentNamespace0_CTD_ANON_40_scale', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/image_shape.xsd', 22, 8), )

    
    scale = property(__scale.value, __scale.set, None, '\n              Scaling factor applied to the image\n            ')

    
    # Element threshold uses Python identifier threshold
    __threshold = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'threshold'), 'threshold', '__AbsentNamespace0_CTD_ANON_40_threshold', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/image_shape.xsd', 31, 8), )

    
    threshold = property(__threshold.value, __threshold.set, None, '\n              Grayscale threshold\n            ')

    
    # Element height uses Python identifier height
    __height = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'height'), 'height', '__AbsentNamespace0_CTD_ANON_40_height', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/image_shape.xsd', 40, 8), )

    
    height = property(__height.value, __height.set, None, '\n              Height of the extruded boxes\n            ')

    
    # Element granularity uses Python identifier granularity
    __granularity = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'granularity'), 'granularity', '__AbsentNamespace0_CTD_ANON_40_granularity', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/image_shape.xsd', 49, 8), )

    
    granularity = property(__granularity.value, __granularity.set, None, '\n              The amount of error in the model\n            ')

    _ElementMap.update({
        __uri.name() : __uri,
        __scale.name() : __scale,
        __threshold.name() : __threshold,
        __height.name() : __height,
        __granularity.name() : __granularity
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_40 = CTD_ANON_40


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_41 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element topic uses Python identifier topic
    __topic = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'topic'), 'topic', '__AbsentNamespace0_CTD_ANON_41_topic', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 13, 8), )

    
    topic = property(__topic.value, __topic.set, None, '\n              Topic on which data is published.\n            ')

    
    # Element angular_velocity uses Python identifier angular_velocity
    __angular_velocity = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'angular_velocity'), 'angular_velocity', '__AbsentNamespace0_CTD_ANON_41_angular_velocity', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 22, 8), )

    
    angular_velocity = property(__angular_velocity.value, __angular_velocity.set, None, '\n              These elements are specific to body-frame angular velocity,\n    which is expressed in radians per second\n            ')

    
    # Element linear_acceleration uses Python identifier linear_acceleration
    __linear_acceleration = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'linear_acceleration'), 'linear_acceleration', '__AbsentNamespace0_CTD_ANON_41_linear_acceleration', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 75, 8), )

    
    linear_acceleration = property(__linear_acceleration.value, __linear_acceleration.set, None, '\n              These elements are specific to body-frame linear acceleration,\n    which is expressed in meters per second squared\n            ')

    
    # Element noise uses Python identifier noise
    __noise = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'noise'), 'noise', '__AbsentNamespace0_CTD_ANON_41_noise', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 128, 8), )

    
    noise = property(__noise.value, __noise.set, None, '\n              The properties of the noise model that should be applied to generated data\n            ')

    _ElementMap.update({
        __topic.name() : __topic,
        __angular_velocity.name() : __angular_velocity,
        __linear_acceleration.name() : __linear_acceleration,
        __noise.name() : __noise
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_41 = CTD_ANON_41


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_42 (pyxb.binding.basis.complexTypeDefinition):
    """
              These elements are specific to body-frame angular velocity,
    which is expressed in radians per second
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 29, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element x uses Python identifier x
    __x = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'x'), 'x', '__AbsentNamespace0_CTD_ANON_42_x', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 32, 14), )

    
    x = property(__x.value, __x.set, None, '\n                    Angular velocity about the X axis\n                  ')

    
    # Element y uses Python identifier y
    __y = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'y'), 'y', '__AbsentNamespace0_CTD_ANON_42_y', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 45, 14), )

    
    y = property(__y.value, __y.set, None, '\n                    Angular velocity about the Y axis\n                  ')

    
    # Element z uses Python identifier z
    __z = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'z'), 'z', '__AbsentNamespace0_CTD_ANON_42_z', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 58, 14), )

    
    z = property(__z.value, __z.set, None, '\n                    Angular velocity about the Z axis\n                  ')

    _ElementMap.update({
        __x.name() : __x,
        __y.name() : __y,
        __z.name() : __z
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_42 = CTD_ANON_42


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_43 (pyxb.binding.basis.complexTypeDefinition):
    """
                    Angular velocity about the X axis
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 38, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_43 = CTD_ANON_43


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_44 (pyxb.binding.basis.complexTypeDefinition):
    """
                    Angular velocity about the Y axis
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 51, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_44 = CTD_ANON_44


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_45 (pyxb.binding.basis.complexTypeDefinition):
    """
                    Angular velocity about the Z axis
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 64, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_45 = CTD_ANON_45


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_46 (pyxb.binding.basis.complexTypeDefinition):
    """
              These elements are specific to body-frame linear acceleration,
    which is expressed in meters per second squared
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 82, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element x uses Python identifier x
    __x = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'x'), 'x', '__AbsentNamespace0_CTD_ANON_46_x', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 85, 14), )

    
    x = property(__x.value, __x.set, None, '\n                    Linear acceleration about the X axis\n                  ')

    
    # Element y uses Python identifier y
    __y = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'y'), 'y', '__AbsentNamespace0_CTD_ANON_46_y', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 98, 14), )

    
    y = property(__y.value, __y.set, None, '\n                    Linear acceleration about the Y axis\n                  ')

    
    # Element z uses Python identifier z
    __z = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'z'), 'z', '__AbsentNamespace0_CTD_ANON_46_z', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 111, 14), )

    
    z = property(__z.value, __z.set, None, '\n                    Linear acceleration about the Z axis\n                  ')

    _ElementMap.update({
        __x.name() : __x,
        __y.name() : __y,
        __z.name() : __z
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_46 = CTD_ANON_46


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_47 (pyxb.binding.basis.complexTypeDefinition):
    """
                    Linear acceleration about the X axis
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 91, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_47 = CTD_ANON_47


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_48 (pyxb.binding.basis.complexTypeDefinition):
    """
                    Linear acceleration about the Y axis
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 104, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_48 = CTD_ANON_48


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_49 (pyxb.binding.basis.complexTypeDefinition):
    """
                    Linear acceleration about the Z axis
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 117, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_49 = CTD_ANON_49


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_50 (pyxb.binding.basis.complexTypeDefinition):
    """
              The properties of the noise model that should be applied to generated data
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 134, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element type uses Python identifier type
    __type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'type'), 'type', '__AbsentNamespace0_CTD_ANON_50_type', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 137, 14), )

    
    type = property(__type.value, __type.set, None, '\n                    The type of noise.  Currently supported types are: "gaussian" (draw noise values independently for each beam from a Gaussian distribution).\n                  ')

    
    # Element rate uses Python identifier rate
    __rate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'rate'), 'rate', '__AbsentNamespace0_CTD_ANON_50_rate', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 146, 14), )

    
    rate = property(__rate.value, __rate.set, None, '\n                    Noise parameters for angular rates.\n                  ')

    
    # Element accel uses Python identifier accel
    __accel = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'accel'), 'accel', '__AbsentNamespace0_CTD_ANON_50_accel', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 195, 14), )

    
    accel = property(__accel.value, __accel.set, None, '\n                    Noise parameters for linear accelerations.\n                  ')

    _ElementMap.update({
        __type.name() : __type,
        __rate.name() : __rate,
        __accel.name() : __accel
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_50 = CTD_ANON_50


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_51 (pyxb.binding.basis.complexTypeDefinition):
    """
                    Noise parameters for angular rates.
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 152, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element mean uses Python identifier mean
    __mean = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'mean'), 'mean', '__AbsentNamespace0_CTD_ANON_51_mean', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 155, 20), )

    
    mean = property(__mean.value, __mean.set, None, '\n                          For type "gaussian," the mean of the Gaussian distribution from which noise values are drawn.\n                        ')

    
    # Element stddev uses Python identifier stddev
    __stddev = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'stddev'), 'stddev', '__AbsentNamespace0_CTD_ANON_51_stddev', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 164, 20), )

    
    stddev = property(__stddev.value, __stddev.set, None, '\n                          For type "gaussian," the standard deviation of the Gaussian distribution from which noise values are drawn.\n                        ')

    
    # Element bias_mean uses Python identifier bias_mean
    __bias_mean = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'bias_mean'), 'bias_mean', '__AbsentNamespace0_CTD_ANON_51_bias_mean', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 173, 20), )

    
    bias_mean = property(__bias_mean.value, __bias_mean.set, None, '\n                          For type "gaussian," the mean of the Gaussian distribution from which bias values are drawn.\n                        ')

    
    # Element bias_stddev uses Python identifier bias_stddev
    __bias_stddev = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'bias_stddev'), 'bias_stddev', '__AbsentNamespace0_CTD_ANON_51_bias_stddev', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 182, 20), )

    
    bias_stddev = property(__bias_stddev.value, __bias_stddev.set, None, '\n                          For type "gaussian," the standard deviation of the Gaussian distribution from which bias values are drawn.\n                        ')

    _ElementMap.update({
        __mean.name() : __mean,
        __stddev.name() : __stddev,
        __bias_mean.name() : __bias_mean,
        __bias_stddev.name() : __bias_stddev
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_51 = CTD_ANON_51


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_52 (pyxb.binding.basis.complexTypeDefinition):
    """
                    Noise parameters for linear accelerations.
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 201, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element mean uses Python identifier mean
    __mean = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'mean'), 'mean', '__AbsentNamespace0_CTD_ANON_52_mean', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 204, 20), )

    
    mean = property(__mean.value, __mean.set, None, '\n                          For type "gaussian," the mean of the Gaussian distribution from which noise values are drawn.\n                        ')

    
    # Element stddev uses Python identifier stddev
    __stddev = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'stddev'), 'stddev', '__AbsentNamespace0_CTD_ANON_52_stddev', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 213, 20), )

    
    stddev = property(__stddev.value, __stddev.set, None, '\n                          For type "gaussian," the standard deviation of the Gaussian distribution from which noise values are drawn.\n                        ')

    
    # Element bias_mean uses Python identifier bias_mean
    __bias_mean = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'bias_mean'), 'bias_mean', '__AbsentNamespace0_CTD_ANON_52_bias_mean', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 222, 20), )

    
    bias_mean = property(__bias_mean.value, __bias_mean.set, None, '\n                          For type "gaussian," the mean of the Gaussian distribution from which bias values are drawn.\n                        ')

    
    # Element bias_stddev uses Python identifier bias_stddev
    __bias_stddev = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'bias_stddev'), 'bias_stddev', '__AbsentNamespace0_CTD_ANON_52_bias_stddev', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 231, 20), )

    
    bias_stddev = property(__bias_stddev.value, __bias_stddev.set, None, '\n                          For type "gaussian," the standard deviation of the Gaussian distribution from which bias values are drawn.\n                        ')

    _ElementMap.update({
        __mean.name() : __mean,
        __stddev.name() : __stddev,
        __bias_mean.name() : __bias_mean,
        __bias_stddev.name() : __bias_stddev
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_52 = CTD_ANON_52


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_53 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element mass uses Python identifier mass
    __mass = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'mass'), 'mass', '__AbsentNamespace0_CTD_ANON_53_mass', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 13, 8), )

    
    mass = property(__mass.value, __mass.set, None, '\n              The mass of the link.\n            ')

    
    # Element pose uses Python identifier pose
    __pose = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'pose'), 'pose', '__AbsentNamespace0_CTD_ANON_53_pose', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 22, 8), )

    
    pose = property(__pose.value, __pose.set, None, '\n              This is the pose of the inertial reference frame, relative to the link reference frame. The origin of the inertial reference frame needs to be at the center of gravity. The axes of the inertial reference frame do not need to be aligned with the principal axes of the inertia.\n            ')

    
    # Element inertia uses Python identifier inertia
    __inertia = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'inertia'), 'inertia', '__AbsentNamespace0_CTD_ANON_53_inertia', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 31, 8), )

    
    inertia = property(__inertia.value, __inertia.set, None, '\n              The 3x3 rotational inertia matrix. Because the rotational inertia matrix is symmetric, only 6 above-diagonal elements of this matrix are specified here, using the attributes ixx, ixy, ixz, iyy, iyz, izz.\n            ')

    _ElementMap.update({
        __mass.name() : __mass,
        __pose.name() : __pose,
        __inertia.name() : __inertia
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_53 = CTD_ANON_53


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_54 (pyxb.binding.basis.complexTypeDefinition):
    """
              The 3x3 rotational inertia matrix. Because the rotational inertia matrix is symmetric, only 6 above-diagonal elements of this matrix are specified here, using the attributes ixx, ixy, ixz, iyy, iyz, izz.
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 37, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ixx uses Python identifier ixx
    __ixx = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ixx'), 'ixx', '__AbsentNamespace0_CTD_ANON_54_ixx', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 40, 14), )

    
    ixx = property(__ixx.value, __ixx.set, None, None)

    
    # Element ixy uses Python identifier ixy
    __ixy = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ixy'), 'ixy', '__AbsentNamespace0_CTD_ANON_54_ixy', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 44, 14), )

    
    ixy = property(__ixy.value, __ixy.set, None, None)

    
    # Element ixz uses Python identifier ixz
    __ixz = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ixz'), 'ixz', '__AbsentNamespace0_CTD_ANON_54_ixz', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 48, 14), )

    
    ixz = property(__ixz.value, __ixz.set, None, None)

    
    # Element iyy uses Python identifier iyy
    __iyy = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'iyy'), 'iyy', '__AbsentNamespace0_CTD_ANON_54_iyy', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 52, 14), )

    
    iyy = property(__iyy.value, __iyy.set, None, None)

    
    # Element iyz uses Python identifier iyz
    __iyz = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'iyz'), 'iyz', '__AbsentNamespace0_CTD_ANON_54_iyz', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 56, 14), )

    
    iyz = property(__iyz.value, __iyz.set, None, None)

    
    # Element izz uses Python identifier izz
    __izz = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'izz'), 'izz', '__AbsentNamespace0_CTD_ANON_54_izz', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 60, 14), )

    
    izz = property(__izz.value, __izz.set, None, None)

    _ElementMap.update({
        __ixx.name() : __ixx,
        __ixy.name() : __ixy,
        __ixz.name() : __ixz,
        __iyy.name() : __iyy,
        __iyz.name() : __iyz,
        __izz.name() : __izz
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_54 = CTD_ANON_54


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_55 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 11, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element parent uses Python identifier parent
    __parent = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'parent'), 'parent', '__AbsentNamespace0_CTD_ANON_55_parent', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 14, 8), )

    
    parent = property(__parent.value, __parent.set, None, '\n              Name of the parent link\n            ')

    
    # Element child uses Python identifier child
    __child = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'child'), 'child', '__AbsentNamespace0_CTD_ANON_55_child', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 23, 8), )

    
    child = property(__child.value, __child.set, None, '\n              Name of the child link\n            ')

    
    # Element pose uses Python identifier pose
    __pose = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'pose'), 'pose', '__AbsentNamespace0_CTD_ANON_55_pose', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 32, 8), )

    
    pose = property(__pose.value, __pose.set, None, '\n              Pose offset from child link frame to joint frame (expressed in child link frame).\n            ')

    
    # Element gearbox_ratio uses Python identifier gearbox_ratio
    __gearbox_ratio = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'gearbox_ratio'), 'gearbox_ratio', '__AbsentNamespace0_CTD_ANON_55_gearbox_ratio', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 41, 8), )

    
    gearbox_ratio = property(__gearbox_ratio.value, __gearbox_ratio.set, None, '\n              Parameter for gearbox joints.  Given theta_1 and theta_2 defined in description for gearbox_reference_body, theta_2 = -gearbox_ratio * theta_1.\n            ')

    
    # Element gearbox_reference_body uses Python identifier gearbox_reference_body
    __gearbox_reference_body = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'gearbox_reference_body'), 'gearbox_reference_body', '__AbsentNamespace0_CTD_ANON_55_gearbox_reference_body', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 50, 8), )

    
    gearbox_reference_body = property(__gearbox_reference_body.value, __gearbox_reference_body.set, None, '\n              Parameter for gearbox joints.  Gearbox ratio is enforced over two joint angles.  First joint angle (theta_1) is the angle from the gearbox_reference_body to the parent link in the direction of the axis element and the second joint angle (theta_2) is the angle from the gearbox_reference_body to the child link in the direction of the axis2 element.\n            ')

    
    # Element thread_pitch uses Python identifier thread_pitch
    __thread_pitch = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'thread_pitch'), 'thread_pitch', '__AbsentNamespace0_CTD_ANON_55_thread_pitch', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 59, 8), )

    
    thread_pitch = property(__thread_pitch.value, __thread_pitch.set, None, '\n              Parameter for screw joints.\n            ')

    
    # Element axis uses Python identifier axis
    __axis = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'axis'), 'axis', '__AbsentNamespace0_CTD_ANON_55_axis', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 68, 8), )

    
    axis = property(__axis.value, __axis.set, None, '\n              \n      Parameters related to the axis of rotation for revolute joints,\n      the axis of translation for prismatic joints.\n    \n            ')

    
    # Element axis2 uses Python identifier axis2
    __axis2 = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'axis2'), 'axis2', '__AbsentNamespace0_CTD_ANON_55_axis2', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 226, 8), )

    
    axis2 = property(__axis2.value, __axis2.set, None, '\n              \n      Parameters related to the second axis of rotation for revolute2 joints and universal joints.\n    \n            ')

    
    # Element physics uses Python identifier physics
    __physics = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'physics'), 'physics', '__AbsentNamespace0_CTD_ANON_55_physics', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 378, 8), )

    
    physics = property(__physics.value, __physics.set, None, '\n              Parameters that are specific to a certain physics engine.\n            ')

    
    # Element sensor uses Python identifier sensor
    __sensor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'sensor'), 'sensor', '__AbsentNamespace0_CTD_ANON_55_sensor', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 23, 2), )

    
    sensor = property(__sensor.value, __sensor.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_55_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 569, 6)
    __name._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 569, 6)
    
    name = property(__name.value, __name.set, None, '\n            A unique name for the joint within the scope of the model.\n          ')

    
    # Attribute type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'type'), 'type', '__AbsentNamespace0_CTD_ANON_55_type', pyxb.binding.datatypes.string, required=True)
    __type._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 576, 6)
    __type._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 576, 6)
    
    type = property(__type.value, __type.set, None, '\n            The type of joint, which must be one of the following:\n      (revolute) a hinge joint that rotates on a single axis with either a fixed or continuous range of motion,\n      (gearbox) geared revolute joints,\n      (revolute2) same as two revolute joints connected in series,\n      (prismatic) a sliding joint that slides along an axis with a limited range specified by upper and lower limits,\n      (ball) a ball and socket joint,\n      (screw) a single degree of freedom joint with coupled sliding and rotational motion,\n      (universal) like a ball joint, but constrains one degree of freedom,\n      (fixed) a joint with zero degrees of freedom that rigidly connects two links.\n    \n          ')

    _ElementMap.update({
        __parent.name() : __parent,
        __child.name() : __child,
        __pose.name() : __pose,
        __gearbox_ratio.name() : __gearbox_ratio,
        __gearbox_reference_body.name() : __gearbox_reference_body,
        __thread_pitch.name() : __thread_pitch,
        __axis.name() : __axis,
        __axis2.name() : __axis2,
        __physics.name() : __physics,
        __sensor.name() : __sensor
    })
    _AttributeMap.update({
        __name.name() : __name,
        __type.name() : __type
    })
_module_typeBindings.CTD_ANON_55 = CTD_ANON_55


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_56 (pyxb.binding.basis.complexTypeDefinition):
    """
              
      Parameters related to the axis of rotation for revolute joints,
      the axis of translation for prismatic joints.
    
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 77, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element xyz uses Python identifier xyz
    __xyz = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'xyz'), 'xyz', '__AbsentNamespace0_CTD_ANON_56_xyz', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 80, 14), )

    
    xyz = property(__xyz.value, __xyz.set, None, '\n                    \n        Represents the x,y,z components of the axis unit vector. The axis is\n        expressed in the joint frame unless the use_parent_model_frame\n        flag is set to true. The vector should be normalized.\n      \n                  ')

    
    # Element use_parent_model_frame uses Python identifier use_parent_model_frame
    __use_parent_model_frame = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'use_parent_model_frame'), 'use_parent_model_frame', '__AbsentNamespace0_CTD_ANON_56_use_parent_model_frame', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 93, 14), )

    
    use_parent_model_frame = property(__use_parent_model_frame.value, __use_parent_model_frame.set, None, '\n                    \n        Flag to interpret the axis xyz element in the parent model frame instead\n        of joint frame. Provided for Gazebo compatibility\n        (see https://bitbucket.org/osrf/gazebo/issue/494 ).\n      \n                  ')

    
    # Element dynamics uses Python identifier dynamics
    __dynamics = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'dynamics'), 'dynamics', '__AbsentNamespace0_CTD_ANON_56_dynamics', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 106, 14), )

    
    dynamics = property(__dynamics.value, __dynamics.set, None, '\n                    An element specifying physical properties of the joint. These values are used to specify modeling properties of the joint, particularly useful for simulation.\n                  ')

    
    # Element limit uses Python identifier limit
    __limit = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'limit'), 'limit', '__AbsentNamespace0_CTD_ANON_56_limit', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 155, 14), )

    
    limit = property(__limit.value, __limit.set, None, '\n                    specifies the limits of this joint\n                  ')

    _ElementMap.update({
        __xyz.name() : __xyz,
        __use_parent_model_frame.name() : __use_parent_model_frame,
        __dynamics.name() : __dynamics,
        __limit.name() : __limit
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_56 = CTD_ANON_56


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_57 (pyxb.binding.basis.complexTypeDefinition):
    """
                    An element specifying physical properties of the joint. These values are used to specify modeling properties of the joint, particularly useful for simulation.
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 112, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element damping uses Python identifier damping
    __damping = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'damping'), 'damping', '__AbsentNamespace0_CTD_ANON_57_damping', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 115, 20), )

    
    damping = property(__damping.value, __damping.set, None, '\n                          The physical velocity dependent viscous damping coefficient of the joint.\n                        ')

    
    # Element friction uses Python identifier friction
    __friction = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'friction'), 'friction', '__AbsentNamespace0_CTD_ANON_57_friction', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 124, 20), )

    
    friction = property(__friction.value, __friction.set, None, '\n                          The physical static friction value of the joint.\n                        ')

    
    # Element spring_reference uses Python identifier spring_reference
    __spring_reference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'spring_reference'), 'spring_reference', '__AbsentNamespace0_CTD_ANON_57_spring_reference', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 133, 20), )

    
    spring_reference = property(__spring_reference.value, __spring_reference.set, None, '\n                          The spring reference position for this joint axis.\n                        ')

    
    # Element spring_stiffness uses Python identifier spring_stiffness
    __spring_stiffness = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'spring_stiffness'), 'spring_stiffness', '__AbsentNamespace0_CTD_ANON_57_spring_stiffness', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 142, 20), )

    
    spring_stiffness = property(__spring_stiffness.value, __spring_stiffness.set, None, '\n                          The spring stiffness for this joint axis.\n                        ')

    _ElementMap.update({
        __damping.name() : __damping,
        __friction.name() : __friction,
        __spring_reference.name() : __spring_reference,
        __spring_stiffness.name() : __spring_stiffness
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_57 = CTD_ANON_57


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_58 (pyxb.binding.basis.complexTypeDefinition):
    """
                    specifies the limits of this joint
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 161, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element lower uses Python identifier lower
    __lower = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'lower'), 'lower', '__AbsentNamespace0_CTD_ANON_58_lower', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 164, 20), )

    
    lower = property(__lower.value, __lower.set, None, '\n                          An attribute specifying the lower joint limit (radians for revolute joints, meters for prismatic joints). Omit if joint is continuous.\n                        ')

    
    # Element upper uses Python identifier upper
    __upper = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'upper'), 'upper', '__AbsentNamespace0_CTD_ANON_58_upper', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 173, 20), )

    
    upper = property(__upper.value, __upper.set, None, '\n                          An attribute specifying the upper joint limit (radians for revolute joints, meters for prismatic joints). Omit if joint is continuous.\n                        ')

    
    # Element effort uses Python identifier effort
    __effort = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'effort'), 'effort', '__AbsentNamespace0_CTD_ANON_58_effort', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 182, 20), )

    
    effort = property(__effort.value, __effort.set, None, '\n                          An attribute for enforcing the maximum joint effort applied by Joint::SetForce.  Limit is not enforced if value is negative.\n                        ')

    
    # Element velocity uses Python identifier velocity
    __velocity = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'velocity'), 'velocity', '__AbsentNamespace0_CTD_ANON_58_velocity', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 191, 20), )

    
    velocity = property(__velocity.value, __velocity.set, None, '\n                          (not implemented) An attribute for enforcing the maximum joint velocity.\n                        ')

    
    # Element stiffness uses Python identifier stiffness
    __stiffness = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'stiffness'), 'stiffness', '__AbsentNamespace0_CTD_ANON_58_stiffness', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 200, 20), )

    
    stiffness = property(__stiffness.value, __stiffness.set, None, '\n                          Joint stop stiffness. Support physics engines: SimBody.\n                        ')

    
    # Element dissipation uses Python identifier dissipation
    __dissipation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'dissipation'), 'dissipation', '__AbsentNamespace0_CTD_ANON_58_dissipation', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 209, 20), )

    
    dissipation = property(__dissipation.value, __dissipation.set, None, '\n                          Joint stop dissipation.\n                        ')

    _ElementMap.update({
        __lower.name() : __lower,
        __upper.name() : __upper,
        __effort.name() : __effort,
        __velocity.name() : __velocity,
        __stiffness.name() : __stiffness,
        __dissipation.name() : __dissipation
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_58 = CTD_ANON_58


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_59 (pyxb.binding.basis.complexTypeDefinition):
    """
              
      Parameters related to the second axis of rotation for revolute2 joints and universal joints.
    
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 234, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element xyz uses Python identifier xyz
    __xyz = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'xyz'), 'xyz', '__AbsentNamespace0_CTD_ANON_59_xyz', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 237, 14), )

    
    xyz = property(__xyz.value, __xyz.set, None, '\n                    \n        Represents the x,y,z components of the axis unit vector. The axis is\n        expressed in the joint frame unless the use_parent_model_frame\n        flag is set to true. The vector should be normalized.\n      \n                  ')

    
    # Element use_parent_model_frame uses Python identifier use_parent_model_frame
    __use_parent_model_frame = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'use_parent_model_frame'), 'use_parent_model_frame', '__AbsentNamespace0_CTD_ANON_59_use_parent_model_frame', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 250, 14), )

    
    use_parent_model_frame = property(__use_parent_model_frame.value, __use_parent_model_frame.set, None, '\n                    \n        Flag to interpret the axis xyz element in the parent model frame instead\n        of joint frame. Provided for Gazebo compatibility\n        (see https://bitbucket.org/osrf/gazebo/issue/494 ).\n      \n                  ')

    
    # Element dynamics uses Python identifier dynamics
    __dynamics = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'dynamics'), 'dynamics', '__AbsentNamespace0_CTD_ANON_59_dynamics', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 263, 14), )

    
    dynamics = property(__dynamics.value, __dynamics.set, None, '\n                    An element specifying physical properties of the joint. These values are used to specify modeling properties of the joint, particularly useful for simulation.\n                  ')

    
    # Element limit uses Python identifier limit
    __limit = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'limit'), 'limit', '__AbsentNamespace0_CTD_ANON_59_limit', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 312, 14), )

    
    limit = property(__limit.value, __limit.set, None, None)

    _ElementMap.update({
        __xyz.name() : __xyz,
        __use_parent_model_frame.name() : __use_parent_model_frame,
        __dynamics.name() : __dynamics,
        __limit.name() : __limit
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_59 = CTD_ANON_59


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_60 (pyxb.binding.basis.complexTypeDefinition):
    """
                    An element specifying physical properties of the joint. These values are used to specify modeling properties of the joint, particularly useful for simulation.
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 269, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element damping uses Python identifier damping
    __damping = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'damping'), 'damping', '__AbsentNamespace0_CTD_ANON_60_damping', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 272, 20), )

    
    damping = property(__damping.value, __damping.set, None, '\n                          The physical velocity dependent viscous damping coefficient of the joint.  EXPERIMENTAL: if damping coefficient is negative and implicit_spring_damper is true, adaptive damping is used.\n                        ')

    
    # Element friction uses Python identifier friction
    __friction = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'friction'), 'friction', '__AbsentNamespace0_CTD_ANON_60_friction', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 281, 20), )

    
    friction = property(__friction.value, __friction.set, None, '\n                          The physical static friction value of the joint.\n                        ')

    
    # Element spring_reference uses Python identifier spring_reference
    __spring_reference = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'spring_reference'), 'spring_reference', '__AbsentNamespace0_CTD_ANON_60_spring_reference', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 290, 20), )

    
    spring_reference = property(__spring_reference.value, __spring_reference.set, None, '\n                          The spring reference position for this joint axis.\n                        ')

    
    # Element spring_stiffness uses Python identifier spring_stiffness
    __spring_stiffness = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'spring_stiffness'), 'spring_stiffness', '__AbsentNamespace0_CTD_ANON_60_spring_stiffness', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 299, 20), )

    
    spring_stiffness = property(__spring_stiffness.value, __spring_stiffness.set, None, '\n                          The spring stiffness for this joint axis.\n                        ')

    _ElementMap.update({
        __damping.name() : __damping,
        __friction.name() : __friction,
        __spring_reference.name() : __spring_reference,
        __spring_stiffness.name() : __spring_stiffness
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_60 = CTD_ANON_60


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_61 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 313, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element lower uses Python identifier lower
    __lower = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'lower'), 'lower', '__AbsentNamespace0_CTD_ANON_61_lower', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 316, 20), )

    
    lower = property(__lower.value, __lower.set, None, '\n                          An attribute specifying the lower joint limit (radians for revolute joints, meters for prismatic joints). Omit if joint is continuous.\n                        ')

    
    # Element upper uses Python identifier upper
    __upper = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'upper'), 'upper', '__AbsentNamespace0_CTD_ANON_61_upper', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 325, 20), )

    
    upper = property(__upper.value, __upper.set, None, '\n                          An attribute specifying the upper joint limit (radians for revolute joints, meters for prismatic joints). Omit if joint is continuous.\n                        ')

    
    # Element effort uses Python identifier effort
    __effort = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'effort'), 'effort', '__AbsentNamespace0_CTD_ANON_61_effort', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 334, 20), )

    
    effort = property(__effort.value, __effort.set, None, '\n                          An attribute for enforcing the maximum joint effort applied by Joint::SetForce.  Limit is not enforced if value is negative.\n                        ')

    
    # Element velocity uses Python identifier velocity
    __velocity = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'velocity'), 'velocity', '__AbsentNamespace0_CTD_ANON_61_velocity', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 343, 20), )

    
    velocity = property(__velocity.value, __velocity.set, None, '\n                          (not implemented) An attribute for enforcing the maximum joint velocity.\n                        ')

    
    # Element stiffness uses Python identifier stiffness
    __stiffness = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'stiffness'), 'stiffness', '__AbsentNamespace0_CTD_ANON_61_stiffness', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 352, 20), )

    
    stiffness = property(__stiffness.value, __stiffness.set, None, '\n                          Joint stop stiffness. Supported physics engines: SimBody.\n                        ')

    
    # Element dissipation uses Python identifier dissipation
    __dissipation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'dissipation'), 'dissipation', '__AbsentNamespace0_CTD_ANON_61_dissipation', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 361, 20), )

    
    dissipation = property(__dissipation.value, __dissipation.set, None, '\n                          Joint stop dissipation. Supported physics engines: SimBody.\n                        ')

    _ElementMap.update({
        __lower.name() : __lower,
        __upper.name() : __upper,
        __effort.name() : __effort,
        __velocity.name() : __velocity,
        __stiffness.name() : __stiffness,
        __dissipation.name() : __dissipation
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_61 = CTD_ANON_61


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_62 (pyxb.binding.basis.complexTypeDefinition):
    """
              Parameters that are specific to a certain physics engine.
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 384, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element simbody uses Python identifier simbody
    __simbody = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'simbody'), 'simbody', '__AbsentNamespace0_CTD_ANON_62_simbody', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 387, 14), )

    
    simbody = property(__simbody.value, __simbody.set, None, '\n                    Simbody specific parameters\n                  ')

    
    # Element ode uses Python identifier ode
    __ode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ode'), 'ode', '__AbsentNamespace0_CTD_ANON_62_ode', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 409, 14), )

    
    ode = property(__ode.value, __ode.set, None, '\n                    ODE specific parameters\n                  ')

    
    # Element provide_feedback uses Python identifier provide_feedback
    __provide_feedback = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'provide_feedback'), 'provide_feedback', '__AbsentNamespace0_CTD_ANON_62_provide_feedback', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 555, 14), )

    
    provide_feedback = property(__provide_feedback.value, __provide_feedback.set, None, '\n                    If provide feedback is set to true, physics engine will compute the constraint forces at this joint.  For now, provide_feedback under ode block will override this tag and given user warning about the migration.  provide_feedback under ode is scheduled to be removed in SDF 1.5.\n                  ')

    _ElementMap.update({
        __simbody.name() : __simbody,
        __ode.name() : __ode,
        __provide_feedback.name() : __provide_feedback
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_62 = CTD_ANON_62


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_63 (pyxb.binding.basis.complexTypeDefinition):
    """
                    Simbody specific parameters
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 393, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element must_be_loop_joint uses Python identifier must_be_loop_joint
    __must_be_loop_joint = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'must_be_loop_joint'), 'must_be_loop_joint', '__AbsentNamespace0_CTD_ANON_63_must_be_loop_joint', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 396, 20), )

    
    must_be_loop_joint = property(__must_be_loop_joint.value, __must_be_loop_joint.set, None, '\n                          Force cut in the multibody graph at this joint.\n                        ')

    _ElementMap.update({
        __must_be_loop_joint.name() : __must_be_loop_joint
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_63 = CTD_ANON_63


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_64 (pyxb.binding.basis.complexTypeDefinition):
    """
                    ODE specific parameters
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 415, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element provide_feedback uses Python identifier provide_feedback
    __provide_feedback = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'provide_feedback'), 'provide_feedback', '__AbsentNamespace0_CTD_ANON_64_provide_feedback', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 418, 20), )

    
    provide_feedback = property(__provide_feedback.value, __provide_feedback.set, None, '\n                          (DEPRECATION WARNING:  In SDF 1.5 this tag will be replaced by the same tag directly under the physics-block.  For now, this tag overrides the one outside of ode-block, but in SDF 1.5 this tag will be removed completely.)  If provide feedback is set to true, ODE will compute the constraint forces at this joint.\n                        ')

    
    # Element cfm_damping uses Python identifier cfm_damping
    __cfm_damping = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'cfm_damping'), 'cfm_damping', '__AbsentNamespace0_CTD_ANON_64_cfm_damping', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 427, 20), )

    
    cfm_damping = property(__cfm_damping.value, __cfm_damping.set, None, '\n                          If cfm damping is set to true, ODE will use CFM to simulate damping, allows for infinite damping, and one additional constraint row (previously used for joint limit) is always active.\n                        ')

    
    # Element implicit_spring_damper uses Python identifier implicit_spring_damper
    __implicit_spring_damper = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'implicit_spring_damper'), 'implicit_spring_damper', '__AbsentNamespace0_CTD_ANON_64_implicit_spring_damper', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 436, 20), )

    
    implicit_spring_damper = property(__implicit_spring_damper.value, __implicit_spring_damper.set, None, '\n                          If implicit_spring_damper is set to true, ODE will use CFM, ERP to simulate stiffness and damping, allows for infinite damping, and one additional constraint row (previously used for joint limit) is always active.  This replaces cfm_damping parameter in sdf 1.4.\n                        ')

    
    # Element fudge_factor uses Python identifier fudge_factor
    __fudge_factor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'fudge_factor'), 'fudge_factor', '__AbsentNamespace0_CTD_ANON_64_fudge_factor', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 445, 20), )

    
    fudge_factor = property(__fudge_factor.value, __fudge_factor.set, None, '\n                          Scale the excess for in a joint motor at joint limits. Should be between zero and one.\n                        ')

    
    # Element cfm uses Python identifier cfm
    __cfm = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'cfm'), 'cfm', '__AbsentNamespace0_CTD_ANON_64_cfm', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 454, 20), )

    
    cfm = property(__cfm.value, __cfm.set, None, '\n                          Constraint force mixing for constrained directions\n                        ')

    
    # Element erp uses Python identifier erp
    __erp = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'erp'), 'erp', '__AbsentNamespace0_CTD_ANON_64_erp', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 463, 20), )

    
    erp = property(__erp.value, __erp.set, None, '\n                          Error reduction parameter for constrained directions\n                        ')

    
    # Element bounce uses Python identifier bounce
    __bounce = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'bounce'), 'bounce', '__AbsentNamespace0_CTD_ANON_64_bounce', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 472, 20), )

    
    bounce = property(__bounce.value, __bounce.set, None, '\n                          Bounciness of the limits\n                        ')

    
    # Element max_force uses Python identifier max_force
    __max_force = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'max_force'), 'max_force', '__AbsentNamespace0_CTD_ANON_64_max_force', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 481, 20), )

    
    max_force = property(__max_force.value, __max_force.set, None, '\n                          Maximum force or torque used to reach the desired velocity.\n                        ')

    
    # Element velocity uses Python identifier velocity
    __velocity = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'velocity'), 'velocity', '__AbsentNamespace0_CTD_ANON_64_velocity', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 490, 20), )

    
    velocity = property(__velocity.value, __velocity.set, None, '\n                          The desired velocity of the joint. Should only be set if you want the joint to move on load.\n                        ')

    
    # Element limit uses Python identifier limit
    __limit = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'limit'), 'limit', '__AbsentNamespace0_CTD_ANON_64_limit', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 499, 20), )

    
    limit = property(__limit.value, __limit.set, None, None)

    
    # Element suspension uses Python identifier suspension
    __suspension = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'suspension'), 'suspension', '__AbsentNamespace0_CTD_ANON_64_suspension', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 525, 20), )

    
    suspension = property(__suspension.value, __suspension.set, None, None)

    _ElementMap.update({
        __provide_feedback.name() : __provide_feedback,
        __cfm_damping.name() : __cfm_damping,
        __implicit_spring_damper.name() : __implicit_spring_damper,
        __fudge_factor.name() : __fudge_factor,
        __cfm.name() : __cfm,
        __erp.name() : __erp,
        __bounce.name() : __bounce,
        __max_force.name() : __max_force,
        __velocity.name() : __velocity,
        __limit.name() : __limit,
        __suspension.name() : __suspension
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_64 = CTD_ANON_64


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_65 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 500, 22)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element cfm uses Python identifier cfm
    __cfm = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'cfm'), 'cfm', '__AbsentNamespace0_CTD_ANON_65_cfm', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 503, 26), )

    
    cfm = property(__cfm.value, __cfm.set, None, '\n                                Constraint force mixing parameter used by the joint stop\n                              ')

    
    # Element erp uses Python identifier erp
    __erp = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'erp'), 'erp', '__AbsentNamespace0_CTD_ANON_65_erp', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 512, 26), )

    
    erp = property(__erp.value, __erp.set, None, '\n                                Error reduction parameter used by the joint stop\n                              ')

    _ElementMap.update({
        __cfm.name() : __cfm,
        __erp.name() : __erp
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_65 = CTD_ANON_65


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_66 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 526, 22)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element cfm uses Python identifier cfm
    __cfm = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'cfm'), 'cfm', '__AbsentNamespace0_CTD_ANON_66_cfm', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 529, 26), )

    
    cfm = property(__cfm.value, __cfm.set, None, '\n                                Suspension constraint force mixing parameter\n                              ')

    
    # Element erp uses Python identifier erp
    __erp = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'erp'), 'erp', '__AbsentNamespace0_CTD_ANON_66_erp', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 538, 26), )

    
    erp = property(__erp.value, __erp.set, None, '\n                                Suspension error reduction parameter\n                              ')

    _ElementMap.update({
        __cfm.name() : __cfm,
        __erp.name() : __erp
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_66 = CTD_ANON_66


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_67 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element cast_shadows uses Python identifier cast_shadows
    __cast_shadows = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'cast_shadows'), 'cast_shadows', '__AbsentNamespace0_CTD_ANON_67_cast_shadows', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 13, 8), )

    
    cast_shadows = property(__cast_shadows.value, __cast_shadows.set, None, '\n              When true, the light will cast shadows.\n            ')

    
    # Element pose uses Python identifier pose
    __pose = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'pose'), 'pose', '__AbsentNamespace0_CTD_ANON_67_pose', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 22, 8), )

    
    pose = property(__pose.value, __pose.set, None, '\n              A position and orientation in the global coordinate frame for the light.\n            ')

    
    # Element diffuse uses Python identifier diffuse
    __diffuse = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'diffuse'), 'diffuse', '__AbsentNamespace0_CTD_ANON_67_diffuse', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 31, 8), )

    
    diffuse = property(__diffuse.value, __diffuse.set, None, '\n              Diffuse light color\n            ')

    
    # Element specular uses Python identifier specular
    __specular = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'specular'), 'specular', '__AbsentNamespace0_CTD_ANON_67_specular', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 40, 8), )

    
    specular = property(__specular.value, __specular.set, None, '\n              Specular light color\n            ')

    
    # Element attenuation uses Python identifier attenuation
    __attenuation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'attenuation'), 'attenuation', '__AbsentNamespace0_CTD_ANON_67_attenuation', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 49, 8), )

    
    attenuation = property(__attenuation.value, __attenuation.set, None, '\n              Light attenuation\n            ')

    
    # Element direction uses Python identifier direction
    __direction = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'direction'), 'direction', '__AbsentNamespace0_CTD_ANON_67_direction', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 98, 8), )

    
    direction = property(__direction.value, __direction.set, None, '\n              Direction of the light, only applicable for spot and directional lights.\n            ')

    
    # Element spot uses Python identifier spot
    __spot = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'spot'), 'spot', '__AbsentNamespace0_CTD_ANON_67_spot', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 107, 8), )

    
    spot = property(__spot.value, __spot.set, None, '\n              Spot light parameters\n            ')

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_67_name', pyxb.binding.datatypes.string, unicode_default='__default__')
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 147, 6)
    __name._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 147, 6)
    
    name = property(__name.value, __name.set, None, '\n            A unique name for the light.\n          ')

    
    # Attribute type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'type'), 'type', '__AbsentNamespace0_CTD_ANON_67_type', pyxb.binding.datatypes.string, required=True)
    __type._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 154, 6)
    __type._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 154, 6)
    
    type = property(__type.value, __type.set, None, '\n            The light type: point, directional, spot.\n          ')

    _ElementMap.update({
        __cast_shadows.name() : __cast_shadows,
        __pose.name() : __pose,
        __diffuse.name() : __diffuse,
        __specular.name() : __specular,
        __attenuation.name() : __attenuation,
        __direction.name() : __direction,
        __spot.name() : __spot
    })
    _AttributeMap.update({
        __name.name() : __name,
        __type.name() : __type
    })
_module_typeBindings.CTD_ANON_67 = CTD_ANON_67


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_68 (pyxb.binding.basis.complexTypeDefinition):
    """
              Light attenuation
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 55, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element range uses Python identifier range
    __range = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'range'), 'range', '__AbsentNamespace0_CTD_ANON_68_range', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 58, 14), )

    
    range = property(__range.value, __range.set, None, '\n                    Range of the light\n                  ')

    
    # Element linear uses Python identifier linear
    __linear = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'linear'), 'linear', '__AbsentNamespace0_CTD_ANON_68_linear', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 67, 14), )

    
    linear = property(__linear.value, __linear.set, None, '\n                    The linear attenuation factor: 1 means attenuate evenly over the distance.\n                  ')

    
    # Element constant uses Python identifier constant
    __constant = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'constant'), 'constant', '__AbsentNamespace0_CTD_ANON_68_constant', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 76, 14), )

    
    constant = property(__constant.value, __constant.set, None, '\n                    The constant attenuation factor: 1.0 means never attenuate, 0.0 is complete attenutation.\n                  ')

    
    # Element quadratic uses Python identifier quadratic
    __quadratic = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'quadratic'), 'quadratic', '__AbsentNamespace0_CTD_ANON_68_quadratic', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 85, 14), )

    
    quadratic = property(__quadratic.value, __quadratic.set, None, '\n                    The quadratic attenuation factor: adds a curvature to the attenuation.\n                  ')

    _ElementMap.update({
        __range.name() : __range,
        __linear.name() : __linear,
        __constant.name() : __constant,
        __quadratic.name() : __quadratic
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_68 = CTD_ANON_68


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_69 (pyxb.binding.basis.complexTypeDefinition):
    """
              Spot light parameters
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 113, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element inner_angle uses Python identifier inner_angle
    __inner_angle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'inner_angle'), 'inner_angle', '__AbsentNamespace0_CTD_ANON_69_inner_angle', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 116, 14), )

    
    inner_angle = property(__inner_angle.value, __inner_angle.set, None, '\n                    Angle covered by the bright inner cone\n                  ')

    
    # Element outer_angle uses Python identifier outer_angle
    __outer_angle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'outer_angle'), 'outer_angle', '__AbsentNamespace0_CTD_ANON_69_outer_angle', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 125, 14), )

    
    outer_angle = property(__outer_angle.value, __outer_angle.set, None, '\n                    Angle covered by the outer cone\n                  ')

    
    # Element falloff uses Python identifier falloff
    __falloff = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'falloff'), 'falloff', '__AbsentNamespace0_CTD_ANON_69_falloff', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 134, 14), )

    
    falloff = property(__falloff.value, __falloff.set, None, '\n                    The rate of falloff between the inner and outer cones. 1.0 means a linear falloff, less means slower falloff, higher means faster falloff.\n                  ')

    _ElementMap.update({
        __inner_angle.name() : __inner_angle,
        __outer_angle.name() : __outer_angle,
        __falloff.name() : __falloff
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_69 = CTD_ANON_69


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_70 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 17, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element audio_sink uses Python identifier audio_sink
    __audio_sink = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'audio_sink'), 'audio_sink', '__AbsentNamespace0_CTD_ANON_70_audio_sink', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_sink.xsd', 9, 2), )

    
    audio_sink = property(__audio_sink.value, __audio_sink.set, None, None)

    
    # Element audio_source uses Python identifier audio_source
    __audio_source = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'audio_source'), 'audio_source', '__AbsentNamespace0_CTD_ANON_70_audio_source', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 9, 2), )

    
    audio_source = property(__audio_source.value, __audio_source.set, None, None)

    
    # Element collision uses Python identifier collision
    __collision = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'collision'), 'collision', '__AbsentNamespace0_CTD_ANON_70_collision', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/collision.xsd', 11, 2), )

    
    collision = property(__collision.value, __collision.set, None, None)

    
    # Element inertial uses Python identifier inertial
    __inertial = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'inertial'), 'inertial', '__AbsentNamespace0_CTD_ANON_70_inertial', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 9, 2), )

    
    inertial = property(__inertial.value, __inertial.set, None, None)

    
    # Element gravity uses Python identifier gravity
    __gravity = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'gravity'), 'gravity', '__AbsentNamespace0_CTD_ANON_70_gravity', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 20, 8), )

    
    gravity = property(__gravity.value, __gravity.set, None, '\n              If true, the link is affected by gravity.\n            ')

    
    # Element self_collide uses Python identifier self_collide
    __self_collide = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'self_collide'), 'self_collide', '__AbsentNamespace0_CTD_ANON_70_self_collide', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 29, 8), )

    
    self_collide = property(__self_collide.value, __self_collide.set, None, '\n              If true, the link can collide with other links in the model. Two links within a model will collide if link1.self_collide OR link2.self_collide. Links connected by a joint will never collide.\n            ')

    
    # Element kinematic uses Python identifier kinematic
    __kinematic = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'kinematic'), 'kinematic', '__AbsentNamespace0_CTD_ANON_70_kinematic', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 38, 8), )

    
    kinematic = property(__kinematic.value, __kinematic.set, None, '\n              If true, the link is kinematic only\n            ')

    
    # Element pose uses Python identifier pose
    __pose = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'pose'), 'pose', '__AbsentNamespace0_CTD_ANON_70_pose', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 47, 8), )

    
    pose = property(__pose.value, __pose.set, None, '\n              This is the pose of the link reference frame, relative to the model reference frame.\n            ')

    
    # Element must_be_base_link uses Python identifier must_be_base_link
    __must_be_base_link = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'must_be_base_link'), 'must_be_base_link', '__AbsentNamespace0_CTD_ANON_70_must_be_base_link', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 56, 8), )

    
    must_be_base_link = property(__must_be_base_link.value, __must_be_base_link.set, None, '\n              If true, the link will have 6DOF and be a direct child of world.\n            ')

    
    # Element velocity_decay uses Python identifier velocity_decay
    __velocity_decay = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'velocity_decay'), 'velocity_decay', '__AbsentNamespace0_CTD_ANON_70_velocity_decay', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 65, 8), )

    
    velocity_decay = property(__velocity_decay.value, __velocity_decay.set, None, "\n              Exponential damping of the link's velocity.\n            ")

    
    # Element projector uses Python identifier projector
    __projector = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'projector'), 'projector', '__AbsentNamespace0_CTD_ANON_70_projector', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 5, 2), )

    
    projector = property(__projector.value, __projector.set, None, None)

    
    # Element sensor uses Python identifier sensor
    __sensor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'sensor'), 'sensor', '__AbsentNamespace0_CTD_ANON_70_sensor', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 23, 2), )

    
    sensor = property(__sensor.value, __sensor.set, None, None)

    
    # Element visual uses Python identifier visual
    __visual = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'visual'), 'visual', '__AbsentNamespace0_CTD_ANON_70_visual', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 12, 2), )

    
    visual = property(__visual.value, __visual.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_70_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 103, 6)
    __name._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 103, 6)
    
    name = property(__name.value, __name.set, None, '\n            A unique name for the link within the scope of the model.\n          ')

    _ElementMap.update({
        __audio_sink.name() : __audio_sink,
        __audio_source.name() : __audio_source,
        __collision.name() : __collision,
        __inertial.name() : __inertial,
        __gravity.name() : __gravity,
        __self_collide.name() : __self_collide,
        __kinematic.name() : __kinematic,
        __pose.name() : __pose,
        __must_be_base_link.name() : __must_be_base_link,
        __velocity_decay.name() : __velocity_decay,
        __projector.name() : __projector,
        __sensor.name() : __sensor,
        __visual.name() : __visual
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_module_typeBindings.CTD_ANON_70 = CTD_ANON_70


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_71 (pyxb.binding.basis.complexTypeDefinition):
    """
              Exponential damping of the link's velocity.
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 71, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element linear uses Python identifier linear
    __linear = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'linear'), 'linear', '__AbsentNamespace0_CTD_ANON_71_linear', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 74, 14), )

    
    linear = property(__linear.value, __linear.set, None, '\n                    Linear damping\n                  ')

    
    # Element angular uses Python identifier angular
    __angular = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'angular'), 'angular', '__AbsentNamespace0_CTD_ANON_71_angular', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 83, 14), )

    
    angular = property(__angular.value, __angular.set, None, '\n                    Angular damping\n                  ')

    _ElementMap.update({
        __linear.name() : __linear,
        __angular.name() : __angular
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_71 = CTD_ANON_71


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_72 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/logical_camera.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element near uses Python identifier near
    __near = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'near'), 'near', '__AbsentNamespace0_CTD_ANON_72_near', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/logical_camera.xsd', 13, 8), )

    
    near = property(__near.value, __near.set, None, '\n              Near clipping distance of the view frustum\n            ')

    
    # Element far uses Python identifier far
    __far = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'far'), 'far', '__AbsentNamespace0_CTD_ANON_72_far', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/logical_camera.xsd', 22, 8), )

    
    far = property(__far.value, __far.set, None, '\n              Far clipping distance of the view frustum\n            ')

    
    # Element aspect_ratio uses Python identifier aspect_ratio
    __aspect_ratio = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'aspect_ratio'), 'aspect_ratio', '__AbsentNamespace0_CTD_ANON_72_aspect_ratio', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/logical_camera.xsd', 31, 8), )

    
    aspect_ratio = property(__aspect_ratio.value, __aspect_ratio.set, None, '\n              Aspect ratio of the near and far planes. This is the width divided by the height of the near or far planes.\n            ')

    
    # Element horizontal_fov uses Python identifier horizontal_fov
    __horizontal_fov = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'horizontal_fov'), 'horizontal_fov', '__AbsentNamespace0_CTD_ANON_72_horizontal_fov', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/logical_camera.xsd', 40, 8), )

    
    horizontal_fov = property(__horizontal_fov.value, __horizontal_fov.set, None, "\n              Horizontal field of view of the frustum, in radians. This is the angle between the frustum's vertex and the edges of the near or far plane.\n            ")

    _ElementMap.update({
        __near.name() : __near,
        __far.name() : __far,
        __aspect_ratio.name() : __aspect_ratio,
        __horizontal_fov.name() : __horizontal_fov
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_72 = CTD_ANON_72


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_73 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/magnetometer.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element x uses Python identifier x
    __x = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'x'), 'x', '__AbsentNamespace0_CTD_ANON_73_x', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/magnetometer.xsd', 13, 8), )

    
    x = property(__x.value, __x.set, None, '\n              \n      Parameters related to the body-frame X axis of the magnetometer\n    \n            ')

    
    # Element y uses Python identifier y
    __y = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'y'), 'y', '__AbsentNamespace0_CTD_ANON_73_y', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/magnetometer.xsd', 28, 8), )

    
    y = property(__y.value, __y.set, None, '\n              \n      Parameters related to the body-frame Y axis of the magnetometer\n    \n            ')

    
    # Element z uses Python identifier z
    __z = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'z'), 'z', '__AbsentNamespace0_CTD_ANON_73_z', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/magnetometer.xsd', 43, 8), )

    
    z = property(__z.value, __z.set, None, '\n              \n      Parameters related to the body-frame Z axis of the magnetometer\n    \n            ')

    _ElementMap.update({
        __x.name() : __x,
        __y.name() : __y,
        __z.name() : __z
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_73 = CTD_ANON_73


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_74 (pyxb.binding.basis.complexTypeDefinition):
    """
              
      Parameters related to the body-frame X axis of the magnetometer
    
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/magnetometer.xsd', 21, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_74 = CTD_ANON_74


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_75 (pyxb.binding.basis.complexTypeDefinition):
    """
              
      Parameters related to the body-frame Y axis of the magnetometer
    
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/magnetometer.xsd', 36, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_75 = CTD_ANON_75


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_76 (pyxb.binding.basis.complexTypeDefinition):
    """
              
      Parameters related to the body-frame Z axis of the magnetometer
    
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/magnetometer.xsd', 51, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_76 = CTD_ANON_76


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_77 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element script uses Python identifier script
    __script = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'script'), 'script', '__AbsentNamespace0_CTD_ANON_77_script', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 13, 8), )

    
    script = property(__script.value, __script.set, None, '\n              Name of material from an installed script file. This will override the color element if the script exists.\n            ')

    
    # Element shader uses Python identifier shader
    __shader = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'shader'), 'shader', '__AbsentNamespace0_CTD_ANON_77_shader', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 44, 8), )

    
    shader = property(__shader.value, __shader.set, None, None)

    
    # Element lighting uses Python identifier lighting
    __lighting = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'lighting'), 'lighting', '__AbsentNamespace0_CTD_ANON_77_lighting', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 68, 8), )

    
    lighting = property(__lighting.value, __lighting.set, None, '\n              If false, dynamic lighting will be disabled\n            ')

    
    # Element ambient uses Python identifier ambient
    __ambient = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ambient'), 'ambient', '__AbsentNamespace0_CTD_ANON_77_ambient', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 77, 8), )

    
    ambient = property(__ambient.value, __ambient.set, None, '\n              The ambient color of a material specified by set of four numbers representing red/green/blue, each in the range of [0,1].\n            ')

    
    # Element diffuse uses Python identifier diffuse
    __diffuse = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'diffuse'), 'diffuse', '__AbsentNamespace0_CTD_ANON_77_diffuse', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 86, 8), )

    
    diffuse = property(__diffuse.value, __diffuse.set, None, '\n              The diffuse color of a material specified by set of four numbers representing red/green/blue/alpha, each in the range of [0,1].\n            ')

    
    # Element specular uses Python identifier specular
    __specular = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'specular'), 'specular', '__AbsentNamespace0_CTD_ANON_77_specular', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 95, 8), )

    
    specular = property(__specular.value, __specular.set, None, '\n              The specular color of a material specified by set of four numbers representing red/green/blue/alpha, each in the range of [0,1].\n            ')

    
    # Element emissive uses Python identifier emissive
    __emissive = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'emissive'), 'emissive', '__AbsentNamespace0_CTD_ANON_77_emissive', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 104, 8), )

    
    emissive = property(__emissive.value, __emissive.set, None, '\n              The emissive color of a material specified by set of four numbers representing red/green/blue, each in the range of [0,1].\n            ')

    _ElementMap.update({
        __script.name() : __script,
        __shader.name() : __shader,
        __lighting.name() : __lighting,
        __ambient.name() : __ambient,
        __diffuse.name() : __diffuse,
        __specular.name() : __specular,
        __emissive.name() : __emissive
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_77 = CTD_ANON_77


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_78 (pyxb.binding.basis.complexTypeDefinition):
    """
              Name of material from an installed script file. This will override the color element if the script exists.
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 19, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element uri uses Python identifier uri
    __uri = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'uri'), 'uri', '__AbsentNamespace0_CTD_ANON_78_uri', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 22, 14), )

    
    uri = property(__uri.value, __uri.set, None, '\n                    URI of the material script file\n                  ')

    
    # Element name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_78_name', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 31, 14), )

    
    name = property(__name.value, __name.set, None, '\n                    Name of the script within the script file\n                  ')

    _ElementMap.update({
        __uri.name() : __uri,
        __name.name() : __name
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_78 = CTD_ANON_78


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_79 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 45, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element normal_map uses Python identifier normal_map
    __normal_map = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'normal_map'), 'normal_map', '__AbsentNamespace0_CTD_ANON_79_normal_map', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 48, 14), )

    
    normal_map = property(__normal_map.value, __normal_map.set, None, '\n                    filename of the normal map\n                  ')

    
    # Attribute type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'type'), 'type', '__AbsentNamespace0_CTD_ANON_79_type', pyxb.binding.datatypes.string, required=True)
    __type._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 57, 12)
    __type._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 57, 12)
    
    type = property(__type.value, __type.set, None, '\n                  vertex, pixel, normal_map_objectspace, normal_map_tangentspace\n                ')

    _ElementMap.update({
        __normal_map.name() : __normal_map
    })
    _AttributeMap.update({
        __type.name() : __type
    })
_module_typeBindings.CTD_ANON_79 = CTD_ANON_79


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_80 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/mesh_shape.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element uri uses Python identifier uri
    __uri = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'uri'), 'uri', '__AbsentNamespace0_CTD_ANON_80_uri', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/mesh_shape.xsd', 13, 8), )

    
    uri = property(__uri.value, __uri.set, None, '\n              Mesh uri\n            ')

    
    # Element submesh uses Python identifier submesh
    __submesh = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'submesh'), 'submesh', '__AbsentNamespace0_CTD_ANON_80_submesh', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/mesh_shape.xsd', 22, 8), )

    
    submesh = property(__submesh.value, __submesh.set, None, '\n              Use a named submesh. The submesh must exist in the mesh specified by the uri\n            ')

    
    # Element scale uses Python identifier scale
    __scale = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'scale'), 'scale', '__AbsentNamespace0_CTD_ANON_80_scale', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/mesh_shape.xsd', 53, 8), )

    
    scale = property(__scale.value, __scale.set, None, '\n              Scaling factor applied to the mesh\n            ')

    _ElementMap.update({
        __uri.name() : __uri,
        __submesh.name() : __submesh,
        __scale.name() : __scale
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_80 = CTD_ANON_80


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_81 (pyxb.binding.basis.complexTypeDefinition):
    """
              Use a named submesh. The submesh must exist in the mesh specified by the uri
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/mesh_shape.xsd', 28, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_81_name', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/mesh_shape.xsd', 31, 14), )

    
    name = property(__name.value, __name.set, None, '\n                    Name of the submesh within the parent mesh\n                  ')

    
    # Element center uses Python identifier center
    __center = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'center'), 'center', '__AbsentNamespace0_CTD_ANON_81_center', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/mesh_shape.xsd', 40, 14), )

    
    center = property(__center.value, __center.set, None, '\n                    Set to true to center the vertices of the submesh at 0,0,0. This will effectively remove any transformations on the submesh before the poses from parent links and models are applied.\n                  ')

    _ElementMap.update({
        __name.name() : __name,
        __center.name() : __center
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_81 = CTD_ANON_81


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_82 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 14, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element gripper uses Python identifier gripper
    __gripper = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'gripper'), 'gripper', '__AbsentNamespace0_CTD_ANON_82_gripper', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 4, 2), )

    
    gripper = property(__gripper.value, __gripper.set, None, None)

    
    # Element joint uses Python identifier joint
    __joint = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'joint'), 'joint', '__AbsentNamespace0_CTD_ANON_82_joint', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 10, 2), )

    
    joint = property(__joint.value, __joint.set, None, None)

    
    # Element link uses Python identifier link
    __link = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'link'), 'link', '__AbsentNamespace0_CTD_ANON_82_link', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 16, 2), )

    
    link = property(__link.value, __link.set, None, None)

    
    # Element static uses Python identifier static
    __static = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'static'), 'static', '__AbsentNamespace0_CTD_ANON_82_static', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 17, 8), )

    
    static = property(__static.value, __static.set, None, '\n              If set to true, the model is immovable. Otherwise the model is simulated in the dynamics engine.\n            ')

    
    # Element self_collide uses Python identifier self_collide
    __self_collide = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'self_collide'), 'self_collide', '__AbsentNamespace0_CTD_ANON_82_self_collide', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 26, 8), )

    
    self_collide = property(__self_collide.value, __self_collide.set, None, '\n              If set to true, all links in the model will collide with each other (except those connected by a joint). Can be overridden by the link or collision element self_collide property. Two links within a model will collide if link1.self_collide OR link2.self_collide. Links connected by a joint will never collide.\n            ')

    
    # Element allow_auto_disable uses Python identifier allow_auto_disable
    __allow_auto_disable = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'allow_auto_disable'), 'allow_auto_disable', '__AbsentNamespace0_CTD_ANON_82_allow_auto_disable', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 35, 8), )

    
    allow_auto_disable = property(__allow_auto_disable.value, __allow_auto_disable.set, None, '\n              Allows a model to auto-disable, which is means the physics engine can skip updating the model when the model is at rest. This parameter is only used by models with no joints.\n            ')

    
    # Element pose uses Python identifier pose
    __pose = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'pose'), 'pose', '__AbsentNamespace0_CTD_ANON_82_pose', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 44, 8), )

    
    pose = property(__pose.value, __pose.set, None, '\n              A position and orientation in the global coordinate frame for the model. Position(x,y,z) and rotation (roll, pitch yaw) in the global coordinate frame.\n            ')

    
    # Element include uses Python identifier include
    __include = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'include'), 'include', '__AbsentNamespace0_CTD_ANON_82_include', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 53, 8), )

    
    include = property(__include.value, __include.set, None, '\n              Include resources from a URI. This can be used to nest models.\n            ')

    
    # Element plugin uses Python identifier plugin
    __plugin = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'plugin'), 'plugin', '__AbsentNamespace0_CTD_ANON_82_plugin', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/plugin.xsd', 9, 2), )

    
    plugin = property(__plugin.value, __plugin.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_82_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 106, 6)
    __name._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 106, 6)
    
    name = property(__name.value, __name.set, None, '\n            A unique name for the model. This name must not match another model in the world.\n          ')

    _ElementMap.update({
        __gripper.name() : __gripper,
        __joint.name() : __joint,
        __link.name() : __link,
        __static.name() : __static,
        __self_collide.name() : __self_collide,
        __allow_auto_disable.name() : __allow_auto_disable,
        __pose.name() : __pose,
        __include.name() : __include,
        __plugin.name() : __plugin
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_module_typeBindings.CTD_ANON_82 = CTD_ANON_82


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_83 (pyxb.binding.basis.complexTypeDefinition):
    """
              Include resources from a URI. This can be used to nest models.
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 59, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element uri uses Python identifier uri
    __uri = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'uri'), 'uri', '__AbsentNamespace0_CTD_ANON_83_uri', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 62, 14), )

    
    uri = property(__uri.value, __uri.set, None, '\n                    URI to a resource, such as a model\n                  ')

    
    # Element pose uses Python identifier pose
    __pose = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'pose'), 'pose', '__AbsentNamespace0_CTD_ANON_83_pose', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 71, 14), )

    
    pose = property(__pose.value, __pose.set, None, '\n                    Override the pose of the included model. A position and orientation in the global coordinate frame for the model. Position(x,y,z) and rotation (roll, pitch yaw) in the global coordinate frame.\n                  ')

    
    # Element name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_83_name', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 80, 14), )

    
    name = property(__name.value, __name.set, None, '\n                    Override the name of the included model.\n                  ')

    
    # Element static uses Python identifier static
    __static = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'static'), 'static', '__AbsentNamespace0_CTD_ANON_83_static', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 89, 14), )

    
    static = property(__static.value, __static.set, None, '\n                    Override the static value of the included model.\n                  ')

    _ElementMap.update({
        __uri.name() : __uri,
        __pose.name() : __pose,
        __name.name() : __name,
        __static.name() : __static
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_83 = CTD_ANON_83


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_84 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element max_step_size uses Python identifier max_step_size
    __max_step_size = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'max_step_size'), 'max_step_size', '__AbsentNamespace0_CTD_ANON_84_max_step_size', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 13, 8), )

    
    max_step_size = property(__max_step_size.value, __max_step_size.set, None, "\n              Maximum time step size at which every system in simulation can interact with the states of the world.  (was physics.sdf's dt).\n            ")

    
    # Element real_time_factor uses Python identifier real_time_factor
    __real_time_factor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'real_time_factor'), 'real_time_factor', '__AbsentNamespace0_CTD_ANON_84_real_time_factor', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 22, 8), )

    
    real_time_factor = property(__real_time_factor.value, __real_time_factor.set, None, '\n              target simulation speedup factor, defined by ratio of simulation time to real-time.\n            ')

    
    # Element real_time_update_rate uses Python identifier real_time_update_rate
    __real_time_update_rate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'real_time_update_rate'), 'real_time_update_rate', '__AbsentNamespace0_CTD_ANON_84_real_time_update_rate', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 31, 8), )

    
    real_time_update_rate = property(__real_time_update_rate.value, __real_time_update_rate.set, None, "\n              Rate at which to update the physics engine (UpdatePhysics calls per real-time second). (was physics.sdf's update_rate).\n            ")

    
    # Element max_contacts uses Python identifier max_contacts
    __max_contacts = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'max_contacts'), 'max_contacts', '__AbsentNamespace0_CTD_ANON_84_max_contacts', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 40, 8), )

    
    max_contacts = property(__max_contacts.value, __max_contacts.set, None, '\n              Maximum number of contacts allowed between two entities. This value can be over ridden by a max_contacts element in a collision element.\n            ')

    
    # Element gravity uses Python identifier gravity
    __gravity = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'gravity'), 'gravity', '__AbsentNamespace0_CTD_ANON_84_gravity', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 49, 8), )

    
    gravity = property(__gravity.value, __gravity.set, None, '\n              The gravity vector in m/s^2, expressed in a coordinate frame defined by the spherical_coordinates tag.\n            ')

    
    # Element magnetic_field uses Python identifier magnetic_field
    __magnetic_field = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'magnetic_field'), 'magnetic_field', '__AbsentNamespace0_CTD_ANON_84_magnetic_field', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 58, 8), )

    
    magnetic_field = property(__magnetic_field.value, __magnetic_field.set, None, '\n              The magnetic vector in Tesla, expressed in a coordinate frame defined by the spherical_coordinates tag.\n            ')

    
    # Element simbody uses Python identifier simbody
    __simbody = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'simbody'), 'simbody', '__AbsentNamespace0_CTD_ANON_84_simbody', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 67, 8), )

    
    simbody = property(__simbody.value, __simbody.set, None, '\n              Simbody specific physics properties\n            ')

    
    # Element bullet uses Python identifier bullet
    __bullet = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'bullet'), 'bullet', '__AbsentNamespace0_CTD_ANON_84_bullet', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 232, 8), )

    
    bullet = property(__bullet.value, __bullet.set, None, '\n              Bullet specific physics properties\n            ')

    
    # Element ode uses Python identifier ode
    __ode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ode'), 'ode', '__AbsentNamespace0_CTD_ANON_84_ode', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 347, 8), )

    
    ode = property(__ode.value, __ode.set, None, '\n              ODE specific physics properties\n            ')

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_84_name', pyxb.binding.datatypes.string, unicode_default='default_physics')
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 475, 6)
    __name._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 475, 6)
    
    name = property(__name.value, __name.set, None, '\n            The name of this set of physics parameters.\n          ')

    
    # Attribute default uses Python identifier default
    __default = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'default'), 'default', '__AbsentNamespace0_CTD_ANON_84_default', pyxb.binding.datatypes.boolean, unicode_default='false')
    __default._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 482, 6)
    __default._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 482, 6)
    
    default = property(__default.value, __default.set, None, '\n            If true, this physics element is set as the default physics profile for the world. If multiple default physics elements exist, the first element marked as default is chosen. If no default physics element exists, the first physics element is chosen.\n          ')

    
    # Attribute type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'type'), 'type', '__AbsentNamespace0_CTD_ANON_84_type', pyxb.binding.datatypes.string, required=True)
    __type._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 489, 6)
    __type._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 489, 6)
    
    type = property(__type.value, __type.set, None, '\n            The type of the dynamics engine. Current options are ode, bullet, simbody and rtql8.  Defaults to ode if left unspecified.\n          ')

    _ElementMap.update({
        __max_step_size.name() : __max_step_size,
        __real_time_factor.name() : __real_time_factor,
        __real_time_update_rate.name() : __real_time_update_rate,
        __max_contacts.name() : __max_contacts,
        __gravity.name() : __gravity,
        __magnetic_field.name() : __magnetic_field,
        __simbody.name() : __simbody,
        __bullet.name() : __bullet,
        __ode.name() : __ode
    })
    _AttributeMap.update({
        __name.name() : __name,
        __default.name() : __default,
        __type.name() : __type
    })
_module_typeBindings.CTD_ANON_84 = CTD_ANON_84


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_85 (pyxb.binding.basis.complexTypeDefinition):
    """
              Simbody specific physics properties
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 73, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element min_step_size uses Python identifier min_step_size
    __min_step_size = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'min_step_size'), 'min_step_size', '__AbsentNamespace0_CTD_ANON_85_min_step_size', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 76, 14), )

    
    min_step_size = property(__min_step_size.value, __min_step_size.set, None, '\n                    (Currently not used in simbody) The time duration which advances with each iteration of the dynamics engine, this has to be no bigger than max_step_size under physics block.  If left unspecified, min_step_size defaults to max_step_size.\n                  ')

    
    # Element accuracy uses Python identifier accuracy
    __accuracy = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'accuracy'), 'accuracy', '__AbsentNamespace0_CTD_ANON_85_accuracy', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 85, 14), )

    
    accuracy = property(__accuracy.value, __accuracy.set, None, '\n                    Roughly the relative error of the system.\n        -LOG(accuracy) is roughly the number of significant digits.\n                  ')

    
    # Element max_transient_velocity uses Python identifier max_transient_velocity
    __max_transient_velocity = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'max_transient_velocity'), 'max_transient_velocity', '__AbsentNamespace0_CTD_ANON_85_max_transient_velocity', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 95, 14), )

    
    max_transient_velocity = property(__max_transient_velocity.value, __max_transient_velocity.set, None, '\n                    Tolerable "slip" velocity allowed by the solver when static\n        friction is supposed to hold object in place.\n                  ')

    
    # Element contact uses Python identifier contact
    __contact = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'contact'), 'contact', '__AbsentNamespace0_CTD_ANON_85_contact', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 105, 14), )

    
    contact = property(__contact.value, __contact.set, None, '\n                    \n        Relationship among dissipation, coef. restitution, etc.\n        d = dissipation coefficient (1/velocity)\n        vc = capture velocity (velocity where e=e_max)\n        vp = plastic velocity (smallest v where e=e_min) > vc\n        Assume real COR=1 when v=0.\n        e_min = given minimum COR, at v >= vp (a.k.a. plastic_coef_restitution)\n        d = slope = (1-e_min)/vp\n        OR, e_min = 1 - d*vp\n        e_max = maximum COR = 1-d*vc, reached at v=vc\n        e = 0,                       v <= vc\n          = 1 - d*v,               vc < v < vp\n          = e_min,                   v >= vp\n  \n        dissipation factor = d*min(v,vp)   [compliant]\n        cor = e                            [rigid]\n  \n        Combining rule e = 0,               e1==e2==0\n                         = 2*e1*e2/(e1+e2), otherwise\n                  ')

    _ElementMap.update({
        __min_step_size.name() : __min_step_size,
        __accuracy.name() : __accuracy,
        __max_transient_velocity.name() : __max_transient_velocity,
        __contact.name() : __contact
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_85 = CTD_ANON_85


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_86 (pyxb.binding.basis.complexTypeDefinition):
    """
                    
        Relationship among dissipation, coef. restitution, etc.
        d = dissipation coefficient (1/velocity)
        vc = capture velocity (velocity where e=e_max)
        vp = plastic velocity (smallest v where e=e_min) > vc
        Assume real COR=1 when v=0.
        e_min = given minimum COR, at v >= vp (a.k.a. plastic_coef_restitution)
        d = slope = (1-e_min)/vp
        OR, e_min = 1 - d*vp
        e_max = maximum COR = 1-d*vc, reached at v=vc
        e = 0,                       v <= vc
          = 1 - d*v,               vc < v < vp
          = e_min,                   v >= vp
  
        dissipation factor = d*min(v,vp)   [compliant]
        cor = e                            [rigid]
  
        Combining rule e = 0,               e1==e2==0
                         = 2*e1*e2/(e1+e2), otherwise
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 129, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element stiffness uses Python identifier stiffness
    __stiffness = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'stiffness'), 'stiffness', '__AbsentNamespace0_CTD_ANON_86_stiffness', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 132, 20), )

    
    stiffness = property(__stiffness.value, __stiffness.set, None, '\n                          Default contact material stiffness\n                     (force/dist or torque/radian).\n                        ')

    
    # Element dissipation uses Python identifier dissipation
    __dissipation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'dissipation'), 'dissipation', '__AbsentNamespace0_CTD_ANON_86_dissipation', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 142, 20), )

    
    dissipation = property(__dissipation.value, __dissipation.set, None, '\n                          dissipation coefficient to be used in compliant contact;\n    if not given it is (1-min_cor)/plastic_impact_velocity\n                        ')

    
    # Element plastic_coef_restitution uses Python identifier plastic_coef_restitution
    __plastic_coef_restitution = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'plastic_coef_restitution'), 'plastic_coef_restitution', '__AbsentNamespace0_CTD_ANON_86_plastic_coef_restitution', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 152, 20), )

    
    plastic_coef_restitution = property(__plastic_coef_restitution.value, __plastic_coef_restitution.set, None, '\n                          this is the COR to be used at high velocities for rigid\n    impacts; if not given it is 1 - dissipation*plastic_impact_velocity\n        \n                        ')

    
    # Element plastic_impact_velocity uses Python identifier plastic_impact_velocity
    __plastic_impact_velocity = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'plastic_impact_velocity'), 'plastic_impact_velocity', '__AbsentNamespace0_CTD_ANON_86_plastic_impact_velocity', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 163, 20), )

    
    plastic_impact_velocity = property(__plastic_impact_velocity.value, __plastic_impact_velocity.set, None, '\n                          smallest impact velocity at which min COR is reached; set\n      to zero if you want the min COR always to be used\n                        ')

    
    # Element static_friction uses Python identifier static_friction
    __static_friction = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'static_friction'), 'static_friction', '__AbsentNamespace0_CTD_ANON_86_static_friction', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 173, 20), )

    
    static_friction = property(__static_friction.value, __static_friction.set, None, '\n                          static friction (mu_s) as described by this plot: http://gazebosim.org/wiki/File:Stribeck_friction.png\n                        ')

    
    # Element dynamic_friction uses Python identifier dynamic_friction
    __dynamic_friction = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'dynamic_friction'), 'dynamic_friction', '__AbsentNamespace0_CTD_ANON_86_dynamic_friction', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 182, 20), )

    
    dynamic_friction = property(__dynamic_friction.value, __dynamic_friction.set, None, '\n                          dynamic friction (mu_d) as described by this plot: http://gazebosim.org/wiki/File:Stribeck_friction.png\n                        ')

    
    # Element viscous_friction uses Python identifier viscous_friction
    __viscous_friction = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'viscous_friction'), 'viscous_friction', '__AbsentNamespace0_CTD_ANON_86_viscous_friction', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 191, 20), )

    
    viscous_friction = property(__viscous_friction.value, __viscous_friction.set, None, '\n                          viscous friction (mu_v) with units of (1/velocity) as described by this plot: http://gazebosim.org/wiki/File:Stribeck_friction.png\n                        ')

    
    # Element override_impact_capture_velocity uses Python identifier override_impact_capture_velocity
    __override_impact_capture_velocity = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'override_impact_capture_velocity'), 'override_impact_capture_velocity', '__AbsentNamespace0_CTD_ANON_86_override_impact_capture_velocity', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 200, 20), )

    
    override_impact_capture_velocity = property(__override_impact_capture_velocity.value, __override_impact_capture_velocity.set, None, '\n                          for rigid impacts only, impact velocity at which\n          COR is set to zero; normally inherited from global default but can\n          be overridden here. Combining rule: use larger velocity\n                        ')

    
    # Element override_stiction_transition_velocity uses Python identifier override_stiction_transition_velocity
    __override_stiction_transition_velocity = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'override_stiction_transition_velocity'), 'override_stiction_transition_velocity', '__AbsentNamespace0_CTD_ANON_86_override_stiction_transition_velocity', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 211, 20), )

    
    override_stiction_transition_velocity = property(__override_stiction_transition_velocity.value, __override_stiction_transition_velocity.set, None, "\n                          This is the largest slip velocity at which\n           we'll consider a transition to stiction. Normally inherited\n           from a global default setting. For a continuous friction model\n           this is the velocity at which the max static friction force\n           is reached.  Combining rule: use larger velocity\n                        ")

    _ElementMap.update({
        __stiffness.name() : __stiffness,
        __dissipation.name() : __dissipation,
        __plastic_coef_restitution.name() : __plastic_coef_restitution,
        __plastic_impact_velocity.name() : __plastic_impact_velocity,
        __static_friction.name() : __static_friction,
        __dynamic_friction.name() : __dynamic_friction,
        __viscous_friction.name() : __viscous_friction,
        __override_impact_capture_velocity.name() : __override_impact_capture_velocity,
        __override_stiction_transition_velocity.name() : __override_stiction_transition_velocity
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_86 = CTD_ANON_86


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_87 (pyxb.binding.basis.complexTypeDefinition):
    """
              Bullet specific physics properties
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 238, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element solver uses Python identifier solver
    __solver = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'solver'), 'solver', '__AbsentNamespace0_CTD_ANON_87_solver', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 241, 14), )

    
    solver = property(__solver.value, __solver.set, None, None)

    
    # Element constraints uses Python identifier constraints
    __constraints = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'constraints'), 'constraints', '__AbsentNamespace0_CTD_ANON_87_constraints', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 285, 14), )

    
    constraints = property(__constraints.value, __constraints.set, None, '\n                    Bullet constraint parameters.\n                  ')

    _ElementMap.update({
        __solver.name() : __solver,
        __constraints.name() : __constraints
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_87 = CTD_ANON_87


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_88 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 242, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element type uses Python identifier type
    __type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'type'), 'type', '__AbsentNamespace0_CTD_ANON_88_type', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 245, 20), )

    
    type = property(__type.value, __type.set, None, '\n                          One of the following types: sequential_impulse only.\n                        ')

    
    # Element min_step_size uses Python identifier min_step_size
    __min_step_size = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'min_step_size'), 'min_step_size', '__AbsentNamespace0_CTD_ANON_88_min_step_size', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 254, 20), )

    
    min_step_size = property(__min_step_size.value, __min_step_size.set, None, '\n                          The time duration which advances with each iteration of the dynamics engine, this has to be no bigger than max_step_size under physics block.  If left unspecified, min_step_size defaults to max_step_size.\n                        ')

    
    # Element iters uses Python identifier iters
    __iters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'iters'), 'iters', '__AbsentNamespace0_CTD_ANON_88_iters', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 263, 20), )

    
    iters = property(__iters.value, __iters.set, None, '\n                          Number of iterations for each step. A higher number produces greater accuracy at a performance cost.\n                        ')

    
    # Element sor uses Python identifier sor
    __sor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'sor'), 'sor', '__AbsentNamespace0_CTD_ANON_88_sor', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 272, 20), )

    
    sor = property(__sor.value, __sor.set, None, '\n                          Set the successive over-relaxation parameter.\n                        ')

    _ElementMap.update({
        __type.name() : __type,
        __min_step_size.name() : __min_step_size,
        __iters.name() : __iters,
        __sor.name() : __sor
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_88 = CTD_ANON_88


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_89 (pyxb.binding.basis.complexTypeDefinition):
    """
                    Bullet constraint parameters.
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 291, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element cfm uses Python identifier cfm
    __cfm = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'cfm'), 'cfm', '__AbsentNamespace0_CTD_ANON_89_cfm', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 294, 20), )

    
    cfm = property(__cfm.value, __cfm.set, None, '\n                          Constraint force mixing parameter. See the ODE page for more information.\n                        ')

    
    # Element erp uses Python identifier erp
    __erp = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'erp'), 'erp', '__AbsentNamespace0_CTD_ANON_89_erp', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 303, 20), )

    
    erp = property(__erp.value, __erp.set, None, '\n                          Error reduction parameter. See the ODE page for more information.\n                        ')

    
    # Element contact_surface_layer uses Python identifier contact_surface_layer
    __contact_surface_layer = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'contact_surface_layer'), 'contact_surface_layer', '__AbsentNamespace0_CTD_ANON_89_contact_surface_layer', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 312, 20), )

    
    contact_surface_layer = property(__contact_surface_layer.value, __contact_surface_layer.set, None, '\n                          The depth of the surface layer around all geometry objects. Contacts are allowed to sink into the surface layer up to the given depth before coming to rest. The default value is zero. Increasing this to some small value (e.g. 0.001) can help prevent jittering problems due to contacts being repeatedly made and broken.\n                        ')

    
    # Element split_impulse uses Python identifier split_impulse
    __split_impulse = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'split_impulse'), 'split_impulse', '__AbsentNamespace0_CTD_ANON_89_split_impulse', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 321, 20), )

    
    split_impulse = property(__split_impulse.value, __split_impulse.set, None, "\n                          Similar to ODE's max_vel implementation. See http://web.archive.org/web/20120430155635/http://bulletphysics.org/mediawiki-1.5.8/index.php/BtContactSolverInfo#Split_Impulse for more information.\n                        ")

    
    # Element split_impulse_penetration_threshold uses Python identifier split_impulse_penetration_threshold
    __split_impulse_penetration_threshold = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'split_impulse_penetration_threshold'), 'split_impulse_penetration_threshold', '__AbsentNamespace0_CTD_ANON_89_split_impulse_penetration_threshold', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 330, 20), )

    
    split_impulse_penetration_threshold = property(__split_impulse_penetration_threshold.value, __split_impulse_penetration_threshold.set, None, "\n                          Similar to ODE's max_vel implementation.  See http://web.archive.org/web/20120430155635/http://bulletphysics.org/mediawiki-1.5.8/index.php/BtContactSolverInfo#Split_Impulse for more information.\n                        ")

    _ElementMap.update({
        __cfm.name() : __cfm,
        __erp.name() : __erp,
        __contact_surface_layer.name() : __contact_surface_layer,
        __split_impulse.name() : __split_impulse,
        __split_impulse_penetration_threshold.name() : __split_impulse_penetration_threshold
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_89 = CTD_ANON_89


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_90 (pyxb.binding.basis.complexTypeDefinition):
    """
              ODE specific physics properties
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 353, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element solver uses Python identifier solver
    __solver = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'solver'), 'solver', '__AbsentNamespace0_CTD_ANON_90_solver', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 356, 14), )

    
    solver = property(__solver.value, __solver.set, None, None)

    
    # Element constraints uses Python identifier constraints
    __constraints = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'constraints'), 'constraints', '__AbsentNamespace0_CTD_ANON_90_constraints', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 422, 14), )

    
    constraints = property(__constraints.value, __constraints.set, None, '\n                    ODE constraint parameters.\n                  ')

    _ElementMap.update({
        __solver.name() : __solver,
        __constraints.name() : __constraints
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_90 = CTD_ANON_90


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_91 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 357, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element type uses Python identifier type
    __type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'type'), 'type', '__AbsentNamespace0_CTD_ANON_91_type', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 360, 20), )

    
    type = property(__type.value, __type.set, None, '\n                          One of the following types: world, quick\n                        ')

    
    # Element min_step_size uses Python identifier min_step_size
    __min_step_size = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'min_step_size'), 'min_step_size', '__AbsentNamespace0_CTD_ANON_91_min_step_size', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 369, 20), )

    
    min_step_size = property(__min_step_size.value, __min_step_size.set, None, '\n                          The time duration which advances with each iteration of the dynamics engine, this has to be no bigger than max_step_size under physics block.  If left unspecified, min_step_size defaults to max_step_size.\n                        ')

    
    # Element iters uses Python identifier iters
    __iters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'iters'), 'iters', '__AbsentNamespace0_CTD_ANON_91_iters', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 378, 20), )

    
    iters = property(__iters.value, __iters.set, None, '\n                          Number of iterations for each step. A higher number produces greater accuracy at a performance cost.\n                        ')

    
    # Element precon_iters uses Python identifier precon_iters
    __precon_iters = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'precon_iters'), 'precon_iters', '__AbsentNamespace0_CTD_ANON_91_precon_iters', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 387, 20), )

    
    precon_iters = property(__precon_iters.value, __precon_iters.set, None, '\n                          Experimental parameter.\n                        ')

    
    # Element sor uses Python identifier sor
    __sor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'sor'), 'sor', '__AbsentNamespace0_CTD_ANON_91_sor', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 396, 20), )

    
    sor = property(__sor.value, __sor.set, None, '\n                          Set the successive over-relaxation parameter.\n                        ')

    
    # Element use_dynamic_moi_rescaling uses Python identifier use_dynamic_moi_rescaling
    __use_dynamic_moi_rescaling = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'use_dynamic_moi_rescaling'), 'use_dynamic_moi_rescaling', '__AbsentNamespace0_CTD_ANON_91_use_dynamic_moi_rescaling', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 405, 20), )

    
    use_dynamic_moi_rescaling = property(__use_dynamic_moi_rescaling.value, __use_dynamic_moi_rescaling.set, None, '\n                          \n          Flag to enable dynamic rescaling of moment of inertia in constrained directions.\n          See gazebo pull request 1114 for the implementation of this feature.\n          https://bitbucket.org/osrf/gazebo/pull-request/1114\n        \n                        ')

    _ElementMap.update({
        __type.name() : __type,
        __min_step_size.name() : __min_step_size,
        __iters.name() : __iters,
        __precon_iters.name() : __precon_iters,
        __sor.name() : __sor,
        __use_dynamic_moi_rescaling.name() : __use_dynamic_moi_rescaling
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_91 = CTD_ANON_91


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_92 (pyxb.binding.basis.complexTypeDefinition):
    """
                    ODE constraint parameters.
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 428, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element cfm uses Python identifier cfm
    __cfm = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'cfm'), 'cfm', '__AbsentNamespace0_CTD_ANON_92_cfm', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 431, 20), )

    
    cfm = property(__cfm.value, __cfm.set, None, '\n                          Constraint force mixing parameter. See the ODE page for more information.\n                        ')

    
    # Element erp uses Python identifier erp
    __erp = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'erp'), 'erp', '__AbsentNamespace0_CTD_ANON_92_erp', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 440, 20), )

    
    erp = property(__erp.value, __erp.set, None, '\n                          Error reduction parameter. See the ODE page for more information.\n                        ')

    
    # Element contact_max_correcting_vel uses Python identifier contact_max_correcting_vel
    __contact_max_correcting_vel = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'contact_max_correcting_vel'), 'contact_max_correcting_vel', '__AbsentNamespace0_CTD_ANON_92_contact_max_correcting_vel', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 449, 20), )

    
    contact_max_correcting_vel = property(__contact_max_correcting_vel.value, __contact_max_correcting_vel.set, None, '\n                          The maximum correcting velocities allowed when resolving contacts.\n                        ')

    
    # Element contact_surface_layer uses Python identifier contact_surface_layer
    __contact_surface_layer = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'contact_surface_layer'), 'contact_surface_layer', '__AbsentNamespace0_CTD_ANON_92_contact_surface_layer', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 458, 20), )

    
    contact_surface_layer = property(__contact_surface_layer.value, __contact_surface_layer.set, None, '\n                          The depth of the surface layer around all geometry objects. Contacts are allowed to sink into the surface layer up to the given depth before coming to rest. The default value is zero. Increasing this to some small value (e.g. 0.001) can help prevent jittering problems due to contacts being repeatedly made and broken.\n                        ')

    _ElementMap.update({
        __cfm.name() : __cfm,
        __erp.name() : __erp,
        __contact_max_correcting_vel.name() : __contact_max_correcting_vel,
        __contact_surface_layer.name() : __contact_surface_layer
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_92 = CTD_ANON_92


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_93 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/plane_shape.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element normal uses Python identifier normal
    __normal = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'normal'), 'normal', '__AbsentNamespace0_CTD_ANON_93_normal', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/plane_shape.xsd', 13, 8), )

    
    normal = property(__normal.value, __normal.set, None, '\n              Normal direction for the plane\n            ')

    
    # Element size uses Python identifier size
    __size = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'size'), 'size', '__AbsentNamespace0_CTD_ANON_93_size', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/plane_shape.xsd', 22, 8), )

    
    size = property(__size.value, __size.set, None, '\n              Length of each side of the plane\n            ')

    _ElementMap.update({
        __normal.name() : __normal,
        __size.name() : __size
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_93 = CTD_ANON_93


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_94 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/plugin.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_94_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/plugin.xsd', 14, 6)
    __name._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/plugin.xsd', 14, 6)
    
    name = property(__name.value, __name.set, None, '\n            A unique name for the plugin, scoped to its parent.\n          ')

    
    # Attribute filename uses Python identifier filename
    __filename = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'filename'), 'filename', '__AbsentNamespace0_CTD_ANON_94_filename', pyxb.binding.datatypes.string, required=True)
    __filename._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/plugin.xsd', 21, 6)
    __filename._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/plugin.xsd', 21, 6)
    
    filename = property(__filename.value, __filename.set, None, '\n            Name of the shared library to load. If the filename is not a full path name, the file will be searched for in the configuration paths.\n          ')

    _HasWildcardElement = True
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        __name.name() : __name,
        __filename.name() : __filename
    })
_module_typeBindings.CTD_ANON_94 = CTD_ANON_94


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_95 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/polyline_shape.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element point uses Python identifier point
    __point = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'point'), 'point', '__AbsentNamespace0_CTD_ANON_95_point', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/polyline_shape.xsd', 13, 8), )

    
    point = property(__point.value, __point.set, None, '\n              \n      A series of points that define the path of the polyline.\n    \n            ')

    
    # Element height uses Python identifier height
    __height = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'height'), 'height', '__AbsentNamespace0_CTD_ANON_95_height', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/polyline_shape.xsd', 24, 8), )

    
    height = property(__height.value, __height.set, None, '\n              Height of the polyline\n            ')

    _ElementMap.update({
        __point.name() : __point,
        __height.name() : __height
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_95 = CTD_ANON_95


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_96 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 16, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element box uses Python identifier box
    __box = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'box'), 'box', '__AbsentNamespace0_CTD_ANON_96_box', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/box_shape.xsd', 9, 2), )

    
    box = property(__box.value, __box.set, None, None)

    
    # Element cylinder uses Python identifier cylinder
    __cylinder = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'cylinder'), 'cylinder', '__AbsentNamespace0_CTD_ANON_96_cylinder', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/cylinder_shape.xsd', 9, 2), )

    
    cylinder = property(__cylinder.value, __cylinder.set, None, None)

    
    # Element model uses Python identifier model
    __model = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'model'), 'model', '__AbsentNamespace0_CTD_ANON_96_model', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 13, 2), )

    
    model = property(__model.value, __model.set, None, None)

    
    # Element pose uses Python identifier pose
    __pose = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'pose'), 'pose', '__AbsentNamespace0_CTD_ANON_96_pose', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 19, 8), )

    
    pose = property(__pose.value, __pose.set, None, "\n              The reference frame of the population's region.\n            ")

    
    # Element model_count uses Python identifier model_count
    __model_count = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'model_count'), 'model_count', '__AbsentNamespace0_CTD_ANON_96_model_count', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 28, 8), )

    
    model_count = property(__model_count.value, __model_count.set, None, '\n              The number of models to place.\n            ')

    
    # Element distribution uses Python identifier distribution
    __distribution = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'distribution'), 'distribution', '__AbsentNamespace0_CTD_ANON_96_distribution', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 37, 8), )

    
    distribution = property(__distribution.value, __distribution.set, None, '\n              \n      Specifies the type of object distribution and its optional parameters.\n    \n            ')

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_96_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 102, 6)
    __name._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 102, 6)
    
    name = property(__name.value, __name.set, None, '\n            \n      A unique name for the population. This name must not match\n      another population in the world.\n    \n          ')

    _ElementMap.update({
        __box.name() : __box,
        __cylinder.name() : __cylinder,
        __model.name() : __model,
        __pose.name() : __pose,
        __model_count.name() : __model_count,
        __distribution.name() : __distribution
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_module_typeBindings.CTD_ANON_96 = CTD_ANON_96


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_97 (pyxb.binding.basis.complexTypeDefinition):
    """
              
      Specifies the type of object distribution and its optional parameters.
    
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 45, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element type uses Python identifier type
    __type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'type'), 'type', '__AbsentNamespace0_CTD_ANON_97_type', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 48, 14), )

    
    type = property(__type.value, __type.set, None, '\n                    \n        Define how the objects will be placed in the specified region.\n        - random: Models placed at random.\n        - uniform: Models approximately placed in a 2D grid pattern with control\n            over the number of objects.\n        - grid: Models evenly placed in a 2D grid pattern. The number of objects\n            is not explicitly specified, it is based on the number of rows and\n            columns of the grid.\n        - linear-x: Models evently placed in a row along the global x-axis.\n        - linear-y: Models evently placed in a row along the global y-axis.\n        - linear-z: Models evently placed in a row along the global z-axis.\n      \n                  ')

    
    # Element rows uses Python identifier rows
    __rows = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'rows'), 'rows', '__AbsentNamespace0_CTD_ANON_97_rows', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 68, 14), )

    
    rows = property(__rows.value, __rows.set, None, '\n                    Number of rows in the grid.\n                  ')

    
    # Element cols uses Python identifier cols
    __cols = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'cols'), 'cols', '__AbsentNamespace0_CTD_ANON_97_cols', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 77, 14), )

    
    cols = property(__cols.value, __cols.set, None, '\n                    Number of columns in the grid.\n                  ')

    
    # Element step uses Python identifier step
    __step = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'step'), 'step', '__AbsentNamespace0_CTD_ANON_97_step', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 86, 14), )

    
    step = property(__step.value, __step.set, None, '\n                    Distance between elements of the grid.\n                  ')

    _ElementMap.update({
        __type.name() : __type,
        __rows.name() : __rows,
        __cols.name() : __cols,
        __step.name() : __step
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_97 = CTD_ANON_97


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_98 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 6, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element plugin uses Python identifier plugin
    __plugin = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'plugin'), 'plugin', '__AbsentNamespace0_CTD_ANON_98_plugin', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/plugin.xsd', 9, 2), )

    
    plugin = property(__plugin.value, __plugin.set, None, None)

    
    # Element texture uses Python identifier texture
    __texture = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'texture'), 'texture', '__AbsentNamespace0_CTD_ANON_98_texture', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 9, 8), )

    
    texture = property(__texture.value, __texture.set, None, '\n              Texture name\n            ')

    
    # Element pose uses Python identifier pose
    __pose = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'pose'), 'pose', '__AbsentNamespace0_CTD_ANON_98_pose', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 18, 8), )

    
    pose = property(__pose.value, __pose.set, None, '\n              Pose of the projector\n            ')

    
    # Element fov uses Python identifier fov
    __fov = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'fov'), 'fov', '__AbsentNamespace0_CTD_ANON_98_fov', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 27, 8), )

    
    fov = property(__fov.value, __fov.set, None, '\n              Field of view\n            ')

    
    # Element near_clip uses Python identifier near_clip
    __near_clip = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'near_clip'), 'near_clip', '__AbsentNamespace0_CTD_ANON_98_near_clip', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 36, 8), )

    
    near_clip = property(__near_clip.value, __near_clip.set, None, '\n              Near clip distance\n            ')

    
    # Element far_clip uses Python identifier far_clip
    __far_clip = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'far_clip'), 'far_clip', '__AbsentNamespace0_CTD_ANON_98_far_clip', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 45, 8), )

    
    far_clip = property(__far_clip.value, __far_clip.set, None, '\n              far clip distance\n            ')

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_98_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 55, 6)
    __name._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 55, 6)
    
    name = property(__name.value, __name.set, None, '\n            Name of the projector\n          ')

    _ElementMap.update({
        __plugin.name() : __plugin,
        __texture.name() : __texture,
        __pose.name() : __pose,
        __fov.name() : __fov,
        __near_clip.name() : __near_clip,
        __far_clip.name() : __far_clip
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_module_typeBindings.CTD_ANON_98 = CTD_ANON_98


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_99 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element scan uses Python identifier scan
    __scan = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'scan'), 'scan', '__AbsentNamespace0_CTD_ANON_99_scan', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 13, 8), )

    
    scan = property(__scan.value, __scan.set, None, None)

    
    # Element range uses Python identifier range
    __range = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'range'), 'range', '__AbsentNamespace0_CTD_ANON_99_range', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 99, 8), )

    
    range = property(__range.value, __range.set, None, '\n              specifies range properties of each simulated ray\n            ')

    
    # Element noise uses Python identifier noise
    __noise = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'noise'), 'noise', '__AbsentNamespace0_CTD_ANON_99_noise', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 139, 8), )

    
    noise = property(__noise.value, __noise.set, None, '\n              The properties of the noise model that should be applied to generated scans\n            ')

    _ElementMap.update({
        __scan.name() : __scan,
        __range.name() : __range,
        __noise.name() : __noise
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_99 = CTD_ANON_99


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_100 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 14, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element horizontal uses Python identifier horizontal
    __horizontal = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'horizontal'), 'horizontal', '__AbsentNamespace0_CTD_ANON_100_horizontal', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 17, 14), )

    
    horizontal = property(__horizontal.value, __horizontal.set, None, None)

    
    # Element vertical uses Python identifier vertical
    __vertical = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'vertical'), 'vertical', '__AbsentNamespace0_CTD_ANON_100_vertical', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 56, 14), )

    
    vertical = property(__vertical.value, __vertical.set, None, None)

    _ElementMap.update({
        __horizontal.name() : __horizontal,
        __vertical.name() : __vertical
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_100 = CTD_ANON_100


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_101 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 18, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element samples uses Python identifier samples
    __samples = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'samples'), 'samples', '__AbsentNamespace0_CTD_ANON_101_samples', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 21, 20), )

    
    samples = property(__samples.value, __samples.set, None, '\n                          The number of simulated rays to generate per complete laser sweep cycle.\n                        ')

    
    # Element resolution uses Python identifier resolution
    __resolution = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'resolution'), 'resolution', '__AbsentNamespace0_CTD_ANON_101_resolution', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 30, 20), )

    
    resolution = property(__resolution.value, __resolution.set, None, '\n                          This number is multiplied by samples to determine the number of range data points returned. If resolution is less than one, range data is interpolated. If resolution is greater than one, range data is averaged.\n                        ')

    
    # Element min_angle uses Python identifier min_angle
    __min_angle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'min_angle'), 'min_angle', '__AbsentNamespace0_CTD_ANON_101_min_angle', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 39, 20), )

    
    min_angle = property(__min_angle.value, __min_angle.set, None, None)

    
    # Element max_angle uses Python identifier max_angle
    __max_angle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'max_angle'), 'max_angle', '__AbsentNamespace0_CTD_ANON_101_max_angle', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 43, 20), )

    
    max_angle = property(__max_angle.value, __max_angle.set, None, '\n                          Must be greater or equal to min_angle\n                        ')

    _ElementMap.update({
        __samples.name() : __samples,
        __resolution.name() : __resolution,
        __min_angle.name() : __min_angle,
        __max_angle.name() : __max_angle
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_101 = CTD_ANON_101


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_102 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 57, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element samples uses Python identifier samples
    __samples = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'samples'), 'samples', '__AbsentNamespace0_CTD_ANON_102_samples', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 60, 20), )

    
    samples = property(__samples.value, __samples.set, None, '\n                          The number of simulated rays to generate per complete laser sweep cycle.\n                        ')

    
    # Element resolution uses Python identifier resolution
    __resolution = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'resolution'), 'resolution', '__AbsentNamespace0_CTD_ANON_102_resolution', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 69, 20), )

    
    resolution = property(__resolution.value, __resolution.set, None, '\n                          This number is multiplied by samples to determine the number of range data points returned. If resolution is less than one, range data is interpolated. If resolution is greater than one, range data is averaged.\n                        ')

    
    # Element min_angle uses Python identifier min_angle
    __min_angle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'min_angle'), 'min_angle', '__AbsentNamespace0_CTD_ANON_102_min_angle', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 78, 20), )

    
    min_angle = property(__min_angle.value, __min_angle.set, None, None)

    
    # Element max_angle uses Python identifier max_angle
    __max_angle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'max_angle'), 'max_angle', '__AbsentNamespace0_CTD_ANON_102_max_angle', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 82, 20), )

    
    max_angle = property(__max_angle.value, __max_angle.set, None, '\n                          Must be greater or equal to min_angle\n                        ')

    _ElementMap.update({
        __samples.name() : __samples,
        __resolution.name() : __resolution,
        __min_angle.name() : __min_angle,
        __max_angle.name() : __max_angle
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_102 = CTD_ANON_102


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_103 (pyxb.binding.basis.complexTypeDefinition):
    """
              specifies range properties of each simulated ray
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 105, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element min uses Python identifier min
    __min = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'min'), 'min', '__AbsentNamespace0_CTD_ANON_103_min', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 108, 14), )

    
    min = property(__min.value, __min.set, None, '\n                    The minimum distance for each ray.\n                  ')

    
    # Element max uses Python identifier max
    __max = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'max'), 'max', '__AbsentNamespace0_CTD_ANON_103_max', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 117, 14), )

    
    max = property(__max.value, __max.set, None, '\n                    The maximum distance for each ray.\n                  ')

    
    # Element resolution uses Python identifier resolution
    __resolution = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'resolution'), 'resolution', '__AbsentNamespace0_CTD_ANON_103_resolution', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 126, 14), )

    
    resolution = property(__resolution.value, __resolution.set, None, '\n                    Linear resolution of each ray.\n                  ')

    _ElementMap.update({
        __min.name() : __min,
        __max.name() : __max,
        __resolution.name() : __resolution
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_103 = CTD_ANON_103


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_104 (pyxb.binding.basis.complexTypeDefinition):
    """
              The properties of the noise model that should be applied to generated scans
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 145, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element type uses Python identifier type
    __type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'type'), 'type', '__AbsentNamespace0_CTD_ANON_104_type', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 148, 14), )

    
    type = property(__type.value, __type.set, None, '\n                    The type of noise.  Currently supported types are: "gaussian" (draw noise values independently for each beam from a Gaussian distribution).\n                  ')

    
    # Element mean uses Python identifier mean
    __mean = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'mean'), 'mean', '__AbsentNamespace0_CTD_ANON_104_mean', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 157, 14), )

    
    mean = property(__mean.value, __mean.set, None, '\n                    For type "gaussian," the mean of the Gaussian distribution from which noise values are drawn.\n                  ')

    
    # Element stddev uses Python identifier stddev
    __stddev = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'stddev'), 'stddev', '__AbsentNamespace0_CTD_ANON_104_stddev', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 166, 14), )

    
    stddev = property(__stddev.value, __stddev.set, None, '\n                    For type "gaussian," the standard deviation of the Gaussian distribution from which noise values are drawn.\n                  ')

    _ElementMap.update({
        __type.name() : __type,
        __mean.name() : __mean,
        __stddev.name() : __stddev
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_104 = CTD_ANON_104


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_105 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/road.xsd', 6, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element material uses Python identifier material
    __material = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'material'), 'material', '__AbsentNamespace0_CTD_ANON_105_material', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 9, 2), )

    
    material = property(__material.value, __material.set, None, None)

    
    # Element width uses Python identifier width
    __width = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'width'), 'width', '__AbsentNamespace0_CTD_ANON_105_width', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/road.xsd', 9, 8), )

    
    width = property(__width.value, __width.set, None, '\n              Width of the road\n            ')

    
    # Element point uses Python identifier point
    __point = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'point'), 'point', '__AbsentNamespace0_CTD_ANON_105_point', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/road.xsd', 18, 8), )

    
    point = property(__point.value, __point.set, None, '\n              A series of points that define the path of the road.\n            ')

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_105_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/road.xsd', 28, 6)
    __name._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/road.xsd', 28, 6)
    
    name = property(__name.value, __name.set, None, '\n            Name of the road\n          ')

    _ElementMap.update({
        __material.name() : __material,
        __width.name() : __width,
        __point.name() : __point
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_module_typeBindings.CTD_ANON_105 = CTD_ANON_105


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_106 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/root.xsd', 14, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element actor uses Python identifier actor
    __actor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'actor'), 'actor', '__AbsentNamespace0_CTD_ANON_106_actor', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 7, 2), )

    
    actor = property(__actor.value, __actor.set, None, None)

    
    # Element light uses Python identifier light
    __light = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'light'), 'light', '__AbsentNamespace0_CTD_ANON_106_light', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 9, 2), )

    
    light = property(__light.value, __light.set, None, None)

    
    # Element model uses Python identifier model
    __model = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'model'), 'model', '__AbsentNamespace0_CTD_ANON_106_model', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 13, 2), )

    
    model = property(__model.value, __model.set, None, None)

    
    # Element world uses Python identifier world
    __world = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'world'), 'world', '__AbsentNamespace0_CTD_ANON_106_world', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 21, 2), )

    
    world = property(__world.value, __world.set, None, None)

    
    # Attribute version uses Python identifier version
    __version = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'version'), 'version', '__AbsentNamespace0_CTD_ANON_106_version', pyxb.binding.datatypes.string, required=True)
    __version._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/root.xsd', 21, 6)
    __version._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/root.xsd', 21, 6)
    
    version = property(__version.value, __version.set, None, '\n            Version number of the SDF format.\n          ')

    _ElementMap.update({
        __actor.name() : __actor,
        __light.name() : __light,
        __model.name() : __model,
        __world.name() : __world
    })
    _AttributeMap.update({
        __version.name() : __version
    })
_module_typeBindings.CTD_ANON_106 = CTD_ANON_106


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_107 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ambient uses Python identifier ambient
    __ambient = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ambient'), 'ambient', '__AbsentNamespace0_CTD_ANON_107_ambient', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 13, 8), )

    
    ambient = property(__ambient.value, __ambient.set, None, '\n              Color of the ambient light.\n            ')

    
    # Element background uses Python identifier background
    __background = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'background'), 'background', '__AbsentNamespace0_CTD_ANON_107_background', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 22, 8), )

    
    background = property(__background.value, __background.set, None, '\n              Color of the background.\n            ')

    
    # Element sky uses Python identifier sky
    __sky = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'sky'), 'sky', '__AbsentNamespace0_CTD_ANON_107_sky', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 31, 8), )

    
    sky = property(__sky.value, __sky.set, None, '\n              Properties for the sky\n            ')

    
    # Element shadows uses Python identifier shadows
    __shadows = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'shadows'), 'shadows', '__AbsentNamespace0_CTD_ANON_107_shadows', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 129, 8), )

    
    shadows = property(__shadows.value, __shadows.set, None, '\n              Enable/disable shadows\n            ')

    
    # Element fog uses Python identifier fog
    __fog = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'fog'), 'fog', '__AbsentNamespace0_CTD_ANON_107_fog', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 138, 8), )

    
    fog = property(__fog.value, __fog.set, None, '\n              Controls fog\n            ')

    
    # Element grid uses Python identifier grid
    __grid = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'grid'), 'grid', '__AbsentNamespace0_CTD_ANON_107_grid', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 196, 8), )

    
    grid = property(__grid.value, __grid.set, None, '\n              Enable/disable the grid\n            ')

    
    # Element origin_visual uses Python identifier origin_visual
    __origin_visual = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'origin_visual'), 'origin_visual', '__AbsentNamespace0_CTD_ANON_107_origin_visual', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 205, 8), )

    
    origin_visual = property(__origin_visual.value, __origin_visual.set, None, '\n              Show/hide world origin indicator\n            ')

    _ElementMap.update({
        __ambient.name() : __ambient,
        __background.name() : __background,
        __sky.name() : __sky,
        __shadows.name() : __shadows,
        __fog.name() : __fog,
        __grid.name() : __grid,
        __origin_visual.name() : __origin_visual
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_107 = CTD_ANON_107


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_108 (pyxb.binding.basis.complexTypeDefinition):
    """
              Properties for the sky
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 37, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element time uses Python identifier time
    __time = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'time'), 'time', '__AbsentNamespace0_CTD_ANON_108_time', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 40, 14), )

    
    time = property(__time.value, __time.set, None, '\n                    Time of day [0..24]\n                  ')

    
    # Element sunrise uses Python identifier sunrise
    __sunrise = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'sunrise'), 'sunrise', '__AbsentNamespace0_CTD_ANON_108_sunrise', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 49, 14), )

    
    sunrise = property(__sunrise.value, __sunrise.set, None, '\n                    Sunrise time [0..24]\n                  ')

    
    # Element sunset uses Python identifier sunset
    __sunset = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'sunset'), 'sunset', '__AbsentNamespace0_CTD_ANON_108_sunset', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 58, 14), )

    
    sunset = property(__sunset.value, __sunset.set, None, '\n                    Sunset time [0..24]\n                  ')

    
    # Element clouds uses Python identifier clouds
    __clouds = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'clouds'), 'clouds', '__AbsentNamespace0_CTD_ANON_108_clouds', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 67, 14), )

    
    clouds = property(__clouds.value, __clouds.set, None, '\n                    Sunset time [0..24]\n                  ')

    _ElementMap.update({
        __time.name() : __time,
        __sunrise.name() : __sunrise,
        __sunset.name() : __sunset,
        __clouds.name() : __clouds
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_108 = CTD_ANON_108


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_109 (pyxb.binding.basis.complexTypeDefinition):
    """
                    Sunset time [0..24]
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 73, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element speed uses Python identifier speed
    __speed = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'speed'), 'speed', '__AbsentNamespace0_CTD_ANON_109_speed', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 76, 20), )

    
    speed = property(__speed.value, __speed.set, None, '\n                          Speed of the clouds\n                        ')

    
    # Element direction uses Python identifier direction
    __direction = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'direction'), 'direction', '__AbsentNamespace0_CTD_ANON_109_direction', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 85, 20), )

    
    direction = property(__direction.value, __direction.set, None, '\n                          Direction of the cloud movement\n                        ')

    
    # Element humidity uses Python identifier humidity
    __humidity = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'humidity'), 'humidity', '__AbsentNamespace0_CTD_ANON_109_humidity', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 94, 20), )

    
    humidity = property(__humidity.value, __humidity.set, None, '\n                          Density of clouds\n                        ')

    
    # Element mean_size uses Python identifier mean_size
    __mean_size = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'mean_size'), 'mean_size', '__AbsentNamespace0_CTD_ANON_109_mean_size', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 103, 20), )

    
    mean_size = property(__mean_size.value, __mean_size.set, None, '\n                          Average size of the clouds\n                        ')

    
    # Element ambient uses Python identifier ambient
    __ambient = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ambient'), 'ambient', '__AbsentNamespace0_CTD_ANON_109_ambient', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 112, 20), )

    
    ambient = property(__ambient.value, __ambient.set, None, '\n                          Ambient cloud color\n                        ')

    _ElementMap.update({
        __speed.name() : __speed,
        __direction.name() : __direction,
        __humidity.name() : __humidity,
        __mean_size.name() : __mean_size,
        __ambient.name() : __ambient
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_109 = CTD_ANON_109


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_110 (pyxb.binding.basis.complexTypeDefinition):
    """
              Controls fog
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 144, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element color uses Python identifier color
    __color = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'color'), 'color', '__AbsentNamespace0_CTD_ANON_110_color', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 147, 14), )

    
    color = property(__color.value, __color.set, None, '\n                    Fog color\n                  ')

    
    # Element type uses Python identifier type
    __type = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'type'), 'type', '__AbsentNamespace0_CTD_ANON_110_type', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 156, 14), )

    
    type = property(__type.value, __type.set, None, '\n                    Fog type: constant, linear, quadratic\n                  ')

    
    # Element start uses Python identifier start
    __start = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'start'), 'start', '__AbsentNamespace0_CTD_ANON_110_start', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 165, 14), )

    
    start = property(__start.value, __start.set, None, '\n                    Distance to start of fog\n                  ')

    
    # Element end uses Python identifier end
    __end = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'end'), 'end', '__AbsentNamespace0_CTD_ANON_110_end', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 174, 14), )

    
    end = property(__end.value, __end.set, None, '\n                    Distance to end of fog\n                  ')

    
    # Element density uses Python identifier density
    __density = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'density'), 'density', '__AbsentNamespace0_CTD_ANON_110_density', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 183, 14), )

    
    density = property(__density.value, __density.set, None, '\n                    Density of fog\n                  ')

    _ElementMap.update({
        __color.name() : __color,
        __type.name() : __type,
        __start.name() : __start,
        __end.name() : __end,
        __density.name() : __density
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_110 = CTD_ANON_110


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_111 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 24, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element altimeter uses Python identifier altimeter
    __altimeter = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'altimeter'), 'altimeter', '__AbsentNamespace0_CTD_ANON_111_altimeter', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/altimeter.xsd', 9, 2), )

    
    altimeter = property(__altimeter.value, __altimeter.set, None, None)

    
    # Element camera uses Python identifier camera
    __camera = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'camera'), 'camera', '__AbsentNamespace0_CTD_ANON_111_camera', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 9, 2), )

    
    camera = property(__camera.value, __camera.set, None, None)

    
    # Element contact uses Python identifier contact
    __contact = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'contact'), 'contact', '__AbsentNamespace0_CTD_ANON_111_contact', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/contact.xsd', 9, 2), )

    
    contact = property(__contact.value, __contact.set, None, None)

    
    # Element force_torque uses Python identifier force_torque
    __force_torque = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'force_torque'), 'force_torque', '__AbsentNamespace0_CTD_ANON_111_force_torque', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/forcetorque.xsd', 9, 2), )

    
    force_torque = property(__force_torque.value, __force_torque.set, None, None)

    
    # Element gps uses Python identifier gps
    __gps = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'gps'), 'gps', '__AbsentNamespace0_CTD_ANON_111_gps', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 9, 2), )

    
    gps = property(__gps.value, __gps.set, None, None)

    
    # Element imu uses Python identifier imu
    __imu = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'imu'), 'imu', '__AbsentNamespace0_CTD_ANON_111_imu', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 9, 2), )

    
    imu = property(__imu.value, __imu.set, None, None)

    
    # Element logical_camera uses Python identifier logical_camera
    __logical_camera = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'logical_camera'), 'logical_camera', '__AbsentNamespace0_CTD_ANON_111_logical_camera', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/logical_camera.xsd', 9, 2), )

    
    logical_camera = property(__logical_camera.value, __logical_camera.set, None, None)

    
    # Element magnetometer uses Python identifier magnetometer
    __magnetometer = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'magnetometer'), 'magnetometer', '__AbsentNamespace0_CTD_ANON_111_magnetometer', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/magnetometer.xsd', 9, 2), )

    
    magnetometer = property(__magnetometer.value, __magnetometer.set, None, None)

    
    # Element plugin uses Python identifier plugin
    __plugin = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'plugin'), 'plugin', '__AbsentNamespace0_CTD_ANON_111_plugin', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/plugin.xsd', 9, 2), )

    
    plugin = property(__plugin.value, __plugin.set, None, None)

    
    # Element ray uses Python identifier ray
    __ray = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'ray'), 'ray', '__AbsentNamespace0_CTD_ANON_111_ray', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 9, 2), )

    
    ray = property(__ray.value, __ray.set, None, None)

    
    # Element rfidtag uses Python identifier rfidtag
    __rfidtag = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'rfidtag'), 'rfidtag', '__AbsentNamespace0_CTD_ANON_111_rfidtag', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/rfid.xsd', 4, 2), )

    
    rfidtag = property(__rfidtag.value, __rfidtag.set, None, None)

    
    # Element rfid uses Python identifier rfid
    __rfid = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'rfid'), 'rfid', '__AbsentNamespace0_CTD_ANON_111_rfid', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/rfidtag.xsd', 4, 2), )

    
    rfid = property(__rfid.value, __rfid.set, None, None)

    
    # Element always_on uses Python identifier always_on
    __always_on = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'always_on'), 'always_on', '__AbsentNamespace0_CTD_ANON_111_always_on', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 27, 8), )

    
    always_on = property(__always_on.value, __always_on.set, None, '\n              If true the sensor will always be updated according to the update rate.\n            ')

    
    # Element update_rate uses Python identifier update_rate
    __update_rate = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'update_rate'), 'update_rate', '__AbsentNamespace0_CTD_ANON_111_update_rate', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 36, 8), )

    
    update_rate = property(__update_rate.value, __update_rate.set, None, '\n              The frequency at which the sensor data is generated. If left unspecified, the sensor will generate data every cycle.\n            ')

    
    # Element visualize uses Python identifier visualize
    __visualize = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'visualize'), 'visualize', '__AbsentNamespace0_CTD_ANON_111_visualize', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 45, 8), )

    
    visualize = property(__visualize.value, __visualize.set, None, '\n              If true, the sensor is visualized in the GUI\n            ')

    
    # Element pose uses Python identifier pose
    __pose = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'pose'), 'pose', '__AbsentNamespace0_CTD_ANON_111_pose', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 54, 8), )

    
    pose = property(__pose.value, __pose.set, None, '\n              This is the pose of the sensor, relative to the parent (link or joint) reference frame.\n            ')

    
    # Element topic uses Python identifier topic
    __topic = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'topic'), 'topic', '__AbsentNamespace0_CTD_ANON_111_topic', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 63, 8), )

    
    topic = property(__topic.value, __topic.set, None, '\n              Name of the topic on which data is published. This is necessary for visualization\n            ')

    
    # Element sonar uses Python identifier sonar
    __sonar = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'sonar'), 'sonar', '__AbsentNamespace0_CTD_ANON_111_sonar', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/sonar.xsd', 9, 2), )

    
    sonar = property(__sonar.value, __sonar.set, None, None)

    
    # Element transceiver uses Python identifier transceiver
    __transceiver = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'transceiver'), 'transceiver', '__AbsentNamespace0_CTD_ANON_111_transceiver', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 9, 2), )

    
    transceiver = property(__transceiver.value, __transceiver.set, None, None)

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_111_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 86, 6)
    __name._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 86, 6)
    
    name = property(__name.value, __name.set, None, '\n            A unique name for the sensor. This name must not match another model in the model.\n          ')

    
    # Attribute type uses Python identifier type
    __type = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'type'), 'type', '__AbsentNamespace0_CTD_ANON_111_type', pyxb.binding.datatypes.string, required=True)
    __type._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 93, 6)
    __type._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 93, 6)
    
    type = property(__type.value, __type.set, None, '\n            The type name of the sensor. By default, SDF supports types\n                  altimeter,\n                  camera,\n                  contact,\n                  depth,\n                  force_torque,\n                  gps,\n                  gpu_ray,\n                  imu,\n                  logical_camera,\n                  magnetometer,\n                  multicamera,\n                  ray,\n                  rfid,\n                  rfidtag,\n                  sonar,\n                  wireless_receiver, and\n                  wireless_transmitter.\n          ')

    _ElementMap.update({
        __altimeter.name() : __altimeter,
        __camera.name() : __camera,
        __contact.name() : __contact,
        __force_torque.name() : __force_torque,
        __gps.name() : __gps,
        __imu.name() : __imu,
        __logical_camera.name() : __logical_camera,
        __magnetometer.name() : __magnetometer,
        __plugin.name() : __plugin,
        __ray.name() : __ray,
        __rfidtag.name() : __rfidtag,
        __rfid.name() : __rfid,
        __always_on.name() : __always_on,
        __update_rate.name() : __update_rate,
        __visualize.name() : __visualize,
        __pose.name() : __pose,
        __topic.name() : __topic,
        __sonar.name() : __sonar,
        __transceiver.name() : __transceiver
    })
    _AttributeMap.update({
        __name.name() : __name,
        __type.name() : __type
    })
_module_typeBindings.CTD_ANON_111 = CTD_ANON_111


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_112 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/sonar.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element min uses Python identifier min
    __min = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'min'), 'min', '__AbsentNamespace0_CTD_ANON_112_min', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/sonar.xsd', 13, 8), )

    
    min = property(__min.value, __min.set, None, '\n              Minimum range\n            ')

    
    # Element max uses Python identifier max
    __max = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'max'), 'max', '__AbsentNamespace0_CTD_ANON_112_max', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/sonar.xsd', 22, 8), )

    
    max = property(__max.value, __max.set, None, '\n              Max range\n            ')

    
    # Element radius uses Python identifier radius
    __radius = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'radius'), 'radius', '__AbsentNamespace0_CTD_ANON_112_radius', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/sonar.xsd', 31, 8), )

    
    radius = property(__radius.value, __radius.set, None, '\n              Radius of the sonar cone at max range.\n            ')

    _ElementMap.update({
        __min.name() : __min,
        __max.name() : __max,
        __radius.name() : __radius
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_112 = CTD_ANON_112


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_113 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/sphere_shape.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element radius uses Python identifier radius
    __radius = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'radius'), 'radius', '__AbsentNamespace0_CTD_ANON_113_radius', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/sphere_shape.xsd', 13, 8), )

    
    radius = property(__radius.value, __radius.set, None, '\n              radius of the sphere\n            ')

    _ElementMap.update({
        __radius.name() : __radius
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_113 = CTD_ANON_113


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_114 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/spherical_coordinates.xsd', 5, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element surface_model uses Python identifier surface_model
    __surface_model = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'surface_model'), 'surface_model', '__AbsentNamespace0_CTD_ANON_114_surface_model', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/spherical_coordinates.xsd', 8, 8), )

    
    surface_model = property(__surface_model.value, __surface_model.set, None, "\n              \n      Name of planetary surface model, used to determine the surface altitude\n      at a given latitude and longitude. The default is an ellipsoid model of\n      the earth based on the WGS-84 standard. It is used in Gazebo's GPS sensor\n      implementation.\n    \n            ")

    
    # Element latitude_deg uses Python identifier latitude_deg
    __latitude_deg = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'latitude_deg'), 'latitude_deg', '__AbsentNamespace0_CTD_ANON_114_latitude_deg', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/spherical_coordinates.xsd', 22, 8), )

    
    latitude_deg = property(__latitude_deg.value, __latitude_deg.set, None, '\n              \n      Geodetic latitude at origin of gazebo reference frame, specified\n      in units of degrees.\n    \n            ')

    
    # Element longitude_deg uses Python identifier longitude_deg
    __longitude_deg = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'longitude_deg'), 'longitude_deg', '__AbsentNamespace0_CTD_ANON_114_longitude_deg', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/spherical_coordinates.xsd', 34, 8), )

    
    longitude_deg = property(__longitude_deg.value, __longitude_deg.set, None, '\n              \n      Longitude at origin of gazebo reference frame, specified in units\n      of degrees.\n    \n            ')

    
    # Element elevation uses Python identifier elevation
    __elevation = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'elevation'), 'elevation', '__AbsentNamespace0_CTD_ANON_114_elevation', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/spherical_coordinates.xsd', 46, 8), )

    
    elevation = property(__elevation.value, __elevation.set, None, '\n              \n      Elevation of origin of gazebo reference frame, specified in meters.\n    \n            ')

    
    # Element heading_deg uses Python identifier heading_deg
    __heading_deg = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'heading_deg'), 'heading_deg', '__AbsentNamespace0_CTD_ANON_114_heading_deg', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/spherical_coordinates.xsd', 57, 8), )

    
    heading_deg = property(__heading_deg.value, __heading_deg.set, None, '\n              \n      Heading offset of gazebo reference frame, measured as angle between\n      East and gazebo x axis, or equivalently, the angle between North and\n      gazebo y axis. The angle is specified in degrees.\n    \n            ')

    _ElementMap.update({
        __surface_model.name() : __surface_model,
        __latitude_deg.name() : __latitude_deg,
        __longitude_deg.name() : __longitude_deg,
        __elevation.name() : __elevation,
        __heading_deg.name() : __heading_deg
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_114 = CTD_ANON_114


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_115 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 5, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element sim_time uses Python identifier sim_time
    __sim_time = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'sim_time'), 'sim_time', '__AbsentNamespace0_CTD_ANON_115_sim_time', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 8, 8), )

    
    sim_time = property(__sim_time.value, __sim_time.set, None, '\n              Simulation time stamp of the state [seconds nanoseconds]\n            ')

    
    # Element wall_time uses Python identifier wall_time
    __wall_time = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'wall_time'), 'wall_time', '__AbsentNamespace0_CTD_ANON_115_wall_time', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 17, 8), )

    
    wall_time = property(__wall_time.value, __wall_time.set, None, '\n              Wall time stamp of the state [seconds nanoseconds]\n            ')

    
    # Element real_time uses Python identifier real_time
    __real_time = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'real_time'), 'real_time', '__AbsentNamespace0_CTD_ANON_115_real_time', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 26, 8), )

    
    real_time = property(__real_time.value, __real_time.set, None, '\n              Real time stamp of the state [seconds nanoseconds]\n            ')

    
    # Element iterations uses Python identifier iterations
    __iterations = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'iterations'), 'iterations', '__AbsentNamespace0_CTD_ANON_115_iterations', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 35, 8), )

    
    iterations = property(__iterations.value, __iterations.set, None, '\n              Number of simulation iterations.\n            ')

    
    # Element insertions uses Python identifier insertions
    __insertions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'insertions'), 'insertions', '__AbsentNamespace0_CTD_ANON_115_insertions', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 44, 8), )

    
    insertions = property(__insertions.value, __insertions.set, None, '\n              A list of new model names\n            ')

    
    # Element deletions uses Python identifier deletions
    __deletions = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'deletions'), 'deletions', '__AbsentNamespace0_CTD_ANON_115_deletions', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 57, 8), )

    
    deletions = property(__deletions.value, __deletions.set, None, '\n              A list of deleted model names\n            ')

    
    # Element model uses Python identifier model
    __model = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'model'), 'model', '__AbsentNamespace0_CTD_ANON_115_model', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 79, 8), )

    
    model = property(__model.value, __model.set, None, '\n              Model state\n            ')

    
    # Attribute world_name uses Python identifier world_name
    __world_name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'world_name'), 'world_name', '__AbsentNamespace0_CTD_ANON_115_world_name', pyxb.binding.datatypes.string, required=True)
    __world_name._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 222, 6)
    __world_name._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 222, 6)
    
    world_name = property(__world_name.value, __world_name.set, None, '\n            Name of the world this state applies to\n          ')

    _ElementMap.update({
        __sim_time.name() : __sim_time,
        __wall_time.name() : __wall_time,
        __real_time.name() : __real_time,
        __iterations.name() : __iterations,
        __insertions.name() : __insertions,
        __deletions.name() : __deletions,
        __model.name() : __model
    })
    _AttributeMap.update({
        __world_name.name() : __world_name
    })
_module_typeBindings.CTD_ANON_115 = CTD_ANON_115


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_116 (pyxb.binding.basis.complexTypeDefinition):
    """
              A list of new model names
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 50, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    _ElementMap.update({
        
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_116 = CTD_ANON_116


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_117 (pyxb.binding.basis.complexTypeDefinition):
    """
              A list of deleted model names
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 63, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_117_name', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 66, 14), )

    
    name = property(__name.value, __name.set, None, '\n                    The name of a deleted model\n                  ')

    _ElementMap.update({
        __name.name() : __name
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_117 = CTD_ANON_117


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_118 (pyxb.binding.basis.complexTypeDefinition):
    """
              Model state
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 85, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element pose uses Python identifier pose
    __pose = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'pose'), 'pose', '__AbsentNamespace0_CTD_ANON_118_pose', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 88, 14), )

    
    pose = property(__pose.value, __pose.set, None, '\n                    Pose of the model\n                  ')

    
    # Element joint uses Python identifier joint
    __joint = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'joint'), 'joint', '__AbsentNamespace0_CTD_ANON_118_joint', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 97, 14), )

    
    joint = property(__joint.value, __joint.set, None, '\n                    Joint angle\n                  ')

    
    # Element link uses Python identifier link
    __link = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'link'), 'link', '__AbsentNamespace0_CTD_ANON_118_link', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 126, 14), )

    
    link = property(__link.value, __link.set, None, '\n                    Link state\n                  ')

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_118_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 211, 12)
    __name._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 211, 12)
    
    name = property(__name.value, __name.set, None, '\n                  Name of the model\n                ')

    _ElementMap.update({
        __pose.name() : __pose,
        __joint.name() : __joint,
        __link.name() : __link
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_module_typeBindings.CTD_ANON_118 = CTD_ANON_118


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_119 (pyxb.binding.basis.complexTypeDefinition):
    """
                    Joint angle
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 103, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element angle uses Python identifier angle
    __angle = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'angle'), 'angle', '__AbsentNamespace0_CTD_ANON_119_angle', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 106, 20), )

    
    angle = property(__angle.value, __angle.set, None, '\n                          Angle of an axis\n                        ')

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_119_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 115, 18)
    __name._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 115, 18)
    
    name = property(__name.value, __name.set, None, '\n                        Name of the joint\n                      ')

    _ElementMap.update({
        __angle.name() : __angle
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_module_typeBindings.CTD_ANON_119 = CTD_ANON_119


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_120 (pyxb.binding.basis.complexTypeDefinition):
    """
                    Link state
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 132, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element pose uses Python identifier pose
    __pose = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'pose'), 'pose', '__AbsentNamespace0_CTD_ANON_120_pose', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 135, 20), )

    
    pose = property(__pose.value, __pose.set, None, '\n                          Pose of the link relative to the model\n                        ')

    
    # Element velocity uses Python identifier velocity
    __velocity = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'velocity'), 'velocity', '__AbsentNamespace0_CTD_ANON_120_velocity', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 144, 20), )

    
    velocity = property(__velocity.value, __velocity.set, None, '\n                          Velocity of the link\n                        ')

    
    # Element acceleration uses Python identifier acceleration
    __acceleration = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'acceleration'), 'acceleration', '__AbsentNamespace0_CTD_ANON_120_acceleration', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 153, 20), )

    
    acceleration = property(__acceleration.value, __acceleration.set, None, '\n                          Acceleration of the link\n                        ')

    
    # Element wrench uses Python identifier wrench
    __wrench = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'wrench'), 'wrench', '__AbsentNamespace0_CTD_ANON_120_wrench', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 162, 20), )

    
    wrench = property(__wrench.value, __wrench.set, None, '\n                          Force applied to the link\n                        ')

    
    # Element collision uses Python identifier collision
    __collision = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'collision'), 'collision', '__AbsentNamespace0_CTD_ANON_120_collision', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 171, 20), )

    
    collision = property(__collision.value, __collision.set, None, '\n                          Collision state\n                        ')

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_120_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 200, 18)
    __name._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 200, 18)
    
    name = property(__name.value, __name.set, None, '\n                        Name of the link\n                      ')

    _ElementMap.update({
        __pose.name() : __pose,
        __velocity.name() : __velocity,
        __acceleration.name() : __acceleration,
        __wrench.name() : __wrench,
        __collision.name() : __collision
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_module_typeBindings.CTD_ANON_120 = CTD_ANON_120


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_121 (pyxb.binding.basis.complexTypeDefinition):
    """
                          Collision state
                        """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 177, 22)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element pose uses Python identifier pose
    __pose = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'pose'), 'pose', '__AbsentNamespace0_CTD_ANON_121_pose', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 180, 26), )

    
    pose = property(__pose.value, __pose.set, None, '\n                                Pose of the link relative to the model\n                              ')

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_121_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 189, 24)
    __name._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 189, 24)
    
    name = property(__name.value, __name.set, None, '\n                              Name of the collision\n                            ')

    _ElementMap.update({
        __pose.name() : __pose
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_module_typeBindings.CTD_ANON_121 = CTD_ANON_121


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_122 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element bounce uses Python identifier bounce
    __bounce = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'bounce'), 'bounce', '__AbsentNamespace0_CTD_ANON_122_bounce', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 13, 8), )

    
    bounce = property(__bounce.value, __bounce.set, None, None)

    
    # Element friction uses Python identifier friction
    __friction = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'friction'), 'friction', '__AbsentNamespace0_CTD_ANON_122_friction', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 39, 8), )

    
    friction = property(__friction.value, __friction.set, None, None)

    
    # Element contact uses Python identifier contact
    __contact = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'contact'), 'contact', '__AbsentNamespace0_CTD_ANON_122_contact', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 149, 8), )

    
    contact = property(__contact.value, __contact.set, None, None)

    
    # Element soft_contact uses Python identifier soft_contact
    __soft_contact = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'soft_contact'), 'soft_contact', '__AbsentNamespace0_CTD_ANON_122_soft_contact', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 318, 8), )

    
    soft_contact = property(__soft_contact.value, __soft_contact.set, None, None)

    _ElementMap.update({
        __bounce.name() : __bounce,
        __friction.name() : __friction,
        __contact.name() : __contact,
        __soft_contact.name() : __soft_contact
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_122 = CTD_ANON_122


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_123 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 14, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element restitution_coefficient uses Python identifier restitution_coefficient
    __restitution_coefficient = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'restitution_coefficient'), 'restitution_coefficient', '__AbsentNamespace0_CTD_ANON_123_restitution_coefficient', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 17, 14), )

    
    restitution_coefficient = property(__restitution_coefficient.value, __restitution_coefficient.set, None, '\n                    Bounciness coefficient of restitution, from [0...1], where 0=no bounciness.\n                  ')

    
    # Element threshold uses Python identifier threshold
    __threshold = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'threshold'), 'threshold', '__AbsentNamespace0_CTD_ANON_123_threshold', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 26, 14), )

    
    threshold = property(__threshold.value, __threshold.set, None, '\n                    Bounce capture velocity, below which effective coefficient of restitution is 0.\n                  ')

    _ElementMap.update({
        __restitution_coefficient.name() : __restitution_coefficient,
        __threshold.name() : __threshold
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_123 = CTD_ANON_123


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_124 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 40, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element ode uses Python identifier ode
    __ode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ode'), 'ode', '__AbsentNamespace0_CTD_ANON_124_ode', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 43, 14), )

    
    ode = property(__ode.value, __ode.set, None, '\n                    ODE friction parameters\n                  ')

    
    # Element bullet uses Python identifier bullet
    __bullet = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'bullet'), 'bullet', '__AbsentNamespace0_CTD_ANON_124_bullet', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 101, 14), )

    
    bullet = property(__bullet.value, __bullet.set, None, None)

    _ElementMap.update({
        __ode.name() : __ode,
        __bullet.name() : __bullet
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_124 = CTD_ANON_124


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_125 (pyxb.binding.basis.complexTypeDefinition):
    """
                    ODE friction parameters
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 49, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element mu uses Python identifier mu
    __mu = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'mu'), 'mu', '__AbsentNamespace0_CTD_ANON_125_mu', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 52, 20), )

    
    mu = property(__mu.value, __mu.set, None, '\n                          Coefficient of friction in the range of [0..1].\n                        ')

    
    # Element mu2 uses Python identifier mu2
    __mu2 = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'mu2'), 'mu2', '__AbsentNamespace0_CTD_ANON_125_mu2', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 61, 20), )

    
    mu2 = property(__mu2.value, __mu2.set, None, '\n                          Second coefficient of friction in the range of [0..1]\n                        ')

    
    # Element fdir1 uses Python identifier fdir1
    __fdir1 = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'fdir1'), 'fdir1', '__AbsentNamespace0_CTD_ANON_125_fdir1', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 70, 20), )

    
    fdir1 = property(__fdir1.value, __fdir1.set, None, '\n                          3-tuple specifying direction of mu1 in the collision local reference frame.\n                        ')

    
    # Element slip1 uses Python identifier slip1
    __slip1 = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'slip1'), 'slip1', '__AbsentNamespace0_CTD_ANON_125_slip1', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 79, 20), )

    
    slip1 = property(__slip1.value, __slip1.set, None, '\n                          Force dependent slip direction 1 in collision local frame, between the range of [0..1].\n                        ')

    
    # Element slip2 uses Python identifier slip2
    __slip2 = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'slip2'), 'slip2', '__AbsentNamespace0_CTD_ANON_125_slip2', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 88, 20), )

    
    slip2 = property(__slip2.value, __slip2.set, None, '\n                          Force dependent slip direction 2 in collision local frame, between the range of [0..1].\n                        ')

    _ElementMap.update({
        __mu.name() : __mu,
        __mu2.name() : __mu2,
        __fdir1.name() : __fdir1,
        __slip1.name() : __slip1,
        __slip2.name() : __slip2
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_125 = CTD_ANON_125


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_126 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 102, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element friction uses Python identifier friction
    __friction = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'friction'), 'friction', '__AbsentNamespace0_CTD_ANON_126_friction', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 105, 20), )

    
    friction = property(__friction.value, __friction.set, None, '\n                          Coefficient of friction in the range of [0..1].\n                        ')

    
    # Element friction2 uses Python identifier friction2
    __friction2 = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'friction2'), 'friction2', '__AbsentNamespace0_CTD_ANON_126_friction2', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 114, 20), )

    
    friction2 = property(__friction2.value, __friction2.set, None, '\n                          Coefficient of friction in the range of [0..1].\n                        ')

    
    # Element fdir1 uses Python identifier fdir1
    __fdir1 = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'fdir1'), 'fdir1', '__AbsentNamespace0_CTD_ANON_126_fdir1', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 123, 20), )

    
    fdir1 = property(__fdir1.value, __fdir1.set, None, '\n                          3-tuple specifying direction of mu1 in the collision local reference frame.\n                        ')

    
    # Element rolling_friction uses Python identifier rolling_friction
    __rolling_friction = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'rolling_friction'), 'rolling_friction', '__AbsentNamespace0_CTD_ANON_126_rolling_friction', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 132, 20), )

    
    rolling_friction = property(__rolling_friction.value, __rolling_friction.set, None, '\n                           coefficient of friction in the range of [0..1]\n                        ')

    _ElementMap.update({
        __friction.name() : __friction,
        __friction2.name() : __friction2,
        __fdir1.name() : __fdir1,
        __rolling_friction.name() : __rolling_friction
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_126 = CTD_ANON_126


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_127 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 150, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element collide_without_contact uses Python identifier collide_without_contact
    __collide_without_contact = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'collide_without_contact'), 'collide_without_contact', '__AbsentNamespace0_CTD_ANON_127_collide_without_contact', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 153, 14), )

    
    collide_without_contact = property(__collide_without_contact.value, __collide_without_contact.set, None, '\n                    Flag to disable contact force generation, while still allowing collision checks and contact visualization to occur.\n                  ')

    
    # Element collide_without_contact_bitmask uses Python identifier collide_without_contact_bitmask
    __collide_without_contact_bitmask = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'collide_without_contact_bitmask'), 'collide_without_contact_bitmask', '__AbsentNamespace0_CTD_ANON_127_collide_without_contact_bitmask', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 162, 14), )

    
    collide_without_contact_bitmask = property(__collide_without_contact_bitmask.value, __collide_without_contact_bitmask.set, None, '\n                    Bitmask for collision filtering when collide_without_contact is on \n                  ')

    
    # Element collide_bitmask uses Python identifier collide_bitmask
    __collide_bitmask = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'collide_bitmask'), 'collide_bitmask', '__AbsentNamespace0_CTD_ANON_127_collide_bitmask', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 171, 14), )

    
    collide_bitmask = property(__collide_bitmask.value, __collide_bitmask.set, None, '\n                    Bitmask for collision filtering. This will override collide_without_contact\n                  ')

    
    # Element ode uses Python identifier ode
    __ode = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'ode'), 'ode', '__AbsentNamespace0_CTD_ANON_127_ode', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 180, 14), )

    
    ode = property(__ode.value, __ode.set, None, '\n                    ODE contact parameters\n                  ')

    
    # Element bullet uses Python identifier bullet
    __bullet = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'bullet'), 'bullet', '__AbsentNamespace0_CTD_ANON_127_bullet', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 247, 14), )

    
    bullet = property(__bullet.value, __bullet.set, None, '\n                    Bullet contact parameters\n                  ')

    _ElementMap.update({
        __collide_without_contact.name() : __collide_without_contact,
        __collide_without_contact_bitmask.name() : __collide_without_contact_bitmask,
        __collide_bitmask.name() : __collide_bitmask,
        __ode.name() : __ode,
        __bullet.name() : __bullet
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_127 = CTD_ANON_127


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_128 (pyxb.binding.basis.complexTypeDefinition):
    """
                    ODE contact parameters
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 186, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element soft_cfm uses Python identifier soft_cfm
    __soft_cfm = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'soft_cfm'), 'soft_cfm', '__AbsentNamespace0_CTD_ANON_128_soft_cfm', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 189, 20), )

    
    soft_cfm = property(__soft_cfm.value, __soft_cfm.set, None, '\n                          Soft constraint force mixing.\n                        ')

    
    # Element soft_erp uses Python identifier soft_erp
    __soft_erp = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'soft_erp'), 'soft_erp', '__AbsentNamespace0_CTD_ANON_128_soft_erp', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 198, 20), )

    
    soft_erp = property(__soft_erp.value, __soft_erp.set, None, '\n                          Soft error reduction parameter\n                        ')

    
    # Element kp uses Python identifier kp
    __kp = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'kp'), 'kp', '__AbsentNamespace0_CTD_ANON_128_kp', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 207, 20), )

    
    kp = property(__kp.value, __kp.set, None, '\n                          dynamically "stiffness"-equivalent coefficient for contact joints\n                        ')

    
    # Element kd uses Python identifier kd
    __kd = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'kd'), 'kd', '__AbsentNamespace0_CTD_ANON_128_kd', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 216, 20), )

    
    kd = property(__kd.value, __kd.set, None, '\n                          dynamically "damping"-equivalent coefficient for contact joints\n                        ')

    
    # Element max_vel uses Python identifier max_vel
    __max_vel = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'max_vel'), 'max_vel', '__AbsentNamespace0_CTD_ANON_128_max_vel', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 225, 20), )

    
    max_vel = property(__max_vel.value, __max_vel.set, None, '\n                          maximum contact correction velocity truncation term.\n                        ')

    
    # Element min_depth uses Python identifier min_depth
    __min_depth = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'min_depth'), 'min_depth', '__AbsentNamespace0_CTD_ANON_128_min_depth', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 234, 20), )

    
    min_depth = property(__min_depth.value, __min_depth.set, None, '\n                          minimum allowable depth before contact correction impulse is applied\n                        ')

    _ElementMap.update({
        __soft_cfm.name() : __soft_cfm,
        __soft_erp.name() : __soft_erp,
        __kp.name() : __kp,
        __kd.name() : __kd,
        __max_vel.name() : __max_vel,
        __min_depth.name() : __min_depth
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_128 = CTD_ANON_128


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_129 (pyxb.binding.basis.complexTypeDefinition):
    """
                    Bullet contact parameters
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 253, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element soft_cfm uses Python identifier soft_cfm
    __soft_cfm = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'soft_cfm'), 'soft_cfm', '__AbsentNamespace0_CTD_ANON_129_soft_cfm', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 256, 20), )

    
    soft_cfm = property(__soft_cfm.value, __soft_cfm.set, None, '\n                          Soft constraint force mixing.\n                        ')

    
    # Element soft_erp uses Python identifier soft_erp
    __soft_erp = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'soft_erp'), 'soft_erp', '__AbsentNamespace0_CTD_ANON_129_soft_erp', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 265, 20), )

    
    soft_erp = property(__soft_erp.value, __soft_erp.set, None, '\n                          Soft error reduction parameter\n                        ')

    
    # Element kp uses Python identifier kp
    __kp = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'kp'), 'kp', '__AbsentNamespace0_CTD_ANON_129_kp', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 274, 20), )

    
    kp = property(__kp.value, __kp.set, None, '\n                          dynamically "stiffness"-equivalent coefficient for contact joints\n                        ')

    
    # Element kd uses Python identifier kd
    __kd = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'kd'), 'kd', '__AbsentNamespace0_CTD_ANON_129_kd', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 283, 20), )

    
    kd = property(__kd.value, __kd.set, None, '\n                          dynamically "damping"-equivalent coefficient for contact joints\n                        ')

    
    # Element split_impulse uses Python identifier split_impulse
    __split_impulse = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'split_impulse'), 'split_impulse', '__AbsentNamespace0_CTD_ANON_129_split_impulse', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 292, 20), )

    
    split_impulse = property(__split_impulse.value, __split_impulse.set, None, "\n                          Similar to ODE's max_vel implementation.  See http://bulletphysics.org/mediawiki-1.5.8/index.php/BtContactSolverInfo#Split_Impulse for more information.\n                        ")

    
    # Element split_impulse_penetration_threshold uses Python identifier split_impulse_penetration_threshold
    __split_impulse_penetration_threshold = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'split_impulse_penetration_threshold'), 'split_impulse_penetration_threshold', '__AbsentNamespace0_CTD_ANON_129_split_impulse_penetration_threshold', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 301, 20), )

    
    split_impulse_penetration_threshold = property(__split_impulse_penetration_threshold.value, __split_impulse_penetration_threshold.set, None, "\n                          Similar to ODE's max_vel implementation.  See http://bulletphysics.org/mediawiki-1.5.8/index.php/BtContactSolverInfo#Split_Impulse for more information.\n                        ")

    _ElementMap.update({
        __soft_cfm.name() : __soft_cfm,
        __soft_erp.name() : __soft_erp,
        __kp.name() : __kp,
        __kd.name() : __kd,
        __split_impulse.name() : __split_impulse,
        __split_impulse_penetration_threshold.name() : __split_impulse_penetration_threshold
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_129 = CTD_ANON_129


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_130 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 319, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element dart uses Python identifier dart
    __dart = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'dart'), 'dart', '__AbsentNamespace0_CTD_ANON_130_dart', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 322, 14), )

    
    dart = property(__dart.value, __dart.set, None, '\n                    soft contact pamameters based on paper:\n             http://www.cc.gatech.edu/graphics/projects/Sumit/homepage/papers/sigasia11/jain_softcontacts_siga11.pdf\n      \n                  ')

    _ElementMap.update({
        __dart.name() : __dart
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_130 = CTD_ANON_130


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_131 (pyxb.binding.basis.complexTypeDefinition):
    """
                    soft contact pamameters based on paper:
             http://www.cc.gatech.edu/graphics/projects/Sumit/homepage/papers/sigasia11/jain_softcontacts_siga11.pdf
      
                  """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 330, 16)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element bone_attachment uses Python identifier bone_attachment
    __bone_attachment = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'bone_attachment'), 'bone_attachment', '__AbsentNamespace0_CTD_ANON_131_bone_attachment', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 333, 20), )

    
    bone_attachment = property(__bone_attachment.value, __bone_attachment.set, None, '\n                          This is variable k_v in the soft contacts paper.  Its unit is N/m.\n                        ')

    
    # Element stiffness uses Python identifier stiffness
    __stiffness = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'stiffness'), 'stiffness', '__AbsentNamespace0_CTD_ANON_131_stiffness', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 342, 20), )

    
    stiffness = property(__stiffness.value, __stiffness.set, None, '\n                          This is variable k_e in the soft contacts paper.  Its unit is N/m.\n                        ')

    
    # Element damping uses Python identifier damping
    __damping = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'damping'), 'damping', '__AbsentNamespace0_CTD_ANON_131_damping', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 351, 20), )

    
    damping = property(__damping.value, __damping.set, None, '\n                          Viscous damping of point velocity in body frame.  Its unit is N/m/s.\n                        ')

    
    # Element flesh_mass_fraction uses Python identifier flesh_mass_fraction
    __flesh_mass_fraction = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'flesh_mass_fraction'), 'flesh_mass_fraction', '__AbsentNamespace0_CTD_ANON_131_flesh_mass_fraction', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 360, 20), )

    
    flesh_mass_fraction = property(__flesh_mass_fraction.value, __flesh_mass_fraction.set, None, '\n                          Fraction of mass to be distributed among deformable nodes.\n                        ')

    _ElementMap.update({
        __bone_attachment.name() : __bone_attachment,
        __stiffness.name() : __stiffness,
        __damping.name() : __damping,
        __flesh_mass_fraction.name() : __flesh_mass_fraction
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_131 = CTD_ANON_131


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_132 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 10, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element essid uses Python identifier essid
    __essid = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'essid'), 'essid', '__AbsentNamespace0_CTD_ANON_132_essid', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 13, 8), )

    
    essid = property(__essid.value, __essid.set, None, '\n              Service set identifier (network name)\n            ')

    
    # Element frequency uses Python identifier frequency
    __frequency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'frequency'), 'frequency', '__AbsentNamespace0_CTD_ANON_132_frequency', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 22, 8), )

    
    frequency = property(__frequency.value, __frequency.set, None, '\n              Specifies the frequency of transmission in MHz\n            ')

    
    # Element min_frequency uses Python identifier min_frequency
    __min_frequency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'min_frequency'), 'min_frequency', '__AbsentNamespace0_CTD_ANON_132_min_frequency', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 31, 8), )

    
    min_frequency = property(__min_frequency.value, __min_frequency.set, None, '\n              Only a frequency range is filtered. Here we set the lower bound (MHz).\n    \n            ')

    
    # Element max_frequency uses Python identifier max_frequency
    __max_frequency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'max_frequency'), 'max_frequency', '__AbsentNamespace0_CTD_ANON_132_max_frequency', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 41, 8), )

    
    max_frequency = property(__max_frequency.value, __max_frequency.set, None, '\n              Only a frequency range is filtered. Here we set the upper bound (MHz).\n    \n            ')

    
    # Element gain uses Python identifier gain
    __gain = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'gain'), 'gain', '__AbsentNamespace0_CTD_ANON_132_gain', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 51, 8), )

    
    gain = property(__gain.value, __gain.set, None, '\n              Specifies the antenna gain in dBi\n            ')

    
    # Element power uses Python identifier power
    __power = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'power'), 'power', '__AbsentNamespace0_CTD_ANON_132_power', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 60, 8), )

    
    power = property(__power.value, __power.set, None, '\n              Specifies the transmission power in dBm\n            ')

    
    # Element sensitivity uses Python identifier sensitivity
    __sensitivity = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'sensitivity'), 'sensitivity', '__AbsentNamespace0_CTD_ANON_132_sensitivity', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 69, 8), )

    
    sensitivity = property(__sensitivity.value, __sensitivity.set, None, '\n              Mininum received signal power in dBm\n            ')

    _ElementMap.update({
        __essid.name() : __essid,
        __frequency.name() : __frequency,
        __min_frequency.name() : __min_frequency,
        __max_frequency.name() : __max_frequency,
        __gain.name() : __gain,
        __power.name() : __power,
        __sensitivity.name() : __sensitivity
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_132 = CTD_ANON_132


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_133 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 13, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element geometry uses Python identifier geometry
    __geometry = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'geometry'), 'geometry', '__AbsentNamespace0_CTD_ANON_133_geometry', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/geometry.xsd', 17, 2), )

    
    geometry = property(__geometry.value, __geometry.set, None, None)

    
    # Element material uses Python identifier material
    __material = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'material'), 'material', '__AbsentNamespace0_CTD_ANON_133_material', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 9, 2), )

    
    material = property(__material.value, __material.set, None, None)

    
    # Element plugin uses Python identifier plugin
    __plugin = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'plugin'), 'plugin', '__AbsentNamespace0_CTD_ANON_133_plugin', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/plugin.xsd', 9, 2), )

    
    plugin = property(__plugin.value, __plugin.set, None, None)

    
    # Element cast_shadows uses Python identifier cast_shadows
    __cast_shadows = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'cast_shadows'), 'cast_shadows', '__AbsentNamespace0_CTD_ANON_133_cast_shadows', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 16, 8), )

    
    cast_shadows = property(__cast_shadows.value, __cast_shadows.set, None, '\n              If true the visual will cast shadows.\n            ')

    
    # Element laser_retro uses Python identifier laser_retro
    __laser_retro = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'laser_retro'), 'laser_retro', '__AbsentNamespace0_CTD_ANON_133_laser_retro', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 25, 8), )

    
    laser_retro = property(__laser_retro.value, __laser_retro.set, None, '\n              will be implemented in the future release.\n            ')

    
    # Element transparency uses Python identifier transparency
    __transparency = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'transparency'), 'transparency', '__AbsentNamespace0_CTD_ANON_133_transparency', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 34, 8), )

    
    transparency = property(__transparency.value, __transparency.set, None, '\n              The amount of transparency( 0=opaque, 1 = fully transparent)\n            ')

    
    # Element pose uses Python identifier pose
    __pose = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'pose'), 'pose', '__AbsentNamespace0_CTD_ANON_133_pose', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 43, 8), )

    
    pose = property(__pose.value, __pose.set, None, '\n              The reference frame of the visual element, relative to the reference frame of the link.\n            ')

    
    # Element meta uses Python identifier meta
    __meta = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'meta'), 'meta', '__AbsentNamespace0_CTD_ANON_133_meta', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 52, 8), )

    
    meta = property(__meta.value, __meta.set, None, '\n              Optional meta information for the visual. The information contained within this element should be used to provide additional feedback to an end user.\n            ')

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_133_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 77, 6)
    __name._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 77, 6)
    
    name = property(__name.value, __name.set, None, '\n            Unique name for the visual element within the scope of the parent link.\n          ')

    _ElementMap.update({
        __geometry.name() : __geometry,
        __material.name() : __material,
        __plugin.name() : __plugin,
        __cast_shadows.name() : __cast_shadows,
        __laser_retro.name() : __laser_retro,
        __transparency.name() : __transparency,
        __pose.name() : __pose,
        __meta.name() : __meta
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_module_typeBindings.CTD_ANON_133 = CTD_ANON_133


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_134 (pyxb.binding.basis.complexTypeDefinition):
    """
              Optional meta information for the visual. The information contained within this element should be used to provide additional feedback to an end user.
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 58, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element layer uses Python identifier layer
    __layer = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'layer'), 'layer', '__AbsentNamespace0_CTD_ANON_134_layer', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 61, 14), )

    
    layer = property(__layer.value, __layer.set, None, '\n                    The layer in which this visual is displayed. The layer number is useful for programs, such as Gazebo, that put visuals in different layers for enhanced visualization.\n                  ')

    _ElementMap.update({
        __layer.name() : __layer
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_134 = CTD_ANON_134


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_135 (pyxb.binding.basis.complexTypeDefinition):
    """Complex type [anonymous] with content type ELEMENT_ONLY"""
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 22, 4)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element actor uses Python identifier actor
    __actor = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'actor'), 'actor', '__AbsentNamespace0_CTD_ANON_135_actor', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 7, 2), )

    
    actor = property(__actor.value, __actor.set, None, None)

    
    # Element gui uses Python identifier gui
    __gui = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'gui'), 'gui', '__AbsentNamespace0_CTD_ANON_135_gui', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 5, 2), )

    
    gui = property(__gui.value, __gui.set, None, None)

    
    # Element joint uses Python identifier joint
    __joint = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'joint'), 'joint', '__AbsentNamespace0_CTD_ANON_135_joint', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 10, 2), )

    
    joint = property(__joint.value, __joint.set, None, None)

    
    # Element light uses Python identifier light
    __light = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'light'), 'light', '__AbsentNamespace0_CTD_ANON_135_light', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 9, 2), )

    
    light = property(__light.value, __light.set, None, None)

    
    # Element model uses Python identifier model
    __model = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'model'), 'model', '__AbsentNamespace0_CTD_ANON_135_model', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 13, 2), )

    
    model = property(__model.value, __model.set, None, None)

    
    # Element physics uses Python identifier physics
    __physics = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'physics'), 'physics', '__AbsentNamespace0_CTD_ANON_135_physics', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 9, 2), )

    
    physics = property(__physics.value, __physics.set, None, None)

    
    # Element plugin uses Python identifier plugin
    __plugin = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'plugin'), 'plugin', '__AbsentNamespace0_CTD_ANON_135_plugin', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/plugin.xsd', 9, 2), )

    
    plugin = property(__plugin.value, __plugin.set, None, None)

    
    # Element population uses Python identifier population
    __population = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'population'), 'population', '__AbsentNamespace0_CTD_ANON_135_population', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 15, 2), )

    
    population = property(__population.value, __population.set, None, None)

    
    # Element road uses Python identifier road
    __road = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'road'), 'road', '__AbsentNamespace0_CTD_ANON_135_road', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/road.xsd', 5, 2), )

    
    road = property(__road.value, __road.set, None, None)

    
    # Element scene uses Python identifier scene
    __scene = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'scene'), 'scene', '__AbsentNamespace0_CTD_ANON_135_scene', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 9, 2), )

    
    scene = property(__scene.value, __scene.set, None, None)

    
    # Element spherical_coordinates uses Python identifier spherical_coordinates
    __spherical_coordinates = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'spherical_coordinates'), 'spherical_coordinates', '__AbsentNamespace0_CTD_ANON_135_spherical_coordinates', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/spherical_coordinates.xsd', 4, 2), )

    
    spherical_coordinates = property(__spherical_coordinates.value, __spherical_coordinates.set, None, None)

    
    # Element state uses Python identifier state
    __state = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(Namespace, 'state'), 'state', '__AbsentNamespace0_CTD_ANON_135_state', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 4, 2), )

    
    state = property(__state.value, __state.set, None, None)

    
    # Element audio uses Python identifier audio
    __audio = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'audio'), 'audio', '__AbsentNamespace0_CTD_ANON_135_audio', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 25, 8), )

    
    audio = property(__audio.value, __audio.set, None, '\n              Global audio properties.\n            ')

    
    # Element include uses Python identifier include
    __include = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'include'), 'include', '__AbsentNamespace0_CTD_ANON_135_include', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 47, 8), )

    
    include = property(__include.value, __include.set, None, '\n              Include resources from a URI\n            ')

    
    # Attribute name uses Python identifier name
    __name = pyxb.binding.content.AttributeUse(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_135_name', pyxb.binding.datatypes.string, required=True)
    __name._DeclarationLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 108, 6)
    __name._UseLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 108, 6)
    
    name = property(__name.value, __name.set, None, '\n            Unique name of the world\n          ')

    _ElementMap.update({
        __actor.name() : __actor,
        __gui.name() : __gui,
        __joint.name() : __joint,
        __light.name() : __light,
        __model.name() : __model,
        __physics.name() : __physics,
        __plugin.name() : __plugin,
        __population.name() : __population,
        __road.name() : __road,
        __scene.name() : __scene,
        __spherical_coordinates.name() : __spherical_coordinates,
        __state.name() : __state,
        __audio.name() : __audio,
        __include.name() : __include
    })
    _AttributeMap.update({
        __name.name() : __name
    })
_module_typeBindings.CTD_ANON_135 = CTD_ANON_135


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_136 (pyxb.binding.basis.complexTypeDefinition):
    """
              Global audio properties.
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 31, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element device uses Python identifier device
    __device = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'device'), 'device', '__AbsentNamespace0_CTD_ANON_136_device', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 34, 14), )

    
    device = property(__device.value, __device.set, None, '\n                    Device to use for audio playback. A value of "default" will use the system\'s default audio device. Otherwise, specify a an audio device file"\n                  ')

    _ElementMap.update({
        __device.name() : __device
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_136 = CTD_ANON_136


# Complex type [anonymous] with content type ELEMENT_ONLY
class CTD_ANON_137 (pyxb.binding.basis.complexTypeDefinition):
    """
              Include resources from a URI
            """
    _TypeDefinition = None
    _ContentTypeTag = pyxb.binding.basis.complexTypeDefinition._CT_ELEMENT_ONLY
    _Abstract = False
    _ExpandedName = None
    _XSDLocation = pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 53, 10)
    _ElementMap = {}
    _AttributeMap = {}
    # Base type is pyxb.binding.datatypes.anyType
    
    # Element uri uses Python identifier uri
    __uri = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'uri'), 'uri', '__AbsentNamespace0_CTD_ANON_137_uri', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 56, 14), )

    
    uri = property(__uri.value, __uri.set, None, '\n                    URI to a resource, such as a model\n                  ')

    
    # Element pose uses Python identifier pose
    __pose = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'pose'), 'pose', '__AbsentNamespace0_CTD_ANON_137_pose', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 65, 14), )

    
    pose = property(__pose.value, __pose.set, None, '\n                    Override the pose of the included model. A position and orientation in the global coordinate frame for the model. Position(x,y,z) and rotation (roll, pitch yaw) in the global coordinate frame.\n                  ')

    
    # Element name uses Python identifier name
    __name = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'name'), 'name', '__AbsentNamespace0_CTD_ANON_137_name', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 74, 14), )

    
    name = property(__name.value, __name.set, None, '\n                    Override the name of the included model.\n                  ')

    
    # Element static uses Python identifier static
    __static = pyxb.binding.content.ElementDeclaration(pyxb.namespace.ExpandedName(None, 'static'), 'static', '__AbsentNamespace0_CTD_ANON_137_static', True, pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 83, 14), )

    
    static = property(__static.value, __static.set, None, '\n                    Override the static value of the included model.\n                  ')

    _ElementMap.update({
        __uri.name() : __uri,
        __pose.name() : __pose,
        __name.name() : __name,
        __static.name() : __static
    })
    _AttributeMap.update({
        
    })
_module_typeBindings.CTD_ANON_137 = CTD_ANON_137


audio_sink = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'audio_sink'), pyxb.binding.datatypes.anyType, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_sink.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', audio_sink.name().localName(), audio_sink)

rfidtag = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'rfidtag'), pyxb.binding.datatypes.anyType, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/rfid.xsd', 4, 2))
Namespace.addCategoryObject('elementBinding', rfidtag.name().localName(), rfidtag)

rfid = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'rfid'), pyxb.binding.datatypes.anyType, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/rfidtag.xsd', 4, 2))
Namespace.addCategoryObject('elementBinding', rfid.name().localName(), rfid)

actor = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'actor'), CTD_ANON, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 7, 2))
Namespace.addCategoryObject('elementBinding', actor.name().localName(), actor)

altimeter = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'altimeter'), CTD_ANON_6, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/altimeter.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', altimeter.name().localName(), altimeter)

audio_source = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'audio_source'), CTD_ANON_9, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', audio_source.name().localName(), audio_source)

box = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'box'), CTD_ANON_11, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/box_shape.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', box.name().localName(), box)

camera = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'camera'), CTD_ANON_12, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', camera.name().localName(), camera)

collision = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'collision'), CTD_ANON_19, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/collision.xsd', 11, 2))
Namespace.addCategoryObject('elementBinding', collision.name().localName(), collision)

contact = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'contact'), CTD_ANON_20, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/contact.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', contact.name().localName(), contact)

cylinder = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'cylinder'), CTD_ANON_21, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/cylinder_shape.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', cylinder.name().localName(), cylinder)

force_torque = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'force_torque'), CTD_ANON_22, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/forcetorque.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', force_torque.name().localName(), force_torque)

geometry = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'geometry'), CTD_ANON_23, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/geometry.xsd', 17, 2))
Namespace.addCategoryObject('elementBinding', geometry.name().localName(), geometry)

gps = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'gps'), CTD_ANON_25, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', gps.name().localName(), gps)

gripper = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'gripper'), CTD_ANON_32, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 4, 2))
Namespace.addCategoryObject('elementBinding', gripper.name().localName(), gripper)

gui = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'gui'), CTD_ANON_34, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 5, 2))
Namespace.addCategoryObject('elementBinding', gui.name().localName(), gui)

heightmap = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'heightmap'), CTD_ANON_37, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', heightmap.name().localName(), heightmap)

image = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'image'), CTD_ANON_40, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/image_shape.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', image.name().localName(), image)

imu = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'imu'), CTD_ANON_41, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', imu.name().localName(), imu)

inertial = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'inertial'), CTD_ANON_53, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', inertial.name().localName(), inertial)

joint = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'joint'), CTD_ANON_55, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 10, 2))
Namespace.addCategoryObject('elementBinding', joint.name().localName(), joint)

light = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'light'), CTD_ANON_67, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', light.name().localName(), light)

link = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'link'), CTD_ANON_70, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 16, 2))
Namespace.addCategoryObject('elementBinding', link.name().localName(), link)

logical_camera = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'logical_camera'), CTD_ANON_72, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/logical_camera.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', logical_camera.name().localName(), logical_camera)

magnetometer = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'magnetometer'), CTD_ANON_73, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/magnetometer.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', magnetometer.name().localName(), magnetometer)

material = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'material'), CTD_ANON_77, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', material.name().localName(), material)

mesh = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'mesh'), CTD_ANON_80, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/mesh_shape.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', mesh.name().localName(), mesh)

model = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'model'), CTD_ANON_82, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 13, 2))
Namespace.addCategoryObject('elementBinding', model.name().localName(), model)

physics = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'physics'), CTD_ANON_84, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', physics.name().localName(), physics)

plane = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'plane'), CTD_ANON_93, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/plane_shape.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', plane.name().localName(), plane)

plugin = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'plugin'), CTD_ANON_94, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/plugin.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', plugin.name().localName(), plugin)

polyline = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'polyline'), CTD_ANON_95, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/polyline_shape.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', polyline.name().localName(), polyline)

population = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'population'), CTD_ANON_96, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 15, 2))
Namespace.addCategoryObject('elementBinding', population.name().localName(), population)

projector = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'projector'), CTD_ANON_98, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 5, 2))
Namespace.addCategoryObject('elementBinding', projector.name().localName(), projector)

ray = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'ray'), CTD_ANON_99, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', ray.name().localName(), ray)

road = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'road'), CTD_ANON_105, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/road.xsd', 5, 2))
Namespace.addCategoryObject('elementBinding', road.name().localName(), road)

sdf = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'sdf'), CTD_ANON_106, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/root.xsd', 13, 2))
Namespace.addCategoryObject('elementBinding', sdf.name().localName(), sdf)

scene = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'scene'), CTD_ANON_107, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', scene.name().localName(), scene)

sensor = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'sensor'), CTD_ANON_111, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 23, 2))
Namespace.addCategoryObject('elementBinding', sensor.name().localName(), sensor)

sonar = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'sonar'), CTD_ANON_112, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/sonar.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', sonar.name().localName(), sonar)

sphere = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'sphere'), CTD_ANON_113, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/sphere_shape.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', sphere.name().localName(), sphere)

spherical_coordinates = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'spherical_coordinates'), CTD_ANON_114, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/spherical_coordinates.xsd', 4, 2))
Namespace.addCategoryObject('elementBinding', spherical_coordinates.name().localName(), spherical_coordinates)

state = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'state'), CTD_ANON_115, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 4, 2))
Namespace.addCategoryObject('elementBinding', state.name().localName(), state)

surface = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'surface'), CTD_ANON_122, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', surface.name().localName(), surface)

transceiver = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'transceiver'), CTD_ANON_132, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 9, 2))
Namespace.addCategoryObject('elementBinding', transceiver.name().localName(), transceiver)

visual = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'visual'), CTD_ANON_133, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 12, 2))
Namespace.addCategoryObject('elementBinding', visual.name().localName(), visual)

world = pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'world'), CTD_ANON_135, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 21, 2))
Namespace.addCategoryObject('elementBinding', world.name().localName(), world)



CTD_ANON._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'static'), pyxb.binding.datatypes.boolean, scope=CTD_ANON, documentation='\n              Actors should be static, in terms of physics simulation.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 11, 8)))

CTD_ANON._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'pose'), pose, scope=CTD_ANON, documentation='\n              Origin of the actor\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 20, 8)))

CTD_ANON._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'skin'), CTD_ANON_, scope=CTD_ANON, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 29, 8)))

CTD_ANON._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'animation'), CTD_ANON_2, scope=CTD_ANON, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 45, 8)))

CTD_ANON._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'script'), CTD_ANON_3, scope=CTD_ANON, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 67, 8)))

CTD_ANON._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'joint'), CTD_ANON_55, scope=CTD_ANON, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 10, 2)))

CTD_ANON._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'link'), CTD_ANON_70, scope=CTD_ANON, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 16, 2)))

CTD_ANON._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'plugin'), CTD_ANON_94, scope=CTD_ANON, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/plugin.xsd', 9, 2)))

def _BuildAutomaton ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton
    del _BuildAutomaton
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 10, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 19, 8))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON._UseForTag(pyxb.namespace.ExpandedName(None, 'static')), pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 11, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON._UseForTag(pyxb.namespace.ExpandedName(None, 'pose')), pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 20, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON._UseForTag(pyxb.namespace.ExpandedName(None, 'skin')), pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 29, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON._UseForTag(pyxb.namespace.ExpandedName(None, 'animation')), pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 45, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON._UseForTag(pyxb.namespace.ExpandedName(None, 'script')), pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 67, 8))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'link')), pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 114, 8))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'joint')), pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 115, 8))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'plugin')), pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 116, 8))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON._Automaton = _BuildAutomaton()




CTD_ANON_._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'filename'), pyxb.binding.datatypes.string, scope=CTD_ANON_, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 33, 14)))

CTD_ANON_._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'scale'), pyxb.binding.datatypes.double, scope=CTD_ANON_, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 37, 14)))

def _BuildAutomaton_ ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_
    del _BuildAutomaton_
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 36, 14))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_._UseForTag(pyxb.namespace.ExpandedName(None, 'filename')), pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 33, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_._UseForTag(pyxb.namespace.ExpandedName(None, 'scale')), pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 37, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_._Automaton = _BuildAutomaton_()




CTD_ANON_2._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'filename'), pyxb.binding.datatypes.string, scope=CTD_ANON_2, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 49, 14)))

CTD_ANON_2._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'scale'), pyxb.binding.datatypes.double, scope=CTD_ANON_2, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 53, 14)))

CTD_ANON_2._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'interpolate_x'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_2, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 57, 14)))

def _BuildAutomaton_2 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_2
    del _BuildAutomaton_2
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 52, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 56, 14))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_2._UseForTag(pyxb.namespace.ExpandedName(None, 'filename')), pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 49, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_2._UseForTag(pyxb.namespace.ExpandedName(None, 'scale')), pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 53, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_2._UseForTag(pyxb.namespace.ExpandedName(None, 'interpolate_x')), pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 57, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_2._Automaton = _BuildAutomaton_2()




CTD_ANON_3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'loop'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_3, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 71, 14)))

CTD_ANON_3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'delay_start'), pyxb.binding.datatypes.double, scope=CTD_ANON_3, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 75, 14)))

CTD_ANON_3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'auto_start'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_3, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 79, 14)))

CTD_ANON_3._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'trajectory'), CTD_ANON_4, scope=CTD_ANON_3, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 83, 14)))

def _BuildAutomaton_3 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_3
    del _BuildAutomaton_3
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 70, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 74, 14))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 78, 14))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 82, 14))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_3._UseForTag(pyxb.namespace.ExpandedName(None, 'loop')), pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 71, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_3._UseForTag(pyxb.namespace.ExpandedName(None, 'delay_start')), pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 75, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_3._UseForTag(pyxb.namespace.ExpandedName(None, 'auto_start')), pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 79, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_3._UseForTag(pyxb.namespace.ExpandedName(None, 'trajectory')), pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 83, 14))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_3._Automaton = _BuildAutomaton_3()




CTD_ANON_4._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'waypoint'), CTD_ANON_5, scope=CTD_ANON_4, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 87, 20)))

def _BuildAutomaton_4 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_4
    del _BuildAutomaton_4
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 86, 20))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_4._UseForTag(pyxb.namespace.ExpandedName(None, 'waypoint')), pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 87, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_4._Automaton = _BuildAutomaton_4()




CTD_ANON_5._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'time'), pyxb.binding.datatypes.double, scope=CTD_ANON_5, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 91, 26)))

CTD_ANON_5._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'pose'), pose, scope=CTD_ANON_5, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 95, 26)))

def _BuildAutomaton_5 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_5
    del _BuildAutomaton_5
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_5._UseForTag(pyxb.namespace.ExpandedName(None, 'time')), pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 91, 26))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_5._UseForTag(pyxb.namespace.ExpandedName(None, 'pose')), pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 95, 26))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_5._Automaton = _BuildAutomaton_5()




CTD_ANON_6._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'vertical_position'), CTD_ANON_7, scope=CTD_ANON_6, documentation='\n              \n      Noise parameters for vertical position\n    \n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/altimeter.xsd', 13, 8)))

CTD_ANON_6._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'vertical_velocity'), CTD_ANON_8, scope=CTD_ANON_6, documentation='\n              \n      Noise parameters for vertical velocity\n    \n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/altimeter.xsd', 28, 8)))

def _BuildAutomaton_6 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_6
    del _BuildAutomaton_6
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/altimeter.xsd', 12, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/altimeter.xsd', 27, 8))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_6._UseForTag(pyxb.namespace.ExpandedName(None, 'vertical_position')), pyxb.utils.utility.Location('http://sdformat.org/schemas/altimeter.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_6._UseForTag(pyxb.namespace.ExpandedName(None, 'vertical_velocity')), pyxb.utils.utility.Location('http://sdformat.org/schemas/altimeter.xsd', 28, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_6._Automaton = _BuildAutomaton_6()




def _BuildAutomaton_7 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_7
    del _BuildAutomaton_7
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_7._Automaton = _BuildAutomaton_7()




def _BuildAutomaton_8 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_8
    del _BuildAutomaton_8
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_8._Automaton = _BuildAutomaton_8()




CTD_ANON_9._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'uri'), pyxb.binding.datatypes.string, scope=CTD_ANON_9, documentation='\n              URI of the audio media.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 13, 8)))

CTD_ANON_9._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'pitch'), pyxb.binding.datatypes.double, scope=CTD_ANON_9, documentation='\n              Pitch for the audio media, in Hz\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 22, 8)))

CTD_ANON_9._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'gain'), pyxb.binding.datatypes.double, scope=CTD_ANON_9, documentation='\n              Gain for the audio media, in dB.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 31, 8)))

CTD_ANON_9._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'contact'), CTD_ANON_10, scope=CTD_ANON_9, documentation='\n              List of collision objects that will trigger audio playback.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 40, 8)))

CTD_ANON_9._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'loop'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_9, documentation='\n              True to make the audio source loop playback.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 62, 8)))

CTD_ANON_9._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'pose'), pose, scope=CTD_ANON_9, documentation='\n              A position and orientation in the parent coordinate frame for the audio source. Position(x,y,z) and rotation (roll, pitch yaw) in the parent coordinate frame.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 71, 8)))

def _BuildAutomaton_9 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_9
    del _BuildAutomaton_9
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 21, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 30, 8))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 39, 8))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 61, 8))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 70, 8))
    counters.add(cc_4)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_9._UseForTag(pyxb.namespace.ExpandedName(None, 'uri')), pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_9._UseForTag(pyxb.namespace.ExpandedName(None, 'pitch')), pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 22, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_9._UseForTag(pyxb.namespace.ExpandedName(None, 'gain')), pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 31, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_9._UseForTag(pyxb.namespace.ExpandedName(None, 'contact')), pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 40, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_9._UseForTag(pyxb.namespace.ExpandedName(None, 'loop')), pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 62, 8))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_9._UseForTag(pyxb.namespace.ExpandedName(None, 'pose')), pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 71, 8))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_9._Automaton = _BuildAutomaton_9()




CTD_ANON_10._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'collision'), pyxb.binding.datatypes.string, scope=CTD_ANON_10, documentation='\n                    Name of child collision element that will trigger audio playback.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 49, 14)))

def _BuildAutomaton_10 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_10
    del _BuildAutomaton_10
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_10._UseForTag(pyxb.namespace.ExpandedName(None, 'collision')), pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 49, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_10._Automaton = _BuildAutomaton_10()




CTD_ANON_11._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'size'), vector3, scope=CTD_ANON_11, documentation='\n              The three side lengths of the box. The origin of the box is in its geometric center (inside the center of the box).\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/box_shape.xsd', 13, 8)))

def _BuildAutomaton_11 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_11
    del _BuildAutomaton_11
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_11._UseForTag(pyxb.namespace.ExpandedName(None, 'size')), pyxb.utils.utility.Location('http://sdformat.org/schemas/box_shape.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_11._Automaton = _BuildAutomaton_11()




CTD_ANON_12._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'pose'), pose, scope=CTD_ANON_12, documentation='\n              A position and orientation in the parent coordinate frame for the camera.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 13, 8)))

CTD_ANON_12._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'horizontal_fov'), pyxb.binding.datatypes.double, scope=CTD_ANON_12, documentation='\n              Horizontal field of view\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 22, 8)))

CTD_ANON_12._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'image'), CTD_ANON_13, scope=CTD_ANON_12, documentation='\n              The image size in pixels and format.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 31, 8)))

CTD_ANON_12._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'clip'), CTD_ANON_14, scope=CTD_ANON_12, documentation='\n              The near and far clip planes. Objects closer or farther than these planes are not rendered.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 71, 8)))

CTD_ANON_12._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'save'), CTD_ANON_15, scope=CTD_ANON_12, documentation='\n              Enable or disable saving of camera frames.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 102, 8)))

CTD_ANON_12._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'depth_camera'), CTD_ANON_16, scope=CTD_ANON_12, documentation='\n              Depth camera parameters\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 131, 8)))

CTD_ANON_12._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'noise'), CTD_ANON_17, scope=CTD_ANON_12, documentation='\n              The properties of the noise model that should be applied to generated images\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 153, 8)))

CTD_ANON_12._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'distortion'), CTD_ANON_18, scope=CTD_ANON_12, documentation='\n              Lens distortion to be applied to camera images. See http://en.wikipedia.org/wiki/Distortion_(optics)#Software_correction\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 193, 8)))

def _BuildAutomaton_12 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_12
    del _BuildAutomaton_12
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 12, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 101, 8))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 130, 8))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 152, 8))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 192, 8))
    counters.add(cc_4)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_12._UseForTag(pyxb.namespace.ExpandedName(None, 'pose')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_12._UseForTag(pyxb.namespace.ExpandedName(None, 'horizontal_fov')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 22, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_12._UseForTag(pyxb.namespace.ExpandedName(None, 'image')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 31, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_12._UseForTag(pyxb.namespace.ExpandedName(None, 'clip')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 71, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_12._UseForTag(pyxb.namespace.ExpandedName(None, 'save')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 102, 8))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_12._UseForTag(pyxb.namespace.ExpandedName(None, 'depth_camera')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 131, 8))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_12._UseForTag(pyxb.namespace.ExpandedName(None, 'noise')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 153, 8))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_12._UseForTag(pyxb.namespace.ExpandedName(None, 'distortion')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 193, 8))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_12._Automaton = _BuildAutomaton_12()




CTD_ANON_13._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'width'), pyxb.binding.datatypes.int, scope=CTD_ANON_13, documentation='\n                    Width in pixels\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 40, 14)))

CTD_ANON_13._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'height'), pyxb.binding.datatypes.int, scope=CTD_ANON_13, documentation='\n                    Height in pixels \n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 49, 14)))

CTD_ANON_13._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'format'), pyxb.binding.datatypes.string, scope=CTD_ANON_13, documentation='\n                    (L8|R8G8B8|B8G8R8|BAYER_RGGB8|BAYER_BGGR8|BAYER_GBRG8|BAYER_GRBG8)\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 58, 14)))

def _BuildAutomaton_13 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_13
    del _BuildAutomaton_13
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 57, 14))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_13._UseForTag(pyxb.namespace.ExpandedName(None, 'width')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 40, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_13._UseForTag(pyxb.namespace.ExpandedName(None, 'height')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 49, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_13._UseForTag(pyxb.namespace.ExpandedName(None, 'format')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 58, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_13._Automaton = _BuildAutomaton_13()




CTD_ANON_14._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'near'), pyxb.binding.datatypes.double, scope=CTD_ANON_14, documentation='\n                    Near clipping plane\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 80, 14)))

CTD_ANON_14._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'far'), pyxb.binding.datatypes.double, scope=CTD_ANON_14, documentation='\n                    Far clipping plane\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 89, 14)))

def _BuildAutomaton_14 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_14
    del _BuildAutomaton_14
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_14._UseForTag(pyxb.namespace.ExpandedName(None, 'near')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 80, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_14._UseForTag(pyxb.namespace.ExpandedName(None, 'far')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 89, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_14._Automaton = _BuildAutomaton_14()




CTD_ANON_15._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'path'), pyxb.binding.datatypes.string, scope=CTD_ANON_15, documentation='\n                    The path name which will hold the frame data. If path name is relative, then directory is relative to current working directory.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 111, 14)))

def _BuildAutomaton_15 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_15
    del _BuildAutomaton_15
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_15._UseForTag(pyxb.namespace.ExpandedName(None, 'path')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 111, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_15._Automaton = _BuildAutomaton_15()




CTD_ANON_16._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'output'), pyxb.binding.datatypes.string, scope=CTD_ANON_16, documentation='\n                    Type of output\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 140, 14)))

def _BuildAutomaton_16 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_16
    del _BuildAutomaton_16
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_16._UseForTag(pyxb.namespace.ExpandedName(None, 'output')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 140, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_16._Automaton = _BuildAutomaton_16()




CTD_ANON_17._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'type'), pyxb.binding.datatypes.string, scope=CTD_ANON_17, documentation='\n                    The type of noise.  Currently supported types are: "gaussian" (draw additive noise values independently for each pixel from a Gaussian distribution).\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 162, 14)))

CTD_ANON_17._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'mean'), pyxb.binding.datatypes.double, scope=CTD_ANON_17, documentation='\n                    For type "gaussian," the mean of the Gaussian distribution from which noise values are drawn.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 171, 14)))

CTD_ANON_17._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'stddev'), pyxb.binding.datatypes.double, scope=CTD_ANON_17, documentation='\n                    For type "gaussian," the standard deviation of the Gaussian distribution from which noise values are drawn.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 180, 14)))

def _BuildAutomaton_17 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_17
    del _BuildAutomaton_17
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 170, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 179, 14))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_17._UseForTag(pyxb.namespace.ExpandedName(None, 'type')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 162, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_17._UseForTag(pyxb.namespace.ExpandedName(None, 'mean')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 171, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_17._UseForTag(pyxb.namespace.ExpandedName(None, 'stddev')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 180, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_17._Automaton = _BuildAutomaton_17()




CTD_ANON_18._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'k1'), pyxb.binding.datatypes.double, scope=CTD_ANON_18, documentation='\n                    The radial distortion coefficient k1\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 202, 14)))

CTD_ANON_18._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'k2'), pyxb.binding.datatypes.double, scope=CTD_ANON_18, documentation='\n                    The radial distortion coefficient k2\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 211, 14)))

CTD_ANON_18._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'k3'), pyxb.binding.datatypes.double, scope=CTD_ANON_18, documentation='\n                    The radial distortion coefficient k3\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 220, 14)))

CTD_ANON_18._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'p1'), pyxb.binding.datatypes.double, scope=CTD_ANON_18, documentation='\n                    The tangential distortion coefficient p1\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 229, 14)))

CTD_ANON_18._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'p2'), pyxb.binding.datatypes.double, scope=CTD_ANON_18, documentation='\n                    The tangential distortion coefficient p2\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 238, 14)))

CTD_ANON_18._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'center'), vector2d, scope=CTD_ANON_18, documentation='\n                    The distortion center or principal point\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 247, 14)))

def _BuildAutomaton_18 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_18
    del _BuildAutomaton_18
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 201, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 210, 14))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 219, 14))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 228, 14))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 237, 14))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 246, 14))
    counters.add(cc_5)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_18._UseForTag(pyxb.namespace.ExpandedName(None, 'k1')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 202, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_18._UseForTag(pyxb.namespace.ExpandedName(None, 'k2')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 211, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_18._UseForTag(pyxb.namespace.ExpandedName(None, 'k3')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 220, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_18._UseForTag(pyxb.namespace.ExpandedName(None, 'p1')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 229, 14))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_18._UseForTag(pyxb.namespace.ExpandedName(None, 'p2')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 238, 14))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_18._UseForTag(pyxb.namespace.ExpandedName(None, 'center')), pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 247, 14))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_18._Automaton = _BuildAutomaton_18()




CTD_ANON_19._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'laser_retro'), pyxb.binding.datatypes.double, scope=CTD_ANON_19, documentation='\n              intensity value returned by laser sensor.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/collision.xsd', 15, 8)))

CTD_ANON_19._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'max_contacts'), pyxb.binding.datatypes.int, scope=CTD_ANON_19, documentation='\n              Maximum number of contacts allowed between two entities. This value overrides the max_contacts element defined in physics.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/collision.xsd', 24, 8)))

CTD_ANON_19._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'pose'), pose, scope=CTD_ANON_19, documentation='\n              The reference frame of the collision element, relative to the reference frame of the link.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/collision.xsd', 33, 8)))

CTD_ANON_19._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'geometry'), CTD_ANON_23, scope=CTD_ANON_19, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/geometry.xsd', 17, 2)))

CTD_ANON_19._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'surface'), CTD_ANON_122, scope=CTD_ANON_19, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 9, 2)))

def _BuildAutomaton_19 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_19
    del _BuildAutomaton_19
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/collision.xsd', 14, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/collision.xsd', 23, 8))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/collision.xsd', 32, 8))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_19._UseForTag(pyxb.namespace.ExpandedName(None, 'laser_retro')), pyxb.utils.utility.Location('http://sdformat.org/schemas/collision.xsd', 15, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_19._UseForTag(pyxb.namespace.ExpandedName(None, 'max_contacts')), pyxb.utils.utility.Location('http://sdformat.org/schemas/collision.xsd', 24, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_19._UseForTag(pyxb.namespace.ExpandedName(None, 'pose')), pyxb.utils.utility.Location('http://sdformat.org/schemas/collision.xsd', 33, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_19._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'geometry')), pyxb.utils.utility.Location('http://sdformat.org/schemas/collision.xsd', 41, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_19._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'surface')), pyxb.utils.utility.Location('http://sdformat.org/schemas/collision.xsd', 42, 8))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_19._Automaton = _BuildAutomaton_19()




CTD_ANON_20._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'collision'), pyxb.binding.datatypes.string, scope=CTD_ANON_20, documentation='\n              name of the collision element within a link that acts as the contact sensor.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/contact.xsd', 13, 8)))

CTD_ANON_20._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'topic'), pyxb.binding.datatypes.string, scope=CTD_ANON_20, documentation='\n              Topic on which contact data is published.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/contact.xsd', 22, 8)))

def _BuildAutomaton_20 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_20
    del _BuildAutomaton_20
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_20._UseForTag(pyxb.namespace.ExpandedName(None, 'collision')), pyxb.utils.utility.Location('http://sdformat.org/schemas/contact.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_20._UseForTag(pyxb.namespace.ExpandedName(None, 'topic')), pyxb.utils.utility.Location('http://sdformat.org/schemas/contact.xsd', 22, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_20._Automaton = _BuildAutomaton_20()




CTD_ANON_21._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'radius'), pyxb.binding.datatypes.double, scope=CTD_ANON_21, documentation='\n              Radius of the cylinder\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/cylinder_shape.xsd', 13, 8)))

CTD_ANON_21._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'length'), pyxb.binding.datatypes.double, scope=CTD_ANON_21, documentation='\n              Length of the cylinder\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/cylinder_shape.xsd', 22, 8)))

def _BuildAutomaton_21 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_21
    del _BuildAutomaton_21
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_21._UseForTag(pyxb.namespace.ExpandedName(None, 'radius')), pyxb.utils.utility.Location('http://sdformat.org/schemas/cylinder_shape.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_21._UseForTag(pyxb.namespace.ExpandedName(None, 'length')), pyxb.utils.utility.Location('http://sdformat.org/schemas/cylinder_shape.xsd', 22, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_21._Automaton = _BuildAutomaton_21()




CTD_ANON_22._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'frame'), pyxb.binding.datatypes.string, scope=CTD_ANON_22, documentation='\n              \n      Frame in which to report the wrench values. Currently supported frames are:\n        "parent" report the wrench expressed in the orientation of the parent link frame,\n        "child" report the wrench expressed in the orientation of the child link frame,\n        "sensor" report the wrench expressed in the orientation of the joint sensor frame.\n      Note that for each option the point with respect to which the \n      torque component of the wrench is expressed is the joint origin.\n    \n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/forcetorque.xsd', 13, 8)))

CTD_ANON_22._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'measure_direction'), pyxb.binding.datatypes.string, scope=CTD_ANON_22, documentation='\n              \n      Direction of the wrench measured by the sensor. The supported options are:\n        "parent_to_child" if the measured wrench is the one applied by parent link on the child link,\n        "child_to_parent" if the measured wrench is the one applied by the child link on the parent link.\n    \n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/forcetorque.xsd', 29, 8)))

def _BuildAutomaton_22 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_22
    del _BuildAutomaton_22
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/forcetorque.xsd', 12, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/forcetorque.xsd', 28, 8))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_22._UseForTag(pyxb.namespace.ExpandedName(None, 'frame')), pyxb.utils.utility.Location('http://sdformat.org/schemas/forcetorque.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_22._UseForTag(pyxb.namespace.ExpandedName(None, 'measure_direction')), pyxb.utils.utility.Location('http://sdformat.org/schemas/forcetorque.xsd', 29, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_22._Automaton = _BuildAutomaton_22()




CTD_ANON_23._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'box'), CTD_ANON_11, scope=CTD_ANON_23, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/box_shape.xsd', 9, 2)))

CTD_ANON_23._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'cylinder'), CTD_ANON_21, scope=CTD_ANON_23, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/cylinder_shape.xsd', 9, 2)))

CTD_ANON_23._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'empty'), CTD_ANON_24, scope=CTD_ANON_23, documentation='\n              You can use the empty tag to make empty geometries.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/geometry.xsd', 21, 8)))

CTD_ANON_23._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'heightmap'), CTD_ANON_37, scope=CTD_ANON_23, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 9, 2)))

CTD_ANON_23._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'image'), CTD_ANON_40, scope=CTD_ANON_23, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/image_shape.xsd', 9, 2)))

CTD_ANON_23._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'mesh'), CTD_ANON_80, scope=CTD_ANON_23, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/mesh_shape.xsd', 9, 2)))

CTD_ANON_23._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'plane'), CTD_ANON_93, scope=CTD_ANON_23, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/plane_shape.xsd', 9, 2)))

CTD_ANON_23._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'polyline'), CTD_ANON_95, scope=CTD_ANON_23, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/polyline_shape.xsd', 9, 2)))

CTD_ANON_23._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'sphere'), CTD_ANON_113, scope=CTD_ANON_23, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/sphere_shape.xsd', 9, 2)))

def _BuildAutomaton_23 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_23
    del _BuildAutomaton_23
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/geometry.xsd', 20, 8))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_23._UseForTag(pyxb.namespace.ExpandedName(None, 'empty')), pyxb.utils.utility.Location('http://sdformat.org/schemas/geometry.xsd', 21, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_23._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'box')), pyxb.utils.utility.Location('http://sdformat.org/schemas/geometry.xsd', 33, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_23._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'cylinder')), pyxb.utils.utility.Location('http://sdformat.org/schemas/geometry.xsd', 34, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_23._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'heightmap')), pyxb.utils.utility.Location('http://sdformat.org/schemas/geometry.xsd', 35, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_23._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'image')), pyxb.utils.utility.Location('http://sdformat.org/schemas/geometry.xsd', 36, 8))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_23._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'mesh')), pyxb.utils.utility.Location('http://sdformat.org/schemas/geometry.xsd', 37, 8))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_23._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'plane')), pyxb.utils.utility.Location('http://sdformat.org/schemas/geometry.xsd', 38, 8))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_23._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'polyline')), pyxb.utils.utility.Location('http://sdformat.org/schemas/geometry.xsd', 39, 8))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_23._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'sphere')), pyxb.utils.utility.Location('http://sdformat.org/schemas/geometry.xsd', 40, 8))
    st_8 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_8._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_23._Automaton = _BuildAutomaton_23()




def _BuildAutomaton_24 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_24
    del _BuildAutomaton_24
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_24._Automaton = _BuildAutomaton_24()




CTD_ANON_25._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'position_sensing'), CTD_ANON_26, scope=CTD_ANON_25, documentation='\n              \n      Parameters related to GPS position measurement.\n    \n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 13, 8)))

CTD_ANON_25._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'velocity_sensing'), CTD_ANON_29, scope=CTD_ANON_25, documentation='\n              \n      Parameters related to GPS position measurement.\n    \n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 58, 8)))

def _BuildAutomaton_25 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_25
    del _BuildAutomaton_25
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 12, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 57, 8))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_25._UseForTag(pyxb.namespace.ExpandedName(None, 'position_sensing')), pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_25._UseForTag(pyxb.namespace.ExpandedName(None, 'velocity_sensing')), pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 58, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_25._Automaton = _BuildAutomaton_25()




CTD_ANON_26._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'horizontal'), CTD_ANON_27, scope=CTD_ANON_26, documentation='\n                    \n        Noise parameters for horizontal position measurement, in units of meters.\n      \n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 24, 14)))

CTD_ANON_26._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'vertical'), CTD_ANON_28, scope=CTD_ANON_26, documentation='\n                    \n        Noise parameters for vertical position measurement, in units of meters.\n      \n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 39, 14)))

def _BuildAutomaton_26 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_26
    del _BuildAutomaton_26
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 23, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 38, 14))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_26._UseForTag(pyxb.namespace.ExpandedName(None, 'horizontal')), pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 24, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_26._UseForTag(pyxb.namespace.ExpandedName(None, 'vertical')), pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 39, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_26._Automaton = _BuildAutomaton_26()




def _BuildAutomaton_27 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_27
    del _BuildAutomaton_27
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_27._Automaton = _BuildAutomaton_27()




def _BuildAutomaton_28 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_28
    del _BuildAutomaton_28
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_28._Automaton = _BuildAutomaton_28()




CTD_ANON_29._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'horizontal'), CTD_ANON_30, scope=CTD_ANON_29, documentation='\n                    \n        Noise parameters for horizontal velocity measurement, in units of meters/second.\n      \n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 69, 14)))

CTD_ANON_29._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'vertical'), CTD_ANON_31, scope=CTD_ANON_29, documentation='\n                    \n        Noise parameters for vertical velocity measurement, in units of meters/second.\n      \n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 84, 14)))

def _BuildAutomaton_29 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_29
    del _BuildAutomaton_29
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 68, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 83, 14))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_29._UseForTag(pyxb.namespace.ExpandedName(None, 'horizontal')), pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 69, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_29._UseForTag(pyxb.namespace.ExpandedName(None, 'vertical')), pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 84, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_29._Automaton = _BuildAutomaton_29()




def _BuildAutomaton_30 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_30
    del _BuildAutomaton_30
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_30._Automaton = _BuildAutomaton_30()




def _BuildAutomaton_31 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_31
    del _BuildAutomaton_31
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_31._Automaton = _BuildAutomaton_31()




CTD_ANON_32._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'grasp_check'), CTD_ANON_33, scope=CTD_ANON_32, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 8, 8)))

CTD_ANON_32._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'gripper_link'), pyxb.binding.datatypes.string, scope=CTD_ANON_32, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 28, 8)))

CTD_ANON_32._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'palm_link'), pyxb.binding.datatypes.string, scope=CTD_ANON_32, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 32, 8)))

def _BuildAutomaton_32 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_32
    del _BuildAutomaton_32
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 7, 8))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_32._UseForTag(pyxb.namespace.ExpandedName(None, 'grasp_check')), pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 8, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_32._UseForTag(pyxb.namespace.ExpandedName(None, 'gripper_link')), pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 28, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_32._UseForTag(pyxb.namespace.ExpandedName(None, 'palm_link')), pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 32, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_32._Automaton = _BuildAutomaton_32()




CTD_ANON_33._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'detach_steps'), pyxb.binding.datatypes.int, scope=CTD_ANON_33, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 12, 14)))

CTD_ANON_33._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'attach_steps'), pyxb.binding.datatypes.int, scope=CTD_ANON_33, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 16, 14)))

CTD_ANON_33._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'min_contact_count'), pyxb.binding.datatypes.unsignedInt, scope=CTD_ANON_33, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 20, 14)))

def _BuildAutomaton_33 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_33
    del _BuildAutomaton_33
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 11, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 15, 14))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 19, 14))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_33._UseForTag(pyxb.namespace.ExpandedName(None, 'detach_steps')), pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 12, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_33._UseForTag(pyxb.namespace.ExpandedName(None, 'attach_steps')), pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 16, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_33._UseForTag(pyxb.namespace.ExpandedName(None, 'min_contact_count')), pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 20, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_33._Automaton = _BuildAutomaton_33()




CTD_ANON_34._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'camera'), CTD_ANON_35, scope=CTD_ANON_34, documentation='\n               \n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 9, 8)))

CTD_ANON_34._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'plugin'), CTD_ANON_94, scope=CTD_ANON_34, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/plugin.xsd', 9, 2)))

def _BuildAutomaton_34 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_34
    del _BuildAutomaton_34
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 8, 8))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_34._UseForTag(pyxb.namespace.ExpandedName(None, 'camera')), pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 9, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_34._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'plugin')), pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 60, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_34._Automaton = _BuildAutomaton_34()




CTD_ANON_35._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'view_controller'), pyxb.binding.datatypes.string, scope=CTD_ANON_35, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 18, 14)))

CTD_ANON_35._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'projection_type'), pyxb.binding.datatypes.string, scope=CTD_ANON_35, documentation='\n                    Set the type of projection for the camera. Valid values are "perspective" and "orthographic".\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 22, 14)))

CTD_ANON_35._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'pose'), pose, scope=CTD_ANON_35, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 31, 14)))

CTD_ANON_35._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'track_visual'), CTD_ANON_36, scope=CTD_ANON_35, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 35, 14)))

def _BuildAutomaton_35 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_35
    del _BuildAutomaton_35
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 17, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 21, 14))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 30, 14))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 34, 14))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_35._UseForTag(pyxb.namespace.ExpandedName(None, 'view_controller')), pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 18, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_35._UseForTag(pyxb.namespace.ExpandedName(None, 'projection_type')), pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 22, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_35._UseForTag(pyxb.namespace.ExpandedName(None, 'pose')), pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 31, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_35._UseForTag(pyxb.namespace.ExpandedName(None, 'track_visual')), pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 35, 14))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_35._Automaton = _BuildAutomaton_35()




CTD_ANON_36._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'name'), pyxb.binding.datatypes.string, scope=CTD_ANON_36, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 39, 20)))

CTD_ANON_36._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'min_dist'), pyxb.binding.datatypes.double, scope=CTD_ANON_36, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 43, 20)))

CTD_ANON_36._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'max_dist'), pyxb.binding.datatypes.double, scope=CTD_ANON_36, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 47, 20)))

def _BuildAutomaton_36 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_36
    del _BuildAutomaton_36
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 42, 20))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 46, 20))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_36._UseForTag(pyxb.namespace.ExpandedName(None, 'name')), pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 39, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_36._UseForTag(pyxb.namespace.ExpandedName(None, 'min_dist')), pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 43, 20))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_36._UseForTag(pyxb.namespace.ExpandedName(None, 'max_dist')), pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 47, 20))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_36._Automaton = _BuildAutomaton_36()




CTD_ANON_37._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'uri'), pyxb.binding.datatypes.string, scope=CTD_ANON_37, documentation='\n              URI to a grayscale image file\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 13, 8)))

CTD_ANON_37._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'size'), vector3, scope=CTD_ANON_37, documentation='\n              The size of the heightmap in world units.\n      When loading an image: "size" is used if present, otherwise defaults to 1x1x1.\n      When loading a DEM: "size" is used if present, otherwise defaults to true size of DEM.\n  \n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 22, 8)))

CTD_ANON_37._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'pos'), vector3, scope=CTD_ANON_37, documentation='\n              A position offset.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 34, 8)))

CTD_ANON_37._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'texture'), CTD_ANON_38, scope=CTD_ANON_37, documentation='\n              The heightmap can contain multiple textures. The order of the texture matters. The first texture will appear at the lowest height, and the last texture at the highest height. Use blend to control the height thresholds and fade between textures.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 43, 8)))

CTD_ANON_37._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'blend'), CTD_ANON_39, scope=CTD_ANON_37, documentation='\n              The blend tag controls how two adjacent textures are mixed. The number of blend elements should equal one less than the number of textures.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 83, 8)))

CTD_ANON_37._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'use_terrain_paging'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_37, documentation='\n              Set if the rendering engine will use terrain paging\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 114, 8)))

def _BuildAutomaton_37 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_37
    del _BuildAutomaton_37
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 21, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 33, 8))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 42, 8))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 82, 8))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 113, 8))
    counters.add(cc_4)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_37._UseForTag(pyxb.namespace.ExpandedName(None, 'uri')), pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_37._UseForTag(pyxb.namespace.ExpandedName(None, 'size')), pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 22, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_37._UseForTag(pyxb.namespace.ExpandedName(None, 'pos')), pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 34, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_37._UseForTag(pyxb.namespace.ExpandedName(None, 'texture')), pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 43, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_37._UseForTag(pyxb.namespace.ExpandedName(None, 'blend')), pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 83, 8))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_37._UseForTag(pyxb.namespace.ExpandedName(None, 'use_terrain_paging')), pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 114, 8))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_37._Automaton = _BuildAutomaton_37()




CTD_ANON_38._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'size'), pyxb.binding.datatypes.double, scope=CTD_ANON_38, documentation='\n                    Size of the applied texture in meters.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 52, 14)))

CTD_ANON_38._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'diffuse'), pyxb.binding.datatypes.string, scope=CTD_ANON_38, documentation='\n                    Diffuse texture image filename\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 61, 14)))

CTD_ANON_38._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'normal'), pyxb.binding.datatypes.string, scope=CTD_ANON_38, documentation='\n                    Normalmap texture image filename\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 70, 14)))

def _BuildAutomaton_38 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_38
    del _BuildAutomaton_38
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_38._UseForTag(pyxb.namespace.ExpandedName(None, 'size')), pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 52, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_38._UseForTag(pyxb.namespace.ExpandedName(None, 'diffuse')), pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 61, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_38._UseForTag(pyxb.namespace.ExpandedName(None, 'normal')), pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 70, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_38._Automaton = _BuildAutomaton_38()




CTD_ANON_39._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'min_height'), pyxb.binding.datatypes.double, scope=CTD_ANON_39, documentation='\n                    Min height of a blend layer\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 92, 14)))

CTD_ANON_39._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'fade_dist'), pyxb.binding.datatypes.double, scope=CTD_ANON_39, documentation='\n                    Distance over which the blend occurs\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 101, 14)))

def _BuildAutomaton_39 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_39
    del _BuildAutomaton_39
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_39._UseForTag(pyxb.namespace.ExpandedName(None, 'min_height')), pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 92, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_39._UseForTag(pyxb.namespace.ExpandedName(None, 'fade_dist')), pyxb.utils.utility.Location('http://sdformat.org/schemas/heightmap_shape.xsd', 101, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_39._Automaton = _BuildAutomaton_39()




CTD_ANON_40._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'uri'), pyxb.binding.datatypes.string, scope=CTD_ANON_40, documentation='\n              URI of the grayscale image file\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/image_shape.xsd', 13, 8)))

CTD_ANON_40._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'scale'), pyxb.binding.datatypes.double, scope=CTD_ANON_40, documentation='\n              Scaling factor applied to the image\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/image_shape.xsd', 22, 8)))

CTD_ANON_40._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'threshold'), pyxb.binding.datatypes.int, scope=CTD_ANON_40, documentation='\n              Grayscale threshold\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/image_shape.xsd', 31, 8)))

CTD_ANON_40._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'height'), pyxb.binding.datatypes.double, scope=CTD_ANON_40, documentation='\n              Height of the extruded boxes\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/image_shape.xsd', 40, 8)))

CTD_ANON_40._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'granularity'), pyxb.binding.datatypes.int, scope=CTD_ANON_40, documentation='\n              The amount of error in the model\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/image_shape.xsd', 49, 8)))

def _BuildAutomaton_40 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_40
    del _BuildAutomaton_40
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_40._UseForTag(pyxb.namespace.ExpandedName(None, 'uri')), pyxb.utils.utility.Location('http://sdformat.org/schemas/image_shape.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_40._UseForTag(pyxb.namespace.ExpandedName(None, 'scale')), pyxb.utils.utility.Location('http://sdformat.org/schemas/image_shape.xsd', 22, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_40._UseForTag(pyxb.namespace.ExpandedName(None, 'threshold')), pyxb.utils.utility.Location('http://sdformat.org/schemas/image_shape.xsd', 31, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_40._UseForTag(pyxb.namespace.ExpandedName(None, 'height')), pyxb.utils.utility.Location('http://sdformat.org/schemas/image_shape.xsd', 40, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_40._UseForTag(pyxb.namespace.ExpandedName(None, 'granularity')), pyxb.utils.utility.Location('http://sdformat.org/schemas/image_shape.xsd', 49, 8))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_40._Automaton = _BuildAutomaton_40()




CTD_ANON_41._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'topic'), pyxb.binding.datatypes.string, scope=CTD_ANON_41, documentation='\n              Topic on which data is published.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 13, 8)))

CTD_ANON_41._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'angular_velocity'), CTD_ANON_42, scope=CTD_ANON_41, documentation='\n              These elements are specific to body-frame angular velocity,\n    which is expressed in radians per second\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 22, 8)))

CTD_ANON_41._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'linear_acceleration'), CTD_ANON_46, scope=CTD_ANON_41, documentation='\n              These elements are specific to body-frame linear acceleration,\n    which is expressed in meters per second squared\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 75, 8)))

CTD_ANON_41._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'noise'), CTD_ANON_50, scope=CTD_ANON_41, documentation='\n              The properties of the noise model that should be applied to generated data\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 128, 8)))

def _BuildAutomaton_41 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_41
    del _BuildAutomaton_41
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 12, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 21, 8))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 74, 8))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 127, 8))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_41._UseForTag(pyxb.namespace.ExpandedName(None, 'topic')), pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_41._UseForTag(pyxb.namespace.ExpandedName(None, 'angular_velocity')), pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 22, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_41._UseForTag(pyxb.namespace.ExpandedName(None, 'linear_acceleration')), pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 75, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_41._UseForTag(pyxb.namespace.ExpandedName(None, 'noise')), pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 128, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_41._Automaton = _BuildAutomaton_41()




CTD_ANON_42._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'x'), CTD_ANON_43, scope=CTD_ANON_42, documentation='\n                    Angular velocity about the X axis\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 32, 14)))

CTD_ANON_42._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'y'), CTD_ANON_44, scope=CTD_ANON_42, documentation='\n                    Angular velocity about the Y axis\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 45, 14)))

CTD_ANON_42._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'z'), CTD_ANON_45, scope=CTD_ANON_42, documentation='\n                    Angular velocity about the Z axis\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 58, 14)))

def _BuildAutomaton_42 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_42
    del _BuildAutomaton_42
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 31, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 44, 14))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 57, 14))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_42._UseForTag(pyxb.namespace.ExpandedName(None, 'x')), pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 32, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_42._UseForTag(pyxb.namespace.ExpandedName(None, 'y')), pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 45, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_42._UseForTag(pyxb.namespace.ExpandedName(None, 'z')), pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 58, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_42._Automaton = _BuildAutomaton_42()




def _BuildAutomaton_43 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_43
    del _BuildAutomaton_43
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_43._Automaton = _BuildAutomaton_43()




def _BuildAutomaton_44 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_44
    del _BuildAutomaton_44
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_44._Automaton = _BuildAutomaton_44()




def _BuildAutomaton_45 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_45
    del _BuildAutomaton_45
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_45._Automaton = _BuildAutomaton_45()




CTD_ANON_46._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'x'), CTD_ANON_47, scope=CTD_ANON_46, documentation='\n                    Linear acceleration about the X axis\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 85, 14)))

CTD_ANON_46._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'y'), CTD_ANON_48, scope=CTD_ANON_46, documentation='\n                    Linear acceleration about the Y axis\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 98, 14)))

CTD_ANON_46._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'z'), CTD_ANON_49, scope=CTD_ANON_46, documentation='\n                    Linear acceleration about the Z axis\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 111, 14)))

def _BuildAutomaton_46 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_46
    del _BuildAutomaton_46
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 84, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 97, 14))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 110, 14))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_46._UseForTag(pyxb.namespace.ExpandedName(None, 'x')), pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 85, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_46._UseForTag(pyxb.namespace.ExpandedName(None, 'y')), pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 98, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_46._UseForTag(pyxb.namespace.ExpandedName(None, 'z')), pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 111, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_46._Automaton = _BuildAutomaton_46()




def _BuildAutomaton_47 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_47
    del _BuildAutomaton_47
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_47._Automaton = _BuildAutomaton_47()




def _BuildAutomaton_48 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_48
    del _BuildAutomaton_48
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_48._Automaton = _BuildAutomaton_48()




def _BuildAutomaton_49 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_49
    del _BuildAutomaton_49
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_49._Automaton = _BuildAutomaton_49()




CTD_ANON_50._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'type'), pyxb.binding.datatypes.string, scope=CTD_ANON_50, documentation='\n                    The type of noise.  Currently supported types are: "gaussian" (draw noise values independently for each beam from a Gaussian distribution).\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 137, 14)))

CTD_ANON_50._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'rate'), CTD_ANON_51, scope=CTD_ANON_50, documentation='\n                    Noise parameters for angular rates.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 146, 14)))

CTD_ANON_50._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'accel'), CTD_ANON_52, scope=CTD_ANON_50, documentation='\n                    Noise parameters for linear accelerations.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 195, 14)))

def _BuildAutomaton_50 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_50
    del _BuildAutomaton_50
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_50._UseForTag(pyxb.namespace.ExpandedName(None, 'type')), pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 137, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_50._UseForTag(pyxb.namespace.ExpandedName(None, 'rate')), pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 146, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_50._UseForTag(pyxb.namespace.ExpandedName(None, 'accel')), pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 195, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_50._Automaton = _BuildAutomaton_50()




CTD_ANON_51._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'mean'), pyxb.binding.datatypes.double, scope=CTD_ANON_51, documentation='\n                          For type "gaussian," the mean of the Gaussian distribution from which noise values are drawn.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 155, 20)))

CTD_ANON_51._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'stddev'), pyxb.binding.datatypes.double, scope=CTD_ANON_51, documentation='\n                          For type "gaussian," the standard deviation of the Gaussian distribution from which noise values are drawn.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 164, 20)))

CTD_ANON_51._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'bias_mean'), pyxb.binding.datatypes.double, scope=CTD_ANON_51, documentation='\n                          For type "gaussian," the mean of the Gaussian distribution from which bias values are drawn.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 173, 20)))

CTD_ANON_51._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'bias_stddev'), pyxb.binding.datatypes.double, scope=CTD_ANON_51, documentation='\n                          For type "gaussian," the standard deviation of the Gaussian distribution from which bias values are drawn.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 182, 20)))

def _BuildAutomaton_51 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_51
    del _BuildAutomaton_51
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 154, 20))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 163, 20))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 172, 20))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 181, 20))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_51._UseForTag(pyxb.namespace.ExpandedName(None, 'mean')), pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 155, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_51._UseForTag(pyxb.namespace.ExpandedName(None, 'stddev')), pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 164, 20))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_51._UseForTag(pyxb.namespace.ExpandedName(None, 'bias_mean')), pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 173, 20))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_51._UseForTag(pyxb.namespace.ExpandedName(None, 'bias_stddev')), pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 182, 20))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_51._Automaton = _BuildAutomaton_51()




CTD_ANON_52._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'mean'), pyxb.binding.datatypes.double, scope=CTD_ANON_52, documentation='\n                          For type "gaussian," the mean of the Gaussian distribution from which noise values are drawn.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 204, 20)))

CTD_ANON_52._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'stddev'), pyxb.binding.datatypes.double, scope=CTD_ANON_52, documentation='\n                          For type "gaussian," the standard deviation of the Gaussian distribution from which noise values are drawn.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 213, 20)))

CTD_ANON_52._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'bias_mean'), pyxb.binding.datatypes.double, scope=CTD_ANON_52, documentation='\n                          For type "gaussian," the mean of the Gaussian distribution from which bias values are drawn.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 222, 20)))

CTD_ANON_52._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'bias_stddev'), pyxb.binding.datatypes.double, scope=CTD_ANON_52, documentation='\n                          For type "gaussian," the standard deviation of the Gaussian distribution from which bias values are drawn.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 231, 20)))

def _BuildAutomaton_52 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_52
    del _BuildAutomaton_52
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 203, 20))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 212, 20))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 221, 20))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 230, 20))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_52._UseForTag(pyxb.namespace.ExpandedName(None, 'mean')), pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 204, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_52._UseForTag(pyxb.namespace.ExpandedName(None, 'stddev')), pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 213, 20))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_52._UseForTag(pyxb.namespace.ExpandedName(None, 'bias_mean')), pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 222, 20))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_52._UseForTag(pyxb.namespace.ExpandedName(None, 'bias_stddev')), pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 231, 20))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_52._Automaton = _BuildAutomaton_52()




CTD_ANON_53._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'mass'), pyxb.binding.datatypes.double, scope=CTD_ANON_53, documentation='\n              The mass of the link.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 13, 8)))

CTD_ANON_53._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'pose'), pose, scope=CTD_ANON_53, documentation='\n              This is the pose of the inertial reference frame, relative to the link reference frame. The origin of the inertial reference frame needs to be at the center of gravity. The axes of the inertial reference frame do not need to be aligned with the principal axes of the inertia.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 22, 8)))

CTD_ANON_53._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'inertia'), CTD_ANON_54, scope=CTD_ANON_53, documentation='\n              The 3x3 rotational inertia matrix. Because the rotational inertia matrix is symmetric, only 6 above-diagonal elements of this matrix are specified here, using the attributes ixx, ixy, ixz, iyy, iyz, izz.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 31, 8)))

def _BuildAutomaton_53 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_53
    del _BuildAutomaton_53
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 12, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 21, 8))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 30, 8))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_53._UseForTag(pyxb.namespace.ExpandedName(None, 'mass')), pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_53._UseForTag(pyxb.namespace.ExpandedName(None, 'pose')), pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 22, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_53._UseForTag(pyxb.namespace.ExpandedName(None, 'inertia')), pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 31, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_53._Automaton = _BuildAutomaton_53()




CTD_ANON_54._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ixx'), pyxb.binding.datatypes.double, scope=CTD_ANON_54, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 40, 14)))

CTD_ANON_54._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ixy'), pyxb.binding.datatypes.double, scope=CTD_ANON_54, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 44, 14)))

CTD_ANON_54._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ixz'), pyxb.binding.datatypes.double, scope=CTD_ANON_54, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 48, 14)))

CTD_ANON_54._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'iyy'), pyxb.binding.datatypes.double, scope=CTD_ANON_54, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 52, 14)))

CTD_ANON_54._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'iyz'), pyxb.binding.datatypes.double, scope=CTD_ANON_54, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 56, 14)))

CTD_ANON_54._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'izz'), pyxb.binding.datatypes.double, scope=CTD_ANON_54, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 60, 14)))

def _BuildAutomaton_54 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_54
    del _BuildAutomaton_54
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_54._UseForTag(pyxb.namespace.ExpandedName(None, 'ixx')), pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 40, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_54._UseForTag(pyxb.namespace.ExpandedName(None, 'ixy')), pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 44, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_54._UseForTag(pyxb.namespace.ExpandedName(None, 'ixz')), pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 48, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_54._UseForTag(pyxb.namespace.ExpandedName(None, 'iyy')), pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 52, 14))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_54._UseForTag(pyxb.namespace.ExpandedName(None, 'iyz')), pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 56, 14))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_54._UseForTag(pyxb.namespace.ExpandedName(None, 'izz')), pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 60, 14))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_54._Automaton = _BuildAutomaton_54()




CTD_ANON_55._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'parent'), pyxb.binding.datatypes.string, scope=CTD_ANON_55, documentation='\n              Name of the parent link\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 14, 8)))

CTD_ANON_55._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'child'), pyxb.binding.datatypes.string, scope=CTD_ANON_55, documentation='\n              Name of the child link\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 23, 8)))

CTD_ANON_55._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'pose'), pose, scope=CTD_ANON_55, documentation='\n              Pose offset from child link frame to joint frame (expressed in child link frame).\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 32, 8)))

CTD_ANON_55._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'gearbox_ratio'), pyxb.binding.datatypes.double, scope=CTD_ANON_55, documentation='\n              Parameter for gearbox joints.  Given theta_1 and theta_2 defined in description for gearbox_reference_body, theta_2 = -gearbox_ratio * theta_1.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 41, 8)))

CTD_ANON_55._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'gearbox_reference_body'), pyxb.binding.datatypes.string, scope=CTD_ANON_55, documentation='\n              Parameter for gearbox joints.  Gearbox ratio is enforced over two joint angles.  First joint angle (theta_1) is the angle from the gearbox_reference_body to the parent link in the direction of the axis element and the second joint angle (theta_2) is the angle from the gearbox_reference_body to the child link in the direction of the axis2 element.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 50, 8)))

CTD_ANON_55._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'thread_pitch'), pyxb.binding.datatypes.double, scope=CTD_ANON_55, documentation='\n              Parameter for screw joints.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 59, 8)))

CTD_ANON_55._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'axis'), CTD_ANON_56, scope=CTD_ANON_55, documentation='\n              \n      Parameters related to the axis of rotation for revolute joints,\n      the axis of translation for prismatic joints.\n    \n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 68, 8)))

CTD_ANON_55._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'axis2'), CTD_ANON_59, scope=CTD_ANON_55, documentation='\n              \n      Parameters related to the second axis of rotation for revolute2 joints and universal joints.\n    \n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 226, 8)))

CTD_ANON_55._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'physics'), CTD_ANON_62, scope=CTD_ANON_55, documentation='\n              Parameters that are specific to a certain physics engine.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 378, 8)))

CTD_ANON_55._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'sensor'), CTD_ANON_111, scope=CTD_ANON_55, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 23, 2)))

def _BuildAutomaton_55 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_55
    del _BuildAutomaton_55
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 31, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 40, 8))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 49, 8))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 58, 8))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 67, 8))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 225, 8))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 377, 8))
    counters.add(cc_6)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_55._UseForTag(pyxb.namespace.ExpandedName(None, 'parent')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 14, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_55._UseForTag(pyxb.namespace.ExpandedName(None, 'child')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 23, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_55._UseForTag(pyxb.namespace.ExpandedName(None, 'pose')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 32, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_55._UseForTag(pyxb.namespace.ExpandedName(None, 'gearbox_ratio')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 41, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_55._UseForTag(pyxb.namespace.ExpandedName(None, 'gearbox_reference_body')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 50, 8))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_55._UseForTag(pyxb.namespace.ExpandedName(None, 'thread_pitch')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 59, 8))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_55._UseForTag(pyxb.namespace.ExpandedName(None, 'axis')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 68, 8))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_55._UseForTag(pyxb.namespace.ExpandedName(None, 'axis2')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 226, 8))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_55._UseForTag(pyxb.namespace.ExpandedName(None, 'physics')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 378, 8))
    st_8 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_55._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'sensor')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 567, 8))
    st_9 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    st_9._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_55._Automaton = _BuildAutomaton_55()




CTD_ANON_56._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'xyz'), vector3, scope=CTD_ANON_56, documentation='\n                    \n        Represents the x,y,z components of the axis unit vector. The axis is\n        expressed in the joint frame unless the use_parent_model_frame\n        flag is set to true. The vector should be normalized.\n      \n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 80, 14)))

CTD_ANON_56._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'use_parent_model_frame'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_56, documentation='\n                    \n        Flag to interpret the axis xyz element in the parent model frame instead\n        of joint frame. Provided for Gazebo compatibility\n        (see https://bitbucket.org/osrf/gazebo/issue/494 ).\n      \n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 93, 14)))

CTD_ANON_56._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'dynamics'), CTD_ANON_57, scope=CTD_ANON_56, documentation='\n                    An element specifying physical properties of the joint. These values are used to specify modeling properties of the joint, particularly useful for simulation.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 106, 14)))

CTD_ANON_56._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'limit'), CTD_ANON_58, scope=CTD_ANON_56, documentation='\n                    specifies the limits of this joint\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 155, 14)))

def _BuildAutomaton_56 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_56
    del _BuildAutomaton_56
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 105, 14))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_56._UseForTag(pyxb.namespace.ExpandedName(None, 'xyz')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 80, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_56._UseForTag(pyxb.namespace.ExpandedName(None, 'use_parent_model_frame')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 93, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_56._UseForTag(pyxb.namespace.ExpandedName(None, 'dynamics')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 106, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_56._UseForTag(pyxb.namespace.ExpandedName(None, 'limit')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 155, 14))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_56._Automaton = _BuildAutomaton_56()




CTD_ANON_57._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'damping'), pyxb.binding.datatypes.double, scope=CTD_ANON_57, documentation='\n                          The physical velocity dependent viscous damping coefficient of the joint.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 115, 20)))

CTD_ANON_57._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'friction'), pyxb.binding.datatypes.double, scope=CTD_ANON_57, documentation='\n                          The physical static friction value of the joint.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 124, 20)))

CTD_ANON_57._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'spring_reference'), pyxb.binding.datatypes.double, scope=CTD_ANON_57, documentation='\n                          The spring reference position for this joint axis.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 133, 20)))

CTD_ANON_57._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'spring_stiffness'), pyxb.binding.datatypes.double, scope=CTD_ANON_57, documentation='\n                          The spring stiffness for this joint axis.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 142, 20)))

def _BuildAutomaton_57 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_57
    del _BuildAutomaton_57
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 114, 20))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 123, 20))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_57._UseForTag(pyxb.namespace.ExpandedName(None, 'damping')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 115, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_57._UseForTag(pyxb.namespace.ExpandedName(None, 'friction')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 124, 20))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_57._UseForTag(pyxb.namespace.ExpandedName(None, 'spring_reference')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 133, 20))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_57._UseForTag(pyxb.namespace.ExpandedName(None, 'spring_stiffness')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 142, 20))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_57._Automaton = _BuildAutomaton_57()




CTD_ANON_58._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'lower'), pyxb.binding.datatypes.double, scope=CTD_ANON_58, documentation='\n                          An attribute specifying the lower joint limit (radians for revolute joints, meters for prismatic joints). Omit if joint is continuous.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 164, 20)))

CTD_ANON_58._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'upper'), pyxb.binding.datatypes.double, scope=CTD_ANON_58, documentation='\n                          An attribute specifying the upper joint limit (radians for revolute joints, meters for prismatic joints). Omit if joint is continuous.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 173, 20)))

CTD_ANON_58._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'effort'), pyxb.binding.datatypes.double, scope=CTD_ANON_58, documentation='\n                          An attribute for enforcing the maximum joint effort applied by Joint::SetForce.  Limit is not enforced if value is negative.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 182, 20)))

CTD_ANON_58._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'velocity'), pyxb.binding.datatypes.double, scope=CTD_ANON_58, documentation='\n                          (not implemented) An attribute for enforcing the maximum joint velocity.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 191, 20)))

CTD_ANON_58._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'stiffness'), pyxb.binding.datatypes.double, scope=CTD_ANON_58, documentation='\n                          Joint stop stiffness. Support physics engines: SimBody.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 200, 20)))

CTD_ANON_58._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'dissipation'), pyxb.binding.datatypes.double, scope=CTD_ANON_58, documentation='\n                          Joint stop dissipation.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 209, 20)))

def _BuildAutomaton_58 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_58
    del _BuildAutomaton_58
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 181, 20))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 190, 20))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 199, 20))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 208, 20))
    counters.add(cc_3)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_58._UseForTag(pyxb.namespace.ExpandedName(None, 'lower')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 164, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_58._UseForTag(pyxb.namespace.ExpandedName(None, 'upper')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 173, 20))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_58._UseForTag(pyxb.namespace.ExpandedName(None, 'effort')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 182, 20))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_58._UseForTag(pyxb.namespace.ExpandedName(None, 'velocity')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 191, 20))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_58._UseForTag(pyxb.namespace.ExpandedName(None, 'stiffness')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 200, 20))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_58._UseForTag(pyxb.namespace.ExpandedName(None, 'dissipation')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 209, 20))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_58._Automaton = _BuildAutomaton_58()




CTD_ANON_59._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'xyz'), vector3, scope=CTD_ANON_59, documentation='\n                    \n        Represents the x,y,z components of the axis unit vector. The axis is\n        expressed in the joint frame unless the use_parent_model_frame\n        flag is set to true. The vector should be normalized.\n      \n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 237, 14)))

CTD_ANON_59._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'use_parent_model_frame'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_59, documentation='\n                    \n        Flag to interpret the axis xyz element in the parent model frame instead\n        of joint frame. Provided for Gazebo compatibility\n        (see https://bitbucket.org/osrf/gazebo/issue/494 ).\n      \n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 250, 14)))

CTD_ANON_59._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'dynamics'), CTD_ANON_60, scope=CTD_ANON_59, documentation='\n                    An element specifying physical properties of the joint. These values are used to specify modeling properties of the joint, particularly useful for simulation.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 263, 14)))

CTD_ANON_59._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'limit'), CTD_ANON_61, scope=CTD_ANON_59, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 312, 14)))

def _BuildAutomaton_59 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_59
    del _BuildAutomaton_59
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 262, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 311, 14))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_59._UseForTag(pyxb.namespace.ExpandedName(None, 'xyz')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 237, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_59._UseForTag(pyxb.namespace.ExpandedName(None, 'use_parent_model_frame')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 250, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_59._UseForTag(pyxb.namespace.ExpandedName(None, 'dynamics')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 263, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_59._UseForTag(pyxb.namespace.ExpandedName(None, 'limit')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 312, 14))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_59._Automaton = _BuildAutomaton_59()




CTD_ANON_60._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'damping'), pyxb.binding.datatypes.double, scope=CTD_ANON_60, documentation='\n                          The physical velocity dependent viscous damping coefficient of the joint.  EXPERIMENTAL: if damping coefficient is negative and implicit_spring_damper is true, adaptive damping is used.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 272, 20)))

CTD_ANON_60._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'friction'), pyxb.binding.datatypes.double, scope=CTD_ANON_60, documentation='\n                          The physical static friction value of the joint.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 281, 20)))

CTD_ANON_60._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'spring_reference'), pyxb.binding.datatypes.double, scope=CTD_ANON_60, documentation='\n                          The spring reference position for this joint axis.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 290, 20)))

CTD_ANON_60._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'spring_stiffness'), pyxb.binding.datatypes.double, scope=CTD_ANON_60, documentation='\n                          The spring stiffness for this joint axis.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 299, 20)))

def _BuildAutomaton_60 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_60
    del _BuildAutomaton_60
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 271, 20))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 280, 20))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_60._UseForTag(pyxb.namespace.ExpandedName(None, 'damping')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 272, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_60._UseForTag(pyxb.namespace.ExpandedName(None, 'friction')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 281, 20))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_60._UseForTag(pyxb.namespace.ExpandedName(None, 'spring_reference')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 290, 20))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_60._UseForTag(pyxb.namespace.ExpandedName(None, 'spring_stiffness')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 299, 20))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_60._Automaton = _BuildAutomaton_60()




CTD_ANON_61._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'lower'), pyxb.binding.datatypes.double, scope=CTD_ANON_61, documentation='\n                          An attribute specifying the lower joint limit (radians for revolute joints, meters for prismatic joints). Omit if joint is continuous.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 316, 20)))

CTD_ANON_61._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'upper'), pyxb.binding.datatypes.double, scope=CTD_ANON_61, documentation='\n                          An attribute specifying the upper joint limit (radians for revolute joints, meters for prismatic joints). Omit if joint is continuous.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 325, 20)))

CTD_ANON_61._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'effort'), pyxb.binding.datatypes.double, scope=CTD_ANON_61, documentation='\n                          An attribute for enforcing the maximum joint effort applied by Joint::SetForce.  Limit is not enforced if value is negative.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 334, 20)))

CTD_ANON_61._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'velocity'), pyxb.binding.datatypes.double, scope=CTD_ANON_61, documentation='\n                          (not implemented) An attribute for enforcing the maximum joint velocity.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 343, 20)))

CTD_ANON_61._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'stiffness'), pyxb.binding.datatypes.double, scope=CTD_ANON_61, documentation='\n                          Joint stop stiffness. Supported physics engines: SimBody.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 352, 20)))

CTD_ANON_61._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'dissipation'), pyxb.binding.datatypes.double, scope=CTD_ANON_61, documentation='\n                          Joint stop dissipation. Supported physics engines: SimBody.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 361, 20)))

def _BuildAutomaton_61 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_61
    del _BuildAutomaton_61
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 315, 20))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 324, 20))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 333, 20))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 342, 20))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 351, 20))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 360, 20))
    counters.add(cc_5)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_61._UseForTag(pyxb.namespace.ExpandedName(None, 'lower')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 316, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_61._UseForTag(pyxb.namespace.ExpandedName(None, 'upper')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 325, 20))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_61._UseForTag(pyxb.namespace.ExpandedName(None, 'effort')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 334, 20))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_61._UseForTag(pyxb.namespace.ExpandedName(None, 'velocity')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 343, 20))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_61._UseForTag(pyxb.namespace.ExpandedName(None, 'stiffness')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 352, 20))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_61._UseForTag(pyxb.namespace.ExpandedName(None, 'dissipation')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 361, 20))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_61._Automaton = _BuildAutomaton_61()




CTD_ANON_62._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'simbody'), CTD_ANON_63, scope=CTD_ANON_62, documentation='\n                    Simbody specific parameters\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 387, 14)))

CTD_ANON_62._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ode'), CTD_ANON_64, scope=CTD_ANON_62, documentation='\n                    ODE specific parameters\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 409, 14)))

CTD_ANON_62._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'provide_feedback'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_62, documentation='\n                    If provide feedback is set to true, physics engine will compute the constraint forces at this joint.  For now, provide_feedback under ode block will override this tag and given user warning about the migration.  provide_feedback under ode is scheduled to be removed in SDF 1.5.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 555, 14)))

def _BuildAutomaton_62 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_62
    del _BuildAutomaton_62
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 386, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 408, 14))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 554, 14))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_62._UseForTag(pyxb.namespace.ExpandedName(None, 'simbody')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 387, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_62._UseForTag(pyxb.namespace.ExpandedName(None, 'ode')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 409, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_62._UseForTag(pyxb.namespace.ExpandedName(None, 'provide_feedback')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 555, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_62._Automaton = _BuildAutomaton_62()




CTD_ANON_63._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'must_be_loop_joint'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_63, documentation='\n                          Force cut in the multibody graph at this joint.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 396, 20)))

def _BuildAutomaton_63 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_63
    del _BuildAutomaton_63
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 395, 20))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_63._UseForTag(pyxb.namespace.ExpandedName(None, 'must_be_loop_joint')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 396, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_63._Automaton = _BuildAutomaton_63()




CTD_ANON_64._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'provide_feedback'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_64, documentation='\n                          (DEPRECATION WARNING:  In SDF 1.5 this tag will be replaced by the same tag directly under the physics-block.  For now, this tag overrides the one outside of ode-block, but in SDF 1.5 this tag will be removed completely.)  If provide feedback is set to true, ODE will compute the constraint forces at this joint.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 418, 20)))

CTD_ANON_64._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'cfm_damping'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_64, documentation='\n                          If cfm damping is set to true, ODE will use CFM to simulate damping, allows for infinite damping, and one additional constraint row (previously used for joint limit) is always active.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 427, 20)))

CTD_ANON_64._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'implicit_spring_damper'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_64, documentation='\n                          If implicit_spring_damper is set to true, ODE will use CFM, ERP to simulate stiffness and damping, allows for infinite damping, and one additional constraint row (previously used for joint limit) is always active.  This replaces cfm_damping parameter in sdf 1.4.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 436, 20)))

CTD_ANON_64._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'fudge_factor'), pyxb.binding.datatypes.double, scope=CTD_ANON_64, documentation='\n                          Scale the excess for in a joint motor at joint limits. Should be between zero and one.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 445, 20)))

CTD_ANON_64._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'cfm'), pyxb.binding.datatypes.double, scope=CTD_ANON_64, documentation='\n                          Constraint force mixing for constrained directions\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 454, 20)))

CTD_ANON_64._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'erp'), pyxb.binding.datatypes.double, scope=CTD_ANON_64, documentation='\n                          Error reduction parameter for constrained directions\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 463, 20)))

CTD_ANON_64._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'bounce'), pyxb.binding.datatypes.double, scope=CTD_ANON_64, documentation='\n                          Bounciness of the limits\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 472, 20)))

CTD_ANON_64._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'max_force'), pyxb.binding.datatypes.double, scope=CTD_ANON_64, documentation='\n                          Maximum force or torque used to reach the desired velocity.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 481, 20)))

CTD_ANON_64._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'velocity'), pyxb.binding.datatypes.double, scope=CTD_ANON_64, documentation='\n                          The desired velocity of the joint. Should only be set if you want the joint to move on load.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 490, 20)))

CTD_ANON_64._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'limit'), CTD_ANON_65, scope=CTD_ANON_64, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 499, 20)))

CTD_ANON_64._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'suspension'), CTD_ANON_66, scope=CTD_ANON_64, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 525, 20)))

def _BuildAutomaton_64 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_64
    del _BuildAutomaton_64
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 417, 20))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 426, 20))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 435, 20))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 444, 20))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 453, 20))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 462, 20))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 471, 20))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 480, 20))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 489, 20))
    counters.add(cc_8)
    cc_9 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 498, 20))
    counters.add(cc_9)
    cc_10 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 524, 20))
    counters.add(cc_10)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_64._UseForTag(pyxb.namespace.ExpandedName(None, 'provide_feedback')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 418, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_64._UseForTag(pyxb.namespace.ExpandedName(None, 'cfm_damping')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 427, 20))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_64._UseForTag(pyxb.namespace.ExpandedName(None, 'implicit_spring_damper')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 436, 20))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_64._UseForTag(pyxb.namespace.ExpandedName(None, 'fudge_factor')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 445, 20))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_64._UseForTag(pyxb.namespace.ExpandedName(None, 'cfm')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 454, 20))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_64._UseForTag(pyxb.namespace.ExpandedName(None, 'erp')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 463, 20))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_64._UseForTag(pyxb.namespace.ExpandedName(None, 'bounce')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 472, 20))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_64._UseForTag(pyxb.namespace.ExpandedName(None, 'max_force')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 481, 20))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_64._UseForTag(pyxb.namespace.ExpandedName(None, 'velocity')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 490, 20))
    st_8 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_9, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_64._UseForTag(pyxb.namespace.ExpandedName(None, 'limit')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 499, 20))
    st_9 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_10, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_64._UseForTag(pyxb.namespace.ExpandedName(None, 'suspension')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 525, 20))
    st_10 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_9, True) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_9, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_9, False) ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_10, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_10, True) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_10, False) ]))
    st_10._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_64._Automaton = _BuildAutomaton_64()




CTD_ANON_65._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'cfm'), pyxb.binding.datatypes.double, scope=CTD_ANON_65, documentation='\n                                Constraint force mixing parameter used by the joint stop\n                              ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 503, 26)))

CTD_ANON_65._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'erp'), pyxb.binding.datatypes.double, scope=CTD_ANON_65, documentation='\n                                Error reduction parameter used by the joint stop\n                              ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 512, 26)))

def _BuildAutomaton_65 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_65
    del _BuildAutomaton_65
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_65._UseForTag(pyxb.namespace.ExpandedName(None, 'cfm')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 503, 26))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_65._UseForTag(pyxb.namespace.ExpandedName(None, 'erp')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 512, 26))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_65._Automaton = _BuildAutomaton_65()




CTD_ANON_66._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'cfm'), pyxb.binding.datatypes.double, scope=CTD_ANON_66, documentation='\n                                Suspension constraint force mixing parameter\n                              ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 529, 26)))

CTD_ANON_66._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'erp'), pyxb.binding.datatypes.double, scope=CTD_ANON_66, documentation='\n                                Suspension error reduction parameter\n                              ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 538, 26)))

def _BuildAutomaton_66 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_66
    del _BuildAutomaton_66
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_66._UseForTag(pyxb.namespace.ExpandedName(None, 'cfm')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 529, 26))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_66._UseForTag(pyxb.namespace.ExpandedName(None, 'erp')), pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 538, 26))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_66._Automaton = _BuildAutomaton_66()




CTD_ANON_67._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'cast_shadows'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_67, documentation='\n              When true, the light will cast shadows.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 13, 8)))

CTD_ANON_67._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'pose'), pose, scope=CTD_ANON_67, documentation='\n              A position and orientation in the global coordinate frame for the light.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 22, 8)))

CTD_ANON_67._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'diffuse'), color, scope=CTD_ANON_67, documentation='\n              Diffuse light color\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 31, 8)))

CTD_ANON_67._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'specular'), color, scope=CTD_ANON_67, documentation='\n              Specular light color\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 40, 8)))

CTD_ANON_67._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'attenuation'), CTD_ANON_68, scope=CTD_ANON_67, documentation='\n              Light attenuation\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 49, 8)))

CTD_ANON_67._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'direction'), vector3, scope=CTD_ANON_67, documentation='\n              Direction of the light, only applicable for spot and directional lights.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 98, 8)))

CTD_ANON_67._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'spot'), CTD_ANON_69, scope=CTD_ANON_67, documentation='\n              Spot light parameters\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 107, 8)))

def _BuildAutomaton_67 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_67
    del _BuildAutomaton_67
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 12, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 21, 8))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 48, 8))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 106, 8))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_67._UseForTag(pyxb.namespace.ExpandedName(None, 'cast_shadows')), pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_67._UseForTag(pyxb.namespace.ExpandedName(None, 'pose')), pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 22, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_67._UseForTag(pyxb.namespace.ExpandedName(None, 'diffuse')), pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 31, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_67._UseForTag(pyxb.namespace.ExpandedName(None, 'specular')), pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 40, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_67._UseForTag(pyxb.namespace.ExpandedName(None, 'attenuation')), pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 49, 8))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_67._UseForTag(pyxb.namespace.ExpandedName(None, 'direction')), pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 98, 8))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_67._UseForTag(pyxb.namespace.ExpandedName(None, 'spot')), pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 107, 8))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_67._Automaton = _BuildAutomaton_67()




CTD_ANON_68._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'range'), pyxb.binding.datatypes.double, scope=CTD_ANON_68, documentation='\n                    Range of the light\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 58, 14)))

CTD_ANON_68._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'linear'), pyxb.binding.datatypes.double, scope=CTD_ANON_68, documentation='\n                    The linear attenuation factor: 1 means attenuate evenly over the distance.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 67, 14)))

CTD_ANON_68._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'constant'), pyxb.binding.datatypes.double, scope=CTD_ANON_68, documentation='\n                    The constant attenuation factor: 1.0 means never attenuate, 0.0 is complete attenutation.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 76, 14)))

CTD_ANON_68._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'quadratic'), pyxb.binding.datatypes.double, scope=CTD_ANON_68, documentation='\n                    The quadratic attenuation factor: adds a curvature to the attenuation.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 85, 14)))

def _BuildAutomaton_68 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_68
    del _BuildAutomaton_68
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 66, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 75, 14))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 84, 14))
    counters.add(cc_2)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_68._UseForTag(pyxb.namespace.ExpandedName(None, 'range')), pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 58, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_68._UseForTag(pyxb.namespace.ExpandedName(None, 'linear')), pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 67, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_68._UseForTag(pyxb.namespace.ExpandedName(None, 'constant')), pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 76, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_68._UseForTag(pyxb.namespace.ExpandedName(None, 'quadratic')), pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 85, 14))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_68._Automaton = _BuildAutomaton_68()




CTD_ANON_69._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'inner_angle'), pyxb.binding.datatypes.double, scope=CTD_ANON_69, documentation='\n                    Angle covered by the bright inner cone\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 116, 14)))

CTD_ANON_69._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'outer_angle'), pyxb.binding.datatypes.double, scope=CTD_ANON_69, documentation='\n                    Angle covered by the outer cone\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 125, 14)))

CTD_ANON_69._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'falloff'), pyxb.binding.datatypes.double, scope=CTD_ANON_69, documentation='\n                    The rate of falloff between the inner and outer cones. 1.0 means a linear falloff, less means slower falloff, higher means faster falloff.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 134, 14)))

def _BuildAutomaton_69 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_69
    del _BuildAutomaton_69
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_69._UseForTag(pyxb.namespace.ExpandedName(None, 'inner_angle')), pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 116, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_69._UseForTag(pyxb.namespace.ExpandedName(None, 'outer_angle')), pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 125, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_69._UseForTag(pyxb.namespace.ExpandedName(None, 'falloff')), pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 134, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_69._Automaton = _BuildAutomaton_69()




CTD_ANON_70._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'audio_sink'), pyxb.binding.datatypes.anyType, scope=CTD_ANON_70, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_sink.xsd', 9, 2)))

CTD_ANON_70._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'audio_source'), CTD_ANON_9, scope=CTD_ANON_70, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/audio_source.xsd', 9, 2)))

CTD_ANON_70._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'collision'), CTD_ANON_19, scope=CTD_ANON_70, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/collision.xsd', 11, 2)))

CTD_ANON_70._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'inertial'), CTD_ANON_53, scope=CTD_ANON_70, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/inertial.xsd', 9, 2)))

CTD_ANON_70._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'gravity'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_70, documentation='\n              If true, the link is affected by gravity.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 20, 8)))

CTD_ANON_70._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'self_collide'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_70, documentation='\n              If true, the link can collide with other links in the model. Two links within a model will collide if link1.self_collide OR link2.self_collide. Links connected by a joint will never collide.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 29, 8)))

CTD_ANON_70._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'kinematic'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_70, documentation='\n              If true, the link is kinematic only\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 38, 8)))

CTD_ANON_70._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'pose'), pose, scope=CTD_ANON_70, documentation='\n              This is the pose of the link reference frame, relative to the model reference frame.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 47, 8)))

CTD_ANON_70._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'must_be_base_link'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_70, documentation='\n              If true, the link will have 6DOF and be a direct child of world.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 56, 8)))

CTD_ANON_70._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'velocity_decay'), CTD_ANON_71, scope=CTD_ANON_70, documentation="\n              Exponential damping of the link's velocity.\n            ", location=pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 65, 8)))

CTD_ANON_70._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'projector'), CTD_ANON_98, scope=CTD_ANON_70, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 5, 2)))

CTD_ANON_70._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'sensor'), CTD_ANON_111, scope=CTD_ANON_70, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 23, 2)))

CTD_ANON_70._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'visual'), CTD_ANON_133, scope=CTD_ANON_70, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 12, 2)))

def _BuildAutomaton_70 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_70
    del _BuildAutomaton_70
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 19, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 28, 8))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 37, 8))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 46, 8))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 55, 8))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 64, 8))
    counters.add(cc_5)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_70._UseForTag(pyxb.namespace.ExpandedName(None, 'gravity')), pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 20, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_70._UseForTag(pyxb.namespace.ExpandedName(None, 'self_collide')), pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 29, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_70._UseForTag(pyxb.namespace.ExpandedName(None, 'kinematic')), pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 38, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_70._UseForTag(pyxb.namespace.ExpandedName(None, 'pose')), pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 47, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_70._UseForTag(pyxb.namespace.ExpandedName(None, 'must_be_base_link')), pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 56, 8))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_70._UseForTag(pyxb.namespace.ExpandedName(None, 'velocity_decay')), pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 65, 8))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_70._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'inertial')), pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 95, 8))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_70._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'collision')), pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 96, 8))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_70._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'visual')), pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 97, 8))
    st_8 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_70._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'sensor')), pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 98, 8))
    st_9 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_70._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'projector')), pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 99, 8))
    st_10 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_70._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'audio_sink')), pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 100, 8))
    st_11 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_70._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'audio_source')), pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 101, 8))
    st_12 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    st_12._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_70._Automaton = _BuildAutomaton_70()




CTD_ANON_71._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'linear'), pyxb.binding.datatypes.double, scope=CTD_ANON_71, documentation='\n                    Linear damping\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 74, 14)))

CTD_ANON_71._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'angular'), pyxb.binding.datatypes.double, scope=CTD_ANON_71, documentation='\n                    Angular damping\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 83, 14)))

def _BuildAutomaton_71 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_71
    del _BuildAutomaton_71
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 73, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 82, 14))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_71._UseForTag(pyxb.namespace.ExpandedName(None, 'linear')), pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 74, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_71._UseForTag(pyxb.namespace.ExpandedName(None, 'angular')), pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 83, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_71._Automaton = _BuildAutomaton_71()




CTD_ANON_72._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'near'), pyxb.binding.datatypes.double, scope=CTD_ANON_72, documentation='\n              Near clipping distance of the view frustum\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/logical_camera.xsd', 13, 8)))

CTD_ANON_72._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'far'), pyxb.binding.datatypes.double, scope=CTD_ANON_72, documentation='\n              Far clipping distance of the view frustum\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/logical_camera.xsd', 22, 8)))

CTD_ANON_72._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'aspect_ratio'), pyxb.binding.datatypes.double, scope=CTD_ANON_72, documentation='\n              Aspect ratio of the near and far planes. This is the width divided by the height of the near or far planes.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/logical_camera.xsd', 31, 8)))

CTD_ANON_72._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'horizontal_fov'), pyxb.binding.datatypes.double, scope=CTD_ANON_72, documentation="\n              Horizontal field of view of the frustum, in radians. This is the angle between the frustum's vertex and the edges of the near or far plane.\n            ", location=pyxb.utils.utility.Location('http://sdformat.org/schemas/logical_camera.xsd', 40, 8)))

def _BuildAutomaton_72 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_72
    del _BuildAutomaton_72
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_72._UseForTag(pyxb.namespace.ExpandedName(None, 'near')), pyxb.utils.utility.Location('http://sdformat.org/schemas/logical_camera.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_72._UseForTag(pyxb.namespace.ExpandedName(None, 'far')), pyxb.utils.utility.Location('http://sdformat.org/schemas/logical_camera.xsd', 22, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_72._UseForTag(pyxb.namespace.ExpandedName(None, 'aspect_ratio')), pyxb.utils.utility.Location('http://sdformat.org/schemas/logical_camera.xsd', 31, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_72._UseForTag(pyxb.namespace.ExpandedName(None, 'horizontal_fov')), pyxb.utils.utility.Location('http://sdformat.org/schemas/logical_camera.xsd', 40, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_72._Automaton = _BuildAutomaton_72()




CTD_ANON_73._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'x'), CTD_ANON_74, scope=CTD_ANON_73, documentation='\n              \n      Parameters related to the body-frame X axis of the magnetometer\n    \n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/magnetometer.xsd', 13, 8)))

CTD_ANON_73._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'y'), CTD_ANON_75, scope=CTD_ANON_73, documentation='\n              \n      Parameters related to the body-frame Y axis of the magnetometer\n    \n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/magnetometer.xsd', 28, 8)))

CTD_ANON_73._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'z'), CTD_ANON_76, scope=CTD_ANON_73, documentation='\n              \n      Parameters related to the body-frame Z axis of the magnetometer\n    \n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/magnetometer.xsd', 43, 8)))

def _BuildAutomaton_73 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_73
    del _BuildAutomaton_73
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/magnetometer.xsd', 12, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/magnetometer.xsd', 27, 8))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/magnetometer.xsd', 42, 8))
    counters.add(cc_2)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_73._UseForTag(pyxb.namespace.ExpandedName(None, 'x')), pyxb.utils.utility.Location('http://sdformat.org/schemas/magnetometer.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_73._UseForTag(pyxb.namespace.ExpandedName(None, 'y')), pyxb.utils.utility.Location('http://sdformat.org/schemas/magnetometer.xsd', 28, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_73._UseForTag(pyxb.namespace.ExpandedName(None, 'z')), pyxb.utils.utility.Location('http://sdformat.org/schemas/magnetometer.xsd', 43, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_73._Automaton = _BuildAutomaton_73()




def _BuildAutomaton_74 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_74
    del _BuildAutomaton_74
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_74._Automaton = _BuildAutomaton_74()




def _BuildAutomaton_75 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_75
    del _BuildAutomaton_75
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_75._Automaton = _BuildAutomaton_75()




def _BuildAutomaton_76 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_76
    del _BuildAutomaton_76
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_76._Automaton = _BuildAutomaton_76()




CTD_ANON_77._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'script'), CTD_ANON_78, scope=CTD_ANON_77, documentation='\n              Name of material from an installed script file. This will override the color element if the script exists.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 13, 8)))

CTD_ANON_77._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'shader'), CTD_ANON_79, scope=CTD_ANON_77, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 44, 8)))

CTD_ANON_77._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'lighting'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_77, documentation='\n              If false, dynamic lighting will be disabled\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 68, 8)))

CTD_ANON_77._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ambient'), color, scope=CTD_ANON_77, documentation='\n              The ambient color of a material specified by set of four numbers representing red/green/blue, each in the range of [0,1].\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 77, 8)))

CTD_ANON_77._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'diffuse'), color, scope=CTD_ANON_77, documentation='\n              The diffuse color of a material specified by set of four numbers representing red/green/blue/alpha, each in the range of [0,1].\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 86, 8)))

CTD_ANON_77._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'specular'), color, scope=CTD_ANON_77, documentation='\n              The specular color of a material specified by set of four numbers representing red/green/blue/alpha, each in the range of [0,1].\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 95, 8)))

CTD_ANON_77._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'emissive'), color, scope=CTD_ANON_77, documentation='\n              The emissive color of a material specified by set of four numbers representing red/green/blue, each in the range of [0,1].\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 104, 8)))

def _BuildAutomaton_77 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_77
    del _BuildAutomaton_77
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 12, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 43, 8))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 67, 8))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 76, 8))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 85, 8))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 94, 8))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 103, 8))
    counters.add(cc_6)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_77._UseForTag(pyxb.namespace.ExpandedName(None, 'script')), pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_77._UseForTag(pyxb.namespace.ExpandedName(None, 'shader')), pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 44, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_77._UseForTag(pyxb.namespace.ExpandedName(None, 'lighting')), pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 68, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_77._UseForTag(pyxb.namespace.ExpandedName(None, 'ambient')), pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 77, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_77._UseForTag(pyxb.namespace.ExpandedName(None, 'diffuse')), pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 86, 8))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_77._UseForTag(pyxb.namespace.ExpandedName(None, 'specular')), pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 95, 8))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_77._UseForTag(pyxb.namespace.ExpandedName(None, 'emissive')), pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 104, 8))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_77._Automaton = _BuildAutomaton_77()




CTD_ANON_78._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'uri'), pyxb.binding.datatypes.string, scope=CTD_ANON_78, documentation='\n                    URI of the material script file\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 22, 14)))

CTD_ANON_78._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'name'), pyxb.binding.datatypes.string, scope=CTD_ANON_78, documentation='\n                    Name of the script within the script file\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 31, 14)))

def _BuildAutomaton_78 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_78
    del _BuildAutomaton_78
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_78._UseForTag(pyxb.namespace.ExpandedName(None, 'uri')), pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 22, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_78._UseForTag(pyxb.namespace.ExpandedName(None, 'name')), pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 31, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_78._Automaton = _BuildAutomaton_78()




CTD_ANON_79._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'normal_map'), pyxb.binding.datatypes.string, scope=CTD_ANON_79, documentation='\n                    filename of the normal map\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 48, 14)))

def _BuildAutomaton_79 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_79
    del _BuildAutomaton_79
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 47, 14))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_79._UseForTag(pyxb.namespace.ExpandedName(None, 'normal_map')), pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 48, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_79._Automaton = _BuildAutomaton_79()




CTD_ANON_80._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'uri'), pyxb.binding.datatypes.string, scope=CTD_ANON_80, documentation='\n              Mesh uri\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/mesh_shape.xsd', 13, 8)))

CTD_ANON_80._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'submesh'), CTD_ANON_81, scope=CTD_ANON_80, documentation='\n              Use a named submesh. The submesh must exist in the mesh specified by the uri\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/mesh_shape.xsd', 22, 8)))

CTD_ANON_80._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'scale'), vector3, scope=CTD_ANON_80, documentation='\n              Scaling factor applied to the mesh\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/mesh_shape.xsd', 53, 8)))

def _BuildAutomaton_80 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_80
    del _BuildAutomaton_80
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/mesh_shape.xsd', 21, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/mesh_shape.xsd', 52, 8))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_80._UseForTag(pyxb.namespace.ExpandedName(None, 'uri')), pyxb.utils.utility.Location('http://sdformat.org/schemas/mesh_shape.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_80._UseForTag(pyxb.namespace.ExpandedName(None, 'submesh')), pyxb.utils.utility.Location('http://sdformat.org/schemas/mesh_shape.xsd', 22, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_80._UseForTag(pyxb.namespace.ExpandedName(None, 'scale')), pyxb.utils.utility.Location('http://sdformat.org/schemas/mesh_shape.xsd', 53, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_80._Automaton = _BuildAutomaton_80()




CTD_ANON_81._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'name'), pyxb.binding.datatypes.string, scope=CTD_ANON_81, documentation='\n                    Name of the submesh within the parent mesh\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/mesh_shape.xsd', 31, 14)))

CTD_ANON_81._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'center'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_81, documentation='\n                    Set to true to center the vertices of the submesh at 0,0,0. This will effectively remove any transformations on the submesh before the poses from parent links and models are applied.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/mesh_shape.xsd', 40, 14)))

def _BuildAutomaton_81 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_81
    del _BuildAutomaton_81
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/mesh_shape.xsd', 39, 14))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_81._UseForTag(pyxb.namespace.ExpandedName(None, 'name')), pyxb.utils.utility.Location('http://sdformat.org/schemas/mesh_shape.xsd', 31, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_81._UseForTag(pyxb.namespace.ExpandedName(None, 'center')), pyxb.utils.utility.Location('http://sdformat.org/schemas/mesh_shape.xsd', 40, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_81._Automaton = _BuildAutomaton_81()




CTD_ANON_82._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'gripper'), CTD_ANON_32, scope=CTD_ANON_82, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gripper.xsd', 4, 2)))

CTD_ANON_82._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'joint'), CTD_ANON_55, scope=CTD_ANON_82, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 10, 2)))

CTD_ANON_82._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'link'), CTD_ANON_70, scope=CTD_ANON_82, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/link.xsd', 16, 2)))

CTD_ANON_82._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'static'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_82, documentation='\n              If set to true, the model is immovable. Otherwise the model is simulated in the dynamics engine.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 17, 8)))

CTD_ANON_82._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'self_collide'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_82, documentation='\n              If set to true, all links in the model will collide with each other (except those connected by a joint). Can be overridden by the link or collision element self_collide property. Two links within a model will collide if link1.self_collide OR link2.self_collide. Links connected by a joint will never collide.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 26, 8)))

CTD_ANON_82._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'allow_auto_disable'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_82, documentation='\n              Allows a model to auto-disable, which is means the physics engine can skip updating the model when the model is at rest. This parameter is only used by models with no joints.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 35, 8)))

CTD_ANON_82._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'pose'), pose, scope=CTD_ANON_82, documentation='\n              A position and orientation in the global coordinate frame for the model. Position(x,y,z) and rotation (roll, pitch yaw) in the global coordinate frame.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 44, 8)))

CTD_ANON_82._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'include'), CTD_ANON_83, scope=CTD_ANON_82, documentation='\n              Include resources from a URI. This can be used to nest models.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 53, 8)))

CTD_ANON_82._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'plugin'), CTD_ANON_94, scope=CTD_ANON_82, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/plugin.xsd', 9, 2)))

def _BuildAutomaton_82 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_82
    del _BuildAutomaton_82
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 16, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 25, 8))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 34, 8))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 43, 8))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 52, 8))
    counters.add(cc_4)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_82._UseForTag(pyxb.namespace.ExpandedName(None, 'static')), pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 17, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_82._UseForTag(pyxb.namespace.ExpandedName(None, 'self_collide')), pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 26, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_82._UseForTag(pyxb.namespace.ExpandedName(None, 'allow_auto_disable')), pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 35, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_82._UseForTag(pyxb.namespace.ExpandedName(None, 'pose')), pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 44, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_82._UseForTag(pyxb.namespace.ExpandedName(None, 'include')), pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 53, 8))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_82._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'link')), pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 101, 8))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_82._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'joint')), pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 102, 8))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_82._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'plugin')), pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 103, 8))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_82._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'gripper')), pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 104, 8))
    st_8 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_8._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_82._Automaton = _BuildAutomaton_82()




CTD_ANON_83._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'uri'), pyxb.binding.datatypes.string, scope=CTD_ANON_83, documentation='\n                    URI to a resource, such as a model\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 62, 14)))

CTD_ANON_83._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'pose'), pose, scope=CTD_ANON_83, documentation='\n                    Override the pose of the included model. A position and orientation in the global coordinate frame for the model. Position(x,y,z) and rotation (roll, pitch yaw) in the global coordinate frame.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 71, 14)))

CTD_ANON_83._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'name'), pyxb.binding.datatypes.string, scope=CTD_ANON_83, documentation='\n                    Override the name of the included model.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 80, 14)))

CTD_ANON_83._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'static'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_83, documentation='\n                    Override the static value of the included model.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 89, 14)))

def _BuildAutomaton_83 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_83
    del _BuildAutomaton_83
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 70, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 79, 14))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 88, 14))
    counters.add(cc_2)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_83._UseForTag(pyxb.namespace.ExpandedName(None, 'uri')), pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 62, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_83._UseForTag(pyxb.namespace.ExpandedName(None, 'pose')), pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 71, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_83._UseForTag(pyxb.namespace.ExpandedName(None, 'name')), pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 80, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_83._UseForTag(pyxb.namespace.ExpandedName(None, 'static')), pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 89, 14))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_83._Automaton = _BuildAutomaton_83()




CTD_ANON_84._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'max_step_size'), pyxb.binding.datatypes.double, scope=CTD_ANON_84, documentation="\n              Maximum time step size at which every system in simulation can interact with the states of the world.  (was physics.sdf's dt).\n            ", location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 13, 8)))

CTD_ANON_84._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'real_time_factor'), pyxb.binding.datatypes.double, scope=CTD_ANON_84, documentation='\n              target simulation speedup factor, defined by ratio of simulation time to real-time.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 22, 8)))

CTD_ANON_84._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'real_time_update_rate'), pyxb.binding.datatypes.double, scope=CTD_ANON_84, documentation="\n              Rate at which to update the physics engine (UpdatePhysics calls per real-time second). (was physics.sdf's update_rate).\n            ", location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 31, 8)))

CTD_ANON_84._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'max_contacts'), pyxb.binding.datatypes.int, scope=CTD_ANON_84, documentation='\n              Maximum number of contacts allowed between two entities. This value can be over ridden by a max_contacts element in a collision element.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 40, 8)))

CTD_ANON_84._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'gravity'), vector3, scope=CTD_ANON_84, documentation='\n              The gravity vector in m/s^2, expressed in a coordinate frame defined by the spherical_coordinates tag.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 49, 8)))

CTD_ANON_84._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'magnetic_field'), vector3, scope=CTD_ANON_84, documentation='\n              The magnetic vector in Tesla, expressed in a coordinate frame defined by the spherical_coordinates tag.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 58, 8)))

CTD_ANON_84._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'simbody'), CTD_ANON_85, scope=CTD_ANON_84, documentation='\n              Simbody specific physics properties\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 67, 8)))

CTD_ANON_84._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'bullet'), CTD_ANON_87, scope=CTD_ANON_84, documentation='\n              Bullet specific physics properties\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 232, 8)))

CTD_ANON_84._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ode'), CTD_ANON_90, scope=CTD_ANON_84, documentation='\n              ODE specific physics properties\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 347, 8)))

def _BuildAutomaton_84 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_84
    del _BuildAutomaton_84
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 39, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 66, 8))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 231, 8))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 346, 8))
    counters.add(cc_3)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_84._UseForTag(pyxb.namespace.ExpandedName(None, 'max_step_size')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_84._UseForTag(pyxb.namespace.ExpandedName(None, 'real_time_factor')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 22, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_84._UseForTag(pyxb.namespace.ExpandedName(None, 'real_time_update_rate')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 31, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_84._UseForTag(pyxb.namespace.ExpandedName(None, 'max_contacts')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 40, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_84._UseForTag(pyxb.namespace.ExpandedName(None, 'gravity')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 49, 8))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_84._UseForTag(pyxb.namespace.ExpandedName(None, 'magnetic_field')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 58, 8))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_84._UseForTag(pyxb.namespace.ExpandedName(None, 'simbody')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 67, 8))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_84._UseForTag(pyxb.namespace.ExpandedName(None, 'bullet')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 232, 8))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_84._UseForTag(pyxb.namespace.ExpandedName(None, 'ode')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 347, 8))
    st_8 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_8._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_84._Automaton = _BuildAutomaton_84()




CTD_ANON_85._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'min_step_size'), pyxb.binding.datatypes.double, scope=CTD_ANON_85, documentation='\n                    (Currently not used in simbody) The time duration which advances with each iteration of the dynamics engine, this has to be no bigger than max_step_size under physics block.  If left unspecified, min_step_size defaults to max_step_size.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 76, 14)))

CTD_ANON_85._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'accuracy'), pyxb.binding.datatypes.double, scope=CTD_ANON_85, documentation='\n                    Roughly the relative error of the system.\n        -LOG(accuracy) is roughly the number of significant digits.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 85, 14)))

CTD_ANON_85._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'max_transient_velocity'), pyxb.binding.datatypes.double, scope=CTD_ANON_85, documentation='\n                    Tolerable "slip" velocity allowed by the solver when static\n        friction is supposed to hold object in place.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 95, 14)))

CTD_ANON_85._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'contact'), CTD_ANON_86, scope=CTD_ANON_85, documentation='\n                    \n        Relationship among dissipation, coef. restitution, etc.\n        d = dissipation coefficient (1/velocity)\n        vc = capture velocity (velocity where e=e_max)\n        vp = plastic velocity (smallest v where e=e_min) > vc\n        Assume real COR=1 when v=0.\n        e_min = given minimum COR, at v >= vp (a.k.a. plastic_coef_restitution)\n        d = slope = (1-e_min)/vp\n        OR, e_min = 1 - d*vp\n        e_max = maximum COR = 1-d*vc, reached at v=vc\n        e = 0,                       v <= vc\n          = 1 - d*v,               vc < v < vp\n          = e_min,                   v >= vp\n  \n        dissipation factor = d*min(v,vp)   [compliant]\n        cor = e                            [rigid]\n  \n        Combining rule e = 0,               e1==e2==0\n                         = 2*e1*e2/(e1+e2), otherwise\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 105, 14)))

def _BuildAutomaton_85 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_85
    del _BuildAutomaton_85
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 75, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 84, 14))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 94, 14))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 104, 14))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_85._UseForTag(pyxb.namespace.ExpandedName(None, 'min_step_size')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 76, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_85._UseForTag(pyxb.namespace.ExpandedName(None, 'accuracy')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 85, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_85._UseForTag(pyxb.namespace.ExpandedName(None, 'max_transient_velocity')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 95, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_85._UseForTag(pyxb.namespace.ExpandedName(None, 'contact')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 105, 14))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_85._Automaton = _BuildAutomaton_85()




CTD_ANON_86._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'stiffness'), pyxb.binding.datatypes.double, scope=CTD_ANON_86, documentation='\n                          Default contact material stiffness\n                     (force/dist or torque/radian).\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 132, 20)))

CTD_ANON_86._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'dissipation'), pyxb.binding.datatypes.double, scope=CTD_ANON_86, documentation='\n                          dissipation coefficient to be used in compliant contact;\n    if not given it is (1-min_cor)/plastic_impact_velocity\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 142, 20)))

CTD_ANON_86._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'plastic_coef_restitution'), pyxb.binding.datatypes.double, scope=CTD_ANON_86, documentation='\n                          this is the COR to be used at high velocities for rigid\n    impacts; if not given it is 1 - dissipation*plastic_impact_velocity\n        \n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 152, 20)))

CTD_ANON_86._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'plastic_impact_velocity'), pyxb.binding.datatypes.double, scope=CTD_ANON_86, documentation='\n                          smallest impact velocity at which min COR is reached; set\n      to zero if you want the min COR always to be used\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 163, 20)))

CTD_ANON_86._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'static_friction'), pyxb.binding.datatypes.double, scope=CTD_ANON_86, documentation='\n                          static friction (mu_s) as described by this plot: http://gazebosim.org/wiki/File:Stribeck_friction.png\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 173, 20)))

CTD_ANON_86._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'dynamic_friction'), pyxb.binding.datatypes.double, scope=CTD_ANON_86, documentation='\n                          dynamic friction (mu_d) as described by this plot: http://gazebosim.org/wiki/File:Stribeck_friction.png\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 182, 20)))

CTD_ANON_86._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'viscous_friction'), pyxb.binding.datatypes.double, scope=CTD_ANON_86, documentation='\n                          viscous friction (mu_v) with units of (1/velocity) as described by this plot: http://gazebosim.org/wiki/File:Stribeck_friction.png\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 191, 20)))

CTD_ANON_86._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'override_impact_capture_velocity'), pyxb.binding.datatypes.double, scope=CTD_ANON_86, documentation='\n                          for rigid impacts only, impact velocity at which\n          COR is set to zero; normally inherited from global default but can\n          be overridden here. Combining rule: use larger velocity\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 200, 20)))

CTD_ANON_86._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'override_stiction_transition_velocity'), pyxb.binding.datatypes.double, scope=CTD_ANON_86, documentation="\n                          This is the largest slip velocity at which\n           we'll consider a transition to stiction. Normally inherited\n           from a global default setting. For a continuous friction model\n           this is the velocity at which the max static friction force\n           is reached.  Combining rule: use larger velocity\n                        ", location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 211, 20)))

def _BuildAutomaton_86 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_86
    del _BuildAutomaton_86
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 131, 20))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 141, 20))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 151, 20))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 162, 20))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 172, 20))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 181, 20))
    counters.add(cc_5)
    cc_6 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 190, 20))
    counters.add(cc_6)
    cc_7 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 199, 20))
    counters.add(cc_7)
    cc_8 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 210, 20))
    counters.add(cc_8)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_86._UseForTag(pyxb.namespace.ExpandedName(None, 'stiffness')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 132, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_86._UseForTag(pyxb.namespace.ExpandedName(None, 'dissipation')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 142, 20))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_86._UseForTag(pyxb.namespace.ExpandedName(None, 'plastic_coef_restitution')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 152, 20))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_86._UseForTag(pyxb.namespace.ExpandedName(None, 'plastic_impact_velocity')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 163, 20))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_86._UseForTag(pyxb.namespace.ExpandedName(None, 'static_friction')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 173, 20))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_86._UseForTag(pyxb.namespace.ExpandedName(None, 'dynamic_friction')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 182, 20))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_6, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_86._UseForTag(pyxb.namespace.ExpandedName(None, 'viscous_friction')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 191, 20))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_7, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_86._UseForTag(pyxb.namespace.ExpandedName(None, 'override_impact_capture_velocity')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 200, 20))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_8, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_86._UseForTag(pyxb.namespace.ExpandedName(None, 'override_stiction_transition_velocity')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 211, 20))
    st_8 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_6, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_6, False) ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_7, True) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_7, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_7, False) ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_8, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_8, True) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_8, False) ]))
    st_8._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_86._Automaton = _BuildAutomaton_86()




CTD_ANON_87._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'solver'), CTD_ANON_88, scope=CTD_ANON_87, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 241, 14)))

CTD_ANON_87._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'constraints'), CTD_ANON_89, scope=CTD_ANON_87, documentation='\n                    Bullet constraint parameters.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 285, 14)))

def _BuildAutomaton_87 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_87
    del _BuildAutomaton_87
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_87._UseForTag(pyxb.namespace.ExpandedName(None, 'solver')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 241, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_87._UseForTag(pyxb.namespace.ExpandedName(None, 'constraints')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 285, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_87._Automaton = _BuildAutomaton_87()




CTD_ANON_88._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'type'), pyxb.binding.datatypes.string, scope=CTD_ANON_88, documentation='\n                          One of the following types: sequential_impulse only.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 245, 20)))

CTD_ANON_88._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'min_step_size'), pyxb.binding.datatypes.double, scope=CTD_ANON_88, documentation='\n                          The time duration which advances with each iteration of the dynamics engine, this has to be no bigger than max_step_size under physics block.  If left unspecified, min_step_size defaults to max_step_size.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 254, 20)))

CTD_ANON_88._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'iters'), pyxb.binding.datatypes.int, scope=CTD_ANON_88, documentation='\n                          Number of iterations for each step. A higher number produces greater accuracy at a performance cost.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 263, 20)))

CTD_ANON_88._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'sor'), pyxb.binding.datatypes.double, scope=CTD_ANON_88, documentation='\n                          Set the successive over-relaxation parameter.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 272, 20)))

def _BuildAutomaton_88 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_88
    del _BuildAutomaton_88
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 253, 20))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_88._UseForTag(pyxb.namespace.ExpandedName(None, 'type')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 245, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_88._UseForTag(pyxb.namespace.ExpandedName(None, 'min_step_size')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 254, 20))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_88._UseForTag(pyxb.namespace.ExpandedName(None, 'iters')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 263, 20))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_88._UseForTag(pyxb.namespace.ExpandedName(None, 'sor')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 272, 20))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_88._Automaton = _BuildAutomaton_88()




CTD_ANON_89._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'cfm'), pyxb.binding.datatypes.double, scope=CTD_ANON_89, documentation='\n                          Constraint force mixing parameter. See the ODE page for more information.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 294, 20)))

CTD_ANON_89._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'erp'), pyxb.binding.datatypes.double, scope=CTD_ANON_89, documentation='\n                          Error reduction parameter. See the ODE page for more information.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 303, 20)))

CTD_ANON_89._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'contact_surface_layer'), pyxb.binding.datatypes.double, scope=CTD_ANON_89, documentation='\n                          The depth of the surface layer around all geometry objects. Contacts are allowed to sink into the surface layer up to the given depth before coming to rest. The default value is zero. Increasing this to some small value (e.g. 0.001) can help prevent jittering problems due to contacts being repeatedly made and broken.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 312, 20)))

CTD_ANON_89._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'split_impulse'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_89, documentation="\n                          Similar to ODE's max_vel implementation. See http://web.archive.org/web/20120430155635/http://bulletphysics.org/mediawiki-1.5.8/index.php/BtContactSolverInfo#Split_Impulse for more information.\n                        ", location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 321, 20)))

CTD_ANON_89._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'split_impulse_penetration_threshold'), pyxb.binding.datatypes.double, scope=CTD_ANON_89, documentation="\n                          Similar to ODE's max_vel implementation.  See http://web.archive.org/web/20120430155635/http://bulletphysics.org/mediawiki-1.5.8/index.php/BtContactSolverInfo#Split_Impulse for more information.\n                        ", location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 330, 20)))

def _BuildAutomaton_89 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_89
    del _BuildAutomaton_89
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_89._UseForTag(pyxb.namespace.ExpandedName(None, 'cfm')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 294, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_89._UseForTag(pyxb.namespace.ExpandedName(None, 'erp')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 303, 20))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_89._UseForTag(pyxb.namespace.ExpandedName(None, 'contact_surface_layer')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 312, 20))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_89._UseForTag(pyxb.namespace.ExpandedName(None, 'split_impulse')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 321, 20))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_89._UseForTag(pyxb.namespace.ExpandedName(None, 'split_impulse_penetration_threshold')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 330, 20))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_89._Automaton = _BuildAutomaton_89()




CTD_ANON_90._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'solver'), CTD_ANON_91, scope=CTD_ANON_90, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 356, 14)))

CTD_ANON_90._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'constraints'), CTD_ANON_92, scope=CTD_ANON_90, documentation='\n                    ODE constraint parameters.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 422, 14)))

def _BuildAutomaton_90 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_90
    del _BuildAutomaton_90
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_90._UseForTag(pyxb.namespace.ExpandedName(None, 'solver')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 356, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_90._UseForTag(pyxb.namespace.ExpandedName(None, 'constraints')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 422, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_90._Automaton = _BuildAutomaton_90()




CTD_ANON_91._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'type'), pyxb.binding.datatypes.string, scope=CTD_ANON_91, documentation='\n                          One of the following types: world, quick\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 360, 20)))

CTD_ANON_91._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'min_step_size'), pyxb.binding.datatypes.double, scope=CTD_ANON_91, documentation='\n                          The time duration which advances with each iteration of the dynamics engine, this has to be no bigger than max_step_size under physics block.  If left unspecified, min_step_size defaults to max_step_size.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 369, 20)))

CTD_ANON_91._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'iters'), pyxb.binding.datatypes.int, scope=CTD_ANON_91, documentation='\n                          Number of iterations for each step. A higher number produces greater accuracy at a performance cost.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 378, 20)))

CTD_ANON_91._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'precon_iters'), pyxb.binding.datatypes.int, scope=CTD_ANON_91, documentation='\n                          Experimental parameter.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 387, 20)))

CTD_ANON_91._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'sor'), pyxb.binding.datatypes.double, scope=CTD_ANON_91, documentation='\n                          Set the successive over-relaxation parameter.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 396, 20)))

CTD_ANON_91._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'use_dynamic_moi_rescaling'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_91, documentation='\n                          \n          Flag to enable dynamic rescaling of moment of inertia in constrained directions.\n          See gazebo pull request 1114 for the implementation of this feature.\n          https://bitbucket.org/osrf/gazebo/pull-request/1114\n        \n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 405, 20)))

def _BuildAutomaton_91 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_91
    del _BuildAutomaton_91
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 368, 20))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 386, 20))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_91._UseForTag(pyxb.namespace.ExpandedName(None, 'type')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 360, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_91._UseForTag(pyxb.namespace.ExpandedName(None, 'min_step_size')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 369, 20))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_91._UseForTag(pyxb.namespace.ExpandedName(None, 'iters')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 378, 20))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_91._UseForTag(pyxb.namespace.ExpandedName(None, 'precon_iters')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 387, 20))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_91._UseForTag(pyxb.namespace.ExpandedName(None, 'sor')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 396, 20))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_91._UseForTag(pyxb.namespace.ExpandedName(None, 'use_dynamic_moi_rescaling')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 405, 20))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_91._Automaton = _BuildAutomaton_91()




CTD_ANON_92._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'cfm'), pyxb.binding.datatypes.double, scope=CTD_ANON_92, documentation='\n                          Constraint force mixing parameter. See the ODE page for more information.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 431, 20)))

CTD_ANON_92._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'erp'), pyxb.binding.datatypes.double, scope=CTD_ANON_92, documentation='\n                          Error reduction parameter. See the ODE page for more information.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 440, 20)))

CTD_ANON_92._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'contact_max_correcting_vel'), pyxb.binding.datatypes.double, scope=CTD_ANON_92, documentation='\n                          The maximum correcting velocities allowed when resolving contacts.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 449, 20)))

CTD_ANON_92._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'contact_surface_layer'), pyxb.binding.datatypes.double, scope=CTD_ANON_92, documentation='\n                          The depth of the surface layer around all geometry objects. Contacts are allowed to sink into the surface layer up to the given depth before coming to rest. The default value is zero. Increasing this to some small value (e.g. 0.001) can help prevent jittering problems due to contacts being repeatedly made and broken.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 458, 20)))

def _BuildAutomaton_92 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_92
    del _BuildAutomaton_92
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_92._UseForTag(pyxb.namespace.ExpandedName(None, 'cfm')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 431, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_92._UseForTag(pyxb.namespace.ExpandedName(None, 'erp')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 440, 20))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_92._UseForTag(pyxb.namespace.ExpandedName(None, 'contact_max_correcting_vel')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 449, 20))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_92._UseForTag(pyxb.namespace.ExpandedName(None, 'contact_surface_layer')), pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 458, 20))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_92._Automaton = _BuildAutomaton_92()




CTD_ANON_93._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'normal'), vector3, scope=CTD_ANON_93, documentation='\n              Normal direction for the plane\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/plane_shape.xsd', 13, 8)))

CTD_ANON_93._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'size'), vector2d, scope=CTD_ANON_93, documentation='\n              Length of each side of the plane\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/plane_shape.xsd', 22, 8)))

def _BuildAutomaton_93 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_93
    del _BuildAutomaton_93
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_93._UseForTag(pyxb.namespace.ExpandedName(None, 'normal')), pyxb.utils.utility.Location('http://sdformat.org/schemas/plane_shape.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_93._UseForTag(pyxb.namespace.ExpandedName(None, 'size')), pyxb.utils.utility.Location('http://sdformat.org/schemas/plane_shape.xsd', 22, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_93._Automaton = _BuildAutomaton_93()




def _BuildAutomaton_94 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_94
    del _BuildAutomaton_94
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/plugin.xsd', 12, 8))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.WildcardUse(pyxb.binding.content.Wildcard(process_contents=pyxb.binding.content.Wildcard.PC_lax, namespace_constraint=pyxb.binding.content.Wildcard.NC_any), pyxb.utils.utility.Location('http://sdformat.org/schemas/plugin.xsd', 12, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_94._Automaton = _BuildAutomaton_94()




CTD_ANON_95._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'point'), vector2d, scope=CTD_ANON_95, documentation='\n              \n      A series of points that define the path of the polyline.\n    \n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/polyline_shape.xsd', 13, 8)))

CTD_ANON_95._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'height'), pyxb.binding.datatypes.double, scope=CTD_ANON_95, documentation='\n              Height of the polyline\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/polyline_shape.xsd', 24, 8)))

def _BuildAutomaton_95 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_95
    del _BuildAutomaton_95
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_95._UseForTag(pyxb.namespace.ExpandedName(None, 'point')), pyxb.utils.utility.Location('http://sdformat.org/schemas/polyline_shape.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_95._UseForTag(pyxb.namespace.ExpandedName(None, 'height')), pyxb.utils.utility.Location('http://sdformat.org/schemas/polyline_shape.xsd', 24, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_95._Automaton = _BuildAutomaton_95()




CTD_ANON_96._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'box'), CTD_ANON_11, scope=CTD_ANON_96, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/box_shape.xsd', 9, 2)))

CTD_ANON_96._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'cylinder'), CTD_ANON_21, scope=CTD_ANON_96, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/cylinder_shape.xsd', 9, 2)))

CTD_ANON_96._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'model'), CTD_ANON_82, scope=CTD_ANON_96, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 13, 2)))

CTD_ANON_96._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'pose'), pose, scope=CTD_ANON_96, documentation="\n              The reference frame of the population's region.\n            ", location=pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 19, 8)))

CTD_ANON_96._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'model_count'), pyxb.binding.datatypes.int, scope=CTD_ANON_96, documentation='\n              The number of models to place.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 28, 8)))

CTD_ANON_96._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'distribution'), CTD_ANON_97, scope=CTD_ANON_96, documentation='\n              \n      Specifies the type of object distribution and its optional parameters.\n    \n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 37, 8)))

def _BuildAutomaton_96 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_96
    del _BuildAutomaton_96
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 18, 8))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_96._UseForTag(pyxb.namespace.ExpandedName(None, 'pose')), pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 19, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_96._UseForTag(pyxb.namespace.ExpandedName(None, 'model_count')), pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 28, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_96._UseForTag(pyxb.namespace.ExpandedName(None, 'distribution')), pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 37, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_96._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'box')), pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 98, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_96._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'cylinder')), pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 99, 8))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_96._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'model')), pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 100, 8))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_96._Automaton = _BuildAutomaton_96()




CTD_ANON_97._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'type'), pyxb.binding.datatypes.string, scope=CTD_ANON_97, documentation='\n                    \n        Define how the objects will be placed in the specified region.\n        - random: Models placed at random.\n        - uniform: Models approximately placed in a 2D grid pattern with control\n            over the number of objects.\n        - grid: Models evenly placed in a 2D grid pattern. The number of objects\n            is not explicitly specified, it is based on the number of rows and\n            columns of the grid.\n        - linear-x: Models evently placed in a row along the global x-axis.\n        - linear-y: Models evently placed in a row along the global y-axis.\n        - linear-z: Models evently placed in a row along the global z-axis.\n      \n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 48, 14)))

CTD_ANON_97._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'rows'), pyxb.binding.datatypes.int, scope=CTD_ANON_97, documentation='\n                    Number of rows in the grid.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 68, 14)))

CTD_ANON_97._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'cols'), pyxb.binding.datatypes.int, scope=CTD_ANON_97, documentation='\n                    Number of columns in the grid.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 77, 14)))

CTD_ANON_97._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'step'), vector3, scope=CTD_ANON_97, documentation='\n                    Distance between elements of the grid.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 86, 14)))

def _BuildAutomaton_97 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_97
    del _BuildAutomaton_97
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 67, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 76, 14))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 85, 14))
    counters.add(cc_2)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_97._UseForTag(pyxb.namespace.ExpandedName(None, 'type')), pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 48, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_97._UseForTag(pyxb.namespace.ExpandedName(None, 'rows')), pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 68, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_97._UseForTag(pyxb.namespace.ExpandedName(None, 'cols')), pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 77, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_97._UseForTag(pyxb.namespace.ExpandedName(None, 'step')), pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 86, 14))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_97._Automaton = _BuildAutomaton_97()




CTD_ANON_98._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'plugin'), CTD_ANON_94, scope=CTD_ANON_98, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/plugin.xsd', 9, 2)))

CTD_ANON_98._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'texture'), pyxb.binding.datatypes.string, scope=CTD_ANON_98, documentation='\n              Texture name\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 9, 8)))

CTD_ANON_98._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'pose'), pose, scope=CTD_ANON_98, documentation='\n              Pose of the projector\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 18, 8)))

CTD_ANON_98._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'fov'), pyxb.binding.datatypes.double, scope=CTD_ANON_98, documentation='\n              Field of view\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 27, 8)))

CTD_ANON_98._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'near_clip'), pyxb.binding.datatypes.double, scope=CTD_ANON_98, documentation='\n              Near clip distance\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 36, 8)))

CTD_ANON_98._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'far_clip'), pyxb.binding.datatypes.double, scope=CTD_ANON_98, documentation='\n              far clip distance\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 45, 8)))

def _BuildAutomaton_98 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_98
    del _BuildAutomaton_98
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 17, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 26, 8))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 35, 8))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 44, 8))
    counters.add(cc_3)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_98._UseForTag(pyxb.namespace.ExpandedName(None, 'texture')), pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 9, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_98._UseForTag(pyxb.namespace.ExpandedName(None, 'pose')), pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 18, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_98._UseForTag(pyxb.namespace.ExpandedName(None, 'fov')), pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 27, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_98._UseForTag(pyxb.namespace.ExpandedName(None, 'near_clip')), pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 36, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_98._UseForTag(pyxb.namespace.ExpandedName(None, 'far_clip')), pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 45, 8))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_98._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'plugin')), pyxb.utils.utility.Location('http://sdformat.org/schemas/projector.xsd', 53, 8))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_98._Automaton = _BuildAutomaton_98()




CTD_ANON_99._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'scan'), CTD_ANON_100, scope=CTD_ANON_99, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 13, 8)))

CTD_ANON_99._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'range'), CTD_ANON_103, scope=CTD_ANON_99, documentation='\n              specifies range properties of each simulated ray\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 99, 8)))

CTD_ANON_99._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'noise'), CTD_ANON_104, scope=CTD_ANON_99, documentation='\n              The properties of the noise model that should be applied to generated scans\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 139, 8)))

def _BuildAutomaton_99 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_99
    del _BuildAutomaton_99
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 138, 8))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_99._UseForTag(pyxb.namespace.ExpandedName(None, 'scan')), pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_99._UseForTag(pyxb.namespace.ExpandedName(None, 'range')), pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 99, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_99._UseForTag(pyxb.namespace.ExpandedName(None, 'noise')), pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 139, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_99._Automaton = _BuildAutomaton_99()




CTD_ANON_100._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'horizontal'), CTD_ANON_101, scope=CTD_ANON_100, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 17, 14)))

CTD_ANON_100._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'vertical'), CTD_ANON_102, scope=CTD_ANON_100, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 56, 14)))

def _BuildAutomaton_100 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_100
    del _BuildAutomaton_100
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 55, 14))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_100._UseForTag(pyxb.namespace.ExpandedName(None, 'horizontal')), pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 17, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_100._UseForTag(pyxb.namespace.ExpandedName(None, 'vertical')), pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 56, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_100._Automaton = _BuildAutomaton_100()




CTD_ANON_101._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'samples'), pyxb.binding.datatypes.unsignedInt, scope=CTD_ANON_101, documentation='\n                          The number of simulated rays to generate per complete laser sweep cycle.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 21, 20)))

CTD_ANON_101._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'resolution'), pyxb.binding.datatypes.double, scope=CTD_ANON_101, documentation='\n                          This number is multiplied by samples to determine the number of range data points returned. If resolution is less than one, range data is interpolated. If resolution is greater than one, range data is averaged.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 30, 20)))

CTD_ANON_101._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'min_angle'), pyxb.binding.datatypes.double, scope=CTD_ANON_101, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 39, 20)))

CTD_ANON_101._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'max_angle'), pyxb.binding.datatypes.double, scope=CTD_ANON_101, documentation='\n                          Must be greater or equal to min_angle\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 43, 20)))

def _BuildAutomaton_101 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_101
    del _BuildAutomaton_101
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_101._UseForTag(pyxb.namespace.ExpandedName(None, 'samples')), pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 21, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_101._UseForTag(pyxb.namespace.ExpandedName(None, 'resolution')), pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 30, 20))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_101._UseForTag(pyxb.namespace.ExpandedName(None, 'min_angle')), pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 39, 20))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_101._UseForTag(pyxb.namespace.ExpandedName(None, 'max_angle')), pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 43, 20))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_101._Automaton = _BuildAutomaton_101()




CTD_ANON_102._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'samples'), pyxb.binding.datatypes.unsignedInt, scope=CTD_ANON_102, documentation='\n                          The number of simulated rays to generate per complete laser sweep cycle.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 60, 20)))

CTD_ANON_102._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'resolution'), pyxb.binding.datatypes.double, scope=CTD_ANON_102, documentation='\n                          This number is multiplied by samples to determine the number of range data points returned. If resolution is less than one, range data is interpolated. If resolution is greater than one, range data is averaged.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 69, 20)))

CTD_ANON_102._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'min_angle'), pyxb.binding.datatypes.double, scope=CTD_ANON_102, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 78, 20)))

CTD_ANON_102._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'max_angle'), pyxb.binding.datatypes.double, scope=CTD_ANON_102, documentation='\n                          Must be greater or equal to min_angle\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 82, 20)))

def _BuildAutomaton_102 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_102
    del _BuildAutomaton_102
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 68, 20))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_102._UseForTag(pyxb.namespace.ExpandedName(None, 'samples')), pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 60, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_102._UseForTag(pyxb.namespace.ExpandedName(None, 'resolution')), pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 69, 20))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_102._UseForTag(pyxb.namespace.ExpandedName(None, 'min_angle')), pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 78, 20))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_102._UseForTag(pyxb.namespace.ExpandedName(None, 'max_angle')), pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 82, 20))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_102._Automaton = _BuildAutomaton_102()




CTD_ANON_103._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'min'), pyxb.binding.datatypes.double, scope=CTD_ANON_103, documentation='\n                    The minimum distance for each ray.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 108, 14)))

CTD_ANON_103._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'max'), pyxb.binding.datatypes.double, scope=CTD_ANON_103, documentation='\n                    The maximum distance for each ray.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 117, 14)))

CTD_ANON_103._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'resolution'), pyxb.binding.datatypes.double, scope=CTD_ANON_103, documentation='\n                    Linear resolution of each ray.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 126, 14)))

def _BuildAutomaton_103 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_103
    del _BuildAutomaton_103
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 125, 14))
    counters.add(cc_0)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_103._UseForTag(pyxb.namespace.ExpandedName(None, 'min')), pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 108, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_103._UseForTag(pyxb.namespace.ExpandedName(None, 'max')), pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 117, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_103._UseForTag(pyxb.namespace.ExpandedName(None, 'resolution')), pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 126, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_103._Automaton = _BuildAutomaton_103()




CTD_ANON_104._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'type'), pyxb.binding.datatypes.string, scope=CTD_ANON_104, documentation='\n                    The type of noise.  Currently supported types are: "gaussian" (draw noise values independently for each beam from a Gaussian distribution).\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 148, 14)))

CTD_ANON_104._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'mean'), pyxb.binding.datatypes.double, scope=CTD_ANON_104, documentation='\n                    For type "gaussian," the mean of the Gaussian distribution from which noise values are drawn.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 157, 14)))

CTD_ANON_104._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'stddev'), pyxb.binding.datatypes.double, scope=CTD_ANON_104, documentation='\n                    For type "gaussian," the standard deviation of the Gaussian distribution from which noise values are drawn.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 166, 14)))

def _BuildAutomaton_104 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_104
    del _BuildAutomaton_104
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 156, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 165, 14))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_104._UseForTag(pyxb.namespace.ExpandedName(None, 'type')), pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 148, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_104._UseForTag(pyxb.namespace.ExpandedName(None, 'mean')), pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 157, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_104._UseForTag(pyxb.namespace.ExpandedName(None, 'stddev')), pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 166, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_104._Automaton = _BuildAutomaton_104()




CTD_ANON_105._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'material'), CTD_ANON_77, scope=CTD_ANON_105, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 9, 2)))

CTD_ANON_105._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'width'), pyxb.binding.datatypes.double, scope=CTD_ANON_105, documentation='\n              Width of the road\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/road.xsd', 9, 8)))

CTD_ANON_105._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'point'), vector3, scope=CTD_ANON_105, documentation='\n              A series of points that define the path of the road.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/road.xsd', 18, 8)))

def _BuildAutomaton_105 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_105
    del _BuildAutomaton_105
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_105._UseForTag(pyxb.namespace.ExpandedName(None, 'width')), pyxb.utils.utility.Location('http://sdformat.org/schemas/road.xsd', 9, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_105._UseForTag(pyxb.namespace.ExpandedName(None, 'point')), pyxb.utils.utility.Location('http://sdformat.org/schemas/road.xsd', 18, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_105._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'material')), pyxb.utils.utility.Location('http://sdformat.org/schemas/road.xsd', 26, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_105._Automaton = _BuildAutomaton_105()




CTD_ANON_106._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'actor'), CTD_ANON, scope=CTD_ANON_106, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 7, 2)))

CTD_ANON_106._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'light'), CTD_ANON_67, scope=CTD_ANON_106, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 9, 2)))

CTD_ANON_106._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'model'), CTD_ANON_82, scope=CTD_ANON_106, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 13, 2)))

CTD_ANON_106._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'world'), CTD_ANON_135, scope=CTD_ANON_106, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 21, 2)))

def _BuildAutomaton_106 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_106
    del _BuildAutomaton_106
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_106._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'world')), pyxb.utils.utility.Location('http://sdformat.org/schemas/root.xsd', 16, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_106._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'model')), pyxb.utils.utility.Location('http://sdformat.org/schemas/root.xsd', 17, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_106._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'actor')), pyxb.utils.utility.Location('http://sdformat.org/schemas/root.xsd', 18, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_106._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'light')), pyxb.utils.utility.Location('http://sdformat.org/schemas/root.xsd', 19, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_106._Automaton = _BuildAutomaton_106()




CTD_ANON_107._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ambient'), color, scope=CTD_ANON_107, documentation='\n              Color of the ambient light.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 13, 8)))

CTD_ANON_107._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'background'), color, scope=CTD_ANON_107, documentation='\n              Color of the background.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 22, 8)))

CTD_ANON_107._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'sky'), CTD_ANON_108, scope=CTD_ANON_107, documentation='\n              Properties for the sky\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 31, 8)))

CTD_ANON_107._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'shadows'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_107, documentation='\n              Enable/disable shadows\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 129, 8)))

CTD_ANON_107._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'fog'), CTD_ANON_110, scope=CTD_ANON_107, documentation='\n              Controls fog\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 138, 8)))

CTD_ANON_107._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'grid'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_107, documentation='\n              Enable/disable the grid\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 196, 8)))

CTD_ANON_107._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'origin_visual'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_107, documentation='\n              Show/hide world origin indicator\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 205, 8)))

def _BuildAutomaton_107 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_107
    del _BuildAutomaton_107
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 30, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 137, 8))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 195, 8))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 204, 8))
    counters.add(cc_3)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_107._UseForTag(pyxb.namespace.ExpandedName(None, 'ambient')), pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_107._UseForTag(pyxb.namespace.ExpandedName(None, 'background')), pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 22, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_107._UseForTag(pyxb.namespace.ExpandedName(None, 'sky')), pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 31, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_107._UseForTag(pyxb.namespace.ExpandedName(None, 'shadows')), pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 129, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_107._UseForTag(pyxb.namespace.ExpandedName(None, 'fog')), pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 138, 8))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_107._UseForTag(pyxb.namespace.ExpandedName(None, 'grid')), pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 196, 8))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_107._UseForTag(pyxb.namespace.ExpandedName(None, 'origin_visual')), pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 205, 8))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_107._Automaton = _BuildAutomaton_107()




CTD_ANON_108._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'time'), pyxb.binding.datatypes.double, scope=CTD_ANON_108, documentation='\n                    Time of day [0..24]\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 40, 14)))

CTD_ANON_108._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'sunrise'), pyxb.binding.datatypes.double, scope=CTD_ANON_108, documentation='\n                    Sunrise time [0..24]\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 49, 14)))

CTD_ANON_108._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'sunset'), pyxb.binding.datatypes.double, scope=CTD_ANON_108, documentation='\n                    Sunset time [0..24]\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 58, 14)))

CTD_ANON_108._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'clouds'), CTD_ANON_109, scope=CTD_ANON_108, documentation='\n                    Sunset time [0..24]\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 67, 14)))

def _BuildAutomaton_108 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_108
    del _BuildAutomaton_108
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 39, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 48, 14))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 57, 14))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 66, 14))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_108._UseForTag(pyxb.namespace.ExpandedName(None, 'time')), pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 40, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_108._UseForTag(pyxb.namespace.ExpandedName(None, 'sunrise')), pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 49, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_108._UseForTag(pyxb.namespace.ExpandedName(None, 'sunset')), pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 58, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_108._UseForTag(pyxb.namespace.ExpandedName(None, 'clouds')), pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 67, 14))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_108._Automaton = _BuildAutomaton_108()




CTD_ANON_109._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'speed'), pyxb.binding.datatypes.double, scope=CTD_ANON_109, documentation='\n                          Speed of the clouds\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 76, 20)))

CTD_ANON_109._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'direction'), pyxb.binding.datatypes.double, scope=CTD_ANON_109, documentation='\n                          Direction of the cloud movement\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 85, 20)))

CTD_ANON_109._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'humidity'), pyxb.binding.datatypes.double, scope=CTD_ANON_109, documentation='\n                          Density of clouds\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 94, 20)))

CTD_ANON_109._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'mean_size'), pyxb.binding.datatypes.double, scope=CTD_ANON_109, documentation='\n                          Average size of the clouds\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 103, 20)))

CTD_ANON_109._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ambient'), color, scope=CTD_ANON_109, documentation='\n                          Ambient cloud color\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 112, 20)))

def _BuildAutomaton_109 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_109
    del _BuildAutomaton_109
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 75, 20))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 84, 20))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 93, 20))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 102, 20))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 111, 20))
    counters.add(cc_4)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_109._UseForTag(pyxb.namespace.ExpandedName(None, 'speed')), pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 76, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_109._UseForTag(pyxb.namespace.ExpandedName(None, 'direction')), pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 85, 20))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_109._UseForTag(pyxb.namespace.ExpandedName(None, 'humidity')), pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 94, 20))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_109._UseForTag(pyxb.namespace.ExpandedName(None, 'mean_size')), pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 103, 20))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_109._UseForTag(pyxb.namespace.ExpandedName(None, 'ambient')), pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 112, 20))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_109._Automaton = _BuildAutomaton_109()




CTD_ANON_110._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'color'), color, scope=CTD_ANON_110, documentation='\n                    Fog color\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 147, 14)))

CTD_ANON_110._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'type'), pyxb.binding.datatypes.string, scope=CTD_ANON_110, documentation='\n                    Fog type: constant, linear, quadratic\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 156, 14)))

CTD_ANON_110._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'start'), pyxb.binding.datatypes.double, scope=CTD_ANON_110, documentation='\n                    Distance to start of fog\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 165, 14)))

CTD_ANON_110._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'end'), pyxb.binding.datatypes.double, scope=CTD_ANON_110, documentation='\n                    Distance to end of fog\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 174, 14)))

CTD_ANON_110._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'density'), pyxb.binding.datatypes.double, scope=CTD_ANON_110, documentation='\n                    Density of fog\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 183, 14)))

def _BuildAutomaton_110 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_110
    del _BuildAutomaton_110
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 146, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 155, 14))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 164, 14))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 173, 14))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 182, 14))
    counters.add(cc_4)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_110._UseForTag(pyxb.namespace.ExpandedName(None, 'color')), pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 147, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_110._UseForTag(pyxb.namespace.ExpandedName(None, 'type')), pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 156, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_110._UseForTag(pyxb.namespace.ExpandedName(None, 'start')), pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 165, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_110._UseForTag(pyxb.namespace.ExpandedName(None, 'end')), pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 174, 14))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_110._UseForTag(pyxb.namespace.ExpandedName(None, 'density')), pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 183, 14))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_110._Automaton = _BuildAutomaton_110()




CTD_ANON_111._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'altimeter'), CTD_ANON_6, scope=CTD_ANON_111, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/altimeter.xsd', 9, 2)))

CTD_ANON_111._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'camera'), CTD_ANON_12, scope=CTD_ANON_111, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/camera.xsd', 9, 2)))

CTD_ANON_111._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'contact'), CTD_ANON_20, scope=CTD_ANON_111, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/contact.xsd', 9, 2)))

CTD_ANON_111._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'force_torque'), CTD_ANON_22, scope=CTD_ANON_111, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/forcetorque.xsd', 9, 2)))

CTD_ANON_111._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'gps'), CTD_ANON_25, scope=CTD_ANON_111, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gps.xsd', 9, 2)))

CTD_ANON_111._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'imu'), CTD_ANON_41, scope=CTD_ANON_111, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/imu.xsd', 9, 2)))

CTD_ANON_111._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'logical_camera'), CTD_ANON_72, scope=CTD_ANON_111, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/logical_camera.xsd', 9, 2)))

CTD_ANON_111._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'magnetometer'), CTD_ANON_73, scope=CTD_ANON_111, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/magnetometer.xsd', 9, 2)))

CTD_ANON_111._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'plugin'), CTD_ANON_94, scope=CTD_ANON_111, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/plugin.xsd', 9, 2)))

CTD_ANON_111._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'ray'), CTD_ANON_99, scope=CTD_ANON_111, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/ray.xsd', 9, 2)))

CTD_ANON_111._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'rfidtag'), pyxb.binding.datatypes.anyType, scope=CTD_ANON_111, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/rfid.xsd', 4, 2)))

CTD_ANON_111._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'rfid'), pyxb.binding.datatypes.anyType, scope=CTD_ANON_111, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/rfidtag.xsd', 4, 2)))

CTD_ANON_111._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'always_on'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_111, documentation='\n              If true the sensor will always be updated according to the update rate.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 27, 8)))

CTD_ANON_111._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'update_rate'), pyxb.binding.datatypes.double, scope=CTD_ANON_111, documentation='\n              The frequency at which the sensor data is generated. If left unspecified, the sensor will generate data every cycle.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 36, 8)))

CTD_ANON_111._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'visualize'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_111, documentation='\n              If true, the sensor is visualized in the GUI\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 45, 8)))

CTD_ANON_111._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'pose'), pose, scope=CTD_ANON_111, documentation='\n              This is the pose of the sensor, relative to the parent (link or joint) reference frame.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 54, 8)))

CTD_ANON_111._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'topic'), pyxb.binding.datatypes.string, scope=CTD_ANON_111, documentation='\n              Name of the topic on which data is published. This is necessary for visualization\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 63, 8)))

CTD_ANON_111._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'sonar'), CTD_ANON_112, scope=CTD_ANON_111, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/sonar.xsd', 9, 2)))

CTD_ANON_111._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'transceiver'), CTD_ANON_132, scope=CTD_ANON_111, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 9, 2)))

def _BuildAutomaton_111 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_111
    del _BuildAutomaton_111
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 26, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 35, 8))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 44, 8))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 53, 8))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 62, 8))
    counters.add(cc_4)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_111._UseForTag(pyxb.namespace.ExpandedName(None, 'always_on')), pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 27, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_111._UseForTag(pyxb.namespace.ExpandedName(None, 'update_rate')), pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 36, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_111._UseForTag(pyxb.namespace.ExpandedName(None, 'visualize')), pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 45, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_111._UseForTag(pyxb.namespace.ExpandedName(None, 'pose')), pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 54, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_111._UseForTag(pyxb.namespace.ExpandedName(None, 'topic')), pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 63, 8))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_111._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'plugin')), pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 71, 8))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_111._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'altimeter')), pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 72, 8))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_111._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'camera')), pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 73, 8))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_111._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'contact')), pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 74, 8))
    st_8 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_111._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'gps')), pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 75, 8))
    st_9 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_111._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'imu')), pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 76, 8))
    st_10 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_111._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'logical_camera')), pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 77, 8))
    st_11 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_111._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'magnetometer')), pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 78, 8))
    st_12 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_111._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'ray')), pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 79, 8))
    st_13 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_111._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'rfidtag')), pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 80, 8))
    st_14 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_14)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_111._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'rfid')), pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 81, 8))
    st_15 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_15)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_111._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'sonar')), pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 82, 8))
    st_16 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_16)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_111._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'transceiver')), pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 83, 8))
    st_17 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_17)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_111._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'force_torque')), pyxb.utils.utility.Location('http://sdformat.org/schemas/sensor.xsd', 84, 8))
    st_18 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_18)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_14, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_15, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_16, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_17, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_18, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_13._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_14._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_15._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_16._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_17._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    transitions.append(fac.Transition(st_14, [
         ]))
    transitions.append(fac.Transition(st_15, [
         ]))
    transitions.append(fac.Transition(st_16, [
         ]))
    transitions.append(fac.Transition(st_17, [
         ]))
    transitions.append(fac.Transition(st_18, [
         ]))
    st_18._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_111._Automaton = _BuildAutomaton_111()




CTD_ANON_112._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'min'), pyxb.binding.datatypes.double, scope=CTD_ANON_112, documentation='\n              Minimum range\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/sonar.xsd', 13, 8)))

CTD_ANON_112._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'max'), pyxb.binding.datatypes.double, scope=CTD_ANON_112, documentation='\n              Max range\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/sonar.xsd', 22, 8)))

CTD_ANON_112._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'radius'), pyxb.binding.datatypes.double, scope=CTD_ANON_112, documentation='\n              Radius of the sonar cone at max range.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/sonar.xsd', 31, 8)))

def _BuildAutomaton_112 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_112
    del _BuildAutomaton_112
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_112._UseForTag(pyxb.namespace.ExpandedName(None, 'min')), pyxb.utils.utility.Location('http://sdformat.org/schemas/sonar.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_112._UseForTag(pyxb.namespace.ExpandedName(None, 'max')), pyxb.utils.utility.Location('http://sdformat.org/schemas/sonar.xsd', 22, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_112._UseForTag(pyxb.namespace.ExpandedName(None, 'radius')), pyxb.utils.utility.Location('http://sdformat.org/schemas/sonar.xsd', 31, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_112._Automaton = _BuildAutomaton_112()




CTD_ANON_113._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'radius'), pyxb.binding.datatypes.double, scope=CTD_ANON_113, documentation='\n              radius of the sphere\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/sphere_shape.xsd', 13, 8)))

def _BuildAutomaton_113 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_113
    del _BuildAutomaton_113
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_113._UseForTag(pyxb.namespace.ExpandedName(None, 'radius')), pyxb.utils.utility.Location('http://sdformat.org/schemas/sphere_shape.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_113._Automaton = _BuildAutomaton_113()




CTD_ANON_114._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'surface_model'), pyxb.binding.datatypes.string, scope=CTD_ANON_114, documentation="\n              \n      Name of planetary surface model, used to determine the surface altitude\n      at a given latitude and longitude. The default is an ellipsoid model of\n      the earth based on the WGS-84 standard. It is used in Gazebo's GPS sensor\n      implementation.\n    \n            ", location=pyxb.utils.utility.Location('http://sdformat.org/schemas/spherical_coordinates.xsd', 8, 8)))

CTD_ANON_114._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'latitude_deg'), pyxb.binding.datatypes.double, scope=CTD_ANON_114, documentation='\n              \n      Geodetic latitude at origin of gazebo reference frame, specified\n      in units of degrees.\n    \n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/spherical_coordinates.xsd', 22, 8)))

CTD_ANON_114._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'longitude_deg'), pyxb.binding.datatypes.double, scope=CTD_ANON_114, documentation='\n              \n      Longitude at origin of gazebo reference frame, specified in units\n      of degrees.\n    \n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/spherical_coordinates.xsd', 34, 8)))

CTD_ANON_114._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'elevation'), pyxb.binding.datatypes.double, scope=CTD_ANON_114, documentation='\n              \n      Elevation of origin of gazebo reference frame, specified in meters.\n    \n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/spherical_coordinates.xsd', 46, 8)))

CTD_ANON_114._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'heading_deg'), pyxb.binding.datatypes.double, scope=CTD_ANON_114, documentation='\n              \n      Heading offset of gazebo reference frame, measured as angle between\n      East and gazebo x axis, or equivalently, the angle between North and\n      gazebo y axis. The angle is specified in degrees.\n    \n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/spherical_coordinates.xsd', 57, 8)))

def _BuildAutomaton_114 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_114
    del _BuildAutomaton_114
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_114._UseForTag(pyxb.namespace.ExpandedName(None, 'surface_model')), pyxb.utils.utility.Location('http://sdformat.org/schemas/spherical_coordinates.xsd', 8, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_114._UseForTag(pyxb.namespace.ExpandedName(None, 'latitude_deg')), pyxb.utils.utility.Location('http://sdformat.org/schemas/spherical_coordinates.xsd', 22, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_114._UseForTag(pyxb.namespace.ExpandedName(None, 'longitude_deg')), pyxb.utils.utility.Location('http://sdformat.org/schemas/spherical_coordinates.xsd', 34, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_114._UseForTag(pyxb.namespace.ExpandedName(None, 'elevation')), pyxb.utils.utility.Location('http://sdformat.org/schemas/spherical_coordinates.xsd', 46, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_114._UseForTag(pyxb.namespace.ExpandedName(None, 'heading_deg')), pyxb.utils.utility.Location('http://sdformat.org/schemas/spherical_coordinates.xsd', 57, 8))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_114._Automaton = _BuildAutomaton_114()




CTD_ANON_115._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'sim_time'), time, scope=CTD_ANON_115, documentation='\n              Simulation time stamp of the state [seconds nanoseconds]\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 8, 8)))

CTD_ANON_115._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'wall_time'), time, scope=CTD_ANON_115, documentation='\n              Wall time stamp of the state [seconds nanoseconds]\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 17, 8)))

CTD_ANON_115._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'real_time'), time, scope=CTD_ANON_115, documentation='\n              Real time stamp of the state [seconds nanoseconds]\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 26, 8)))

CTD_ANON_115._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'iterations'), pyxb.binding.datatypes.unsignedInt, scope=CTD_ANON_115, documentation='\n              Number of simulation iterations.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 35, 8)))

CTD_ANON_115._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'insertions'), CTD_ANON_116, scope=CTD_ANON_115, documentation='\n              A list of new model names\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 44, 8)))

CTD_ANON_115._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'deletions'), CTD_ANON_117, scope=CTD_ANON_115, documentation='\n              A list of deleted model names\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 57, 8)))

CTD_ANON_115._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'model'), CTD_ANON_118, scope=CTD_ANON_115, documentation='\n              Model state\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 79, 8)))

def _BuildAutomaton_115 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_115
    del _BuildAutomaton_115
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 7, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 16, 8))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 25, 8))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 43, 8))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 56, 8))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 78, 8))
    counters.add(cc_5)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_115._UseForTag(pyxb.namespace.ExpandedName(None, 'sim_time')), pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 8, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_115._UseForTag(pyxb.namespace.ExpandedName(None, 'wall_time')), pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 17, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_115._UseForTag(pyxb.namespace.ExpandedName(None, 'real_time')), pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 26, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_115._UseForTag(pyxb.namespace.ExpandedName(None, 'iterations')), pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 35, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_115._UseForTag(pyxb.namespace.ExpandedName(None, 'insertions')), pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 44, 8))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_115._UseForTag(pyxb.namespace.ExpandedName(None, 'deletions')), pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 57, 8))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_115._UseForTag(pyxb.namespace.ExpandedName(None, 'model')), pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 79, 8))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_115._Automaton = _BuildAutomaton_115()




def _BuildAutomaton_116 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_116
    del _BuildAutomaton_116
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_116._Automaton = _BuildAutomaton_116()




CTD_ANON_117._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'name'), pyxb.binding.datatypes.string, scope=CTD_ANON_117, documentation='\n                    The name of a deleted model\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 66, 14)))

def _BuildAutomaton_117 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_117
    del _BuildAutomaton_117
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_117._UseForTag(pyxb.namespace.ExpandedName(None, 'name')), pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 66, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_117._Automaton = _BuildAutomaton_117()




CTD_ANON_118._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'pose'), pose, scope=CTD_ANON_118, documentation='\n                    Pose of the model\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 88, 14)))

CTD_ANON_118._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'joint'), CTD_ANON_119, scope=CTD_ANON_118, documentation='\n                    Joint angle\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 97, 14)))

CTD_ANON_118._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'link'), CTD_ANON_120, scope=CTD_ANON_118, documentation='\n                    Link state\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 126, 14)))

def _BuildAutomaton_118 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_118
    del _BuildAutomaton_118
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 96, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 125, 14))
    counters.add(cc_1)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_118._UseForTag(pyxb.namespace.ExpandedName(None, 'pose')), pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 88, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_118._UseForTag(pyxb.namespace.ExpandedName(None, 'joint')), pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 97, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_118._UseForTag(pyxb.namespace.ExpandedName(None, 'link')), pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 126, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_118._Automaton = _BuildAutomaton_118()




CTD_ANON_119._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'angle'), pyxb.binding.datatypes.double, scope=CTD_ANON_119, documentation='\n                          Angle of an axis\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 106, 20)))

def _BuildAutomaton_119 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_119
    del _BuildAutomaton_119
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_119._UseForTag(pyxb.namespace.ExpandedName(None, 'angle')), pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 106, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_119._Automaton = _BuildAutomaton_119()




CTD_ANON_120._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'pose'), pose, scope=CTD_ANON_120, documentation='\n                          Pose of the link relative to the model\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 135, 20)))

CTD_ANON_120._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'velocity'), pose, scope=CTD_ANON_120, documentation='\n                          Velocity of the link\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 144, 20)))

CTD_ANON_120._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'acceleration'), pose, scope=CTD_ANON_120, documentation='\n                          Acceleration of the link\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 153, 20)))

CTD_ANON_120._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'wrench'), pose, scope=CTD_ANON_120, documentation='\n                          Force applied to the link\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 162, 20)))

CTD_ANON_120._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'collision'), CTD_ANON_121, scope=CTD_ANON_120, documentation='\n                          Collision state\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 171, 20)))

def _BuildAutomaton_120 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_120
    del _BuildAutomaton_120
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 143, 20))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 152, 20))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 161, 20))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 170, 20))
    counters.add(cc_3)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_120._UseForTag(pyxb.namespace.ExpandedName(None, 'pose')), pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 135, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_120._UseForTag(pyxb.namespace.ExpandedName(None, 'velocity')), pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 144, 20))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_120._UseForTag(pyxb.namespace.ExpandedName(None, 'acceleration')), pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 153, 20))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_120._UseForTag(pyxb.namespace.ExpandedName(None, 'wrench')), pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 162, 20))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_120._UseForTag(pyxb.namespace.ExpandedName(None, 'collision')), pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 171, 20))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_120._Automaton = _BuildAutomaton_120()




CTD_ANON_121._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'pose'), pose, scope=CTD_ANON_121, documentation='\n                                Pose of the link relative to the model\n                              ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 180, 26)))

def _BuildAutomaton_121 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_121
    del _BuildAutomaton_121
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_121._UseForTag(pyxb.namespace.ExpandedName(None, 'pose')), pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 180, 26))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_121._Automaton = _BuildAutomaton_121()




CTD_ANON_122._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'bounce'), CTD_ANON_123, scope=CTD_ANON_122, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 13, 8)))

CTD_ANON_122._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'friction'), CTD_ANON_124, scope=CTD_ANON_122, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 39, 8)))

CTD_ANON_122._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'contact'), CTD_ANON_127, scope=CTD_ANON_122, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 149, 8)))

CTD_ANON_122._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'soft_contact'), CTD_ANON_130, scope=CTD_ANON_122, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 318, 8)))

def _BuildAutomaton_122 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_122
    del _BuildAutomaton_122
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 12, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 38, 8))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 148, 8))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 317, 8))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_122._UseForTag(pyxb.namespace.ExpandedName(None, 'bounce')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_122._UseForTag(pyxb.namespace.ExpandedName(None, 'friction')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 39, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_122._UseForTag(pyxb.namespace.ExpandedName(None, 'contact')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 149, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_122._UseForTag(pyxb.namespace.ExpandedName(None, 'soft_contact')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 318, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_122._Automaton = _BuildAutomaton_122()




CTD_ANON_123._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'restitution_coefficient'), pyxb.binding.datatypes.double, scope=CTD_ANON_123, documentation='\n                    Bounciness coefficient of restitution, from [0...1], where 0=no bounciness.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 17, 14)))

CTD_ANON_123._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'threshold'), pyxb.binding.datatypes.double, scope=CTD_ANON_123, documentation='\n                    Bounce capture velocity, below which effective coefficient of restitution is 0.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 26, 14)))

def _BuildAutomaton_123 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_123
    del _BuildAutomaton_123
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 16, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 25, 14))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_123._UseForTag(pyxb.namespace.ExpandedName(None, 'restitution_coefficient')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 17, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_123._UseForTag(pyxb.namespace.ExpandedName(None, 'threshold')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 26, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_123._Automaton = _BuildAutomaton_123()




CTD_ANON_124._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ode'), CTD_ANON_125, scope=CTD_ANON_124, documentation='\n                    ODE friction parameters\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 43, 14)))

CTD_ANON_124._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'bullet'), CTD_ANON_126, scope=CTD_ANON_124, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 101, 14)))

def _BuildAutomaton_124 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_124
    del _BuildAutomaton_124
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 42, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 100, 14))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_124._UseForTag(pyxb.namespace.ExpandedName(None, 'ode')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 43, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_124._UseForTag(pyxb.namespace.ExpandedName(None, 'bullet')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 101, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_124._Automaton = _BuildAutomaton_124()




CTD_ANON_125._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'mu'), pyxb.binding.datatypes.double, scope=CTD_ANON_125, documentation='\n                          Coefficient of friction in the range of [0..1].\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 52, 20)))

CTD_ANON_125._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'mu2'), pyxb.binding.datatypes.double, scope=CTD_ANON_125, documentation='\n                          Second coefficient of friction in the range of [0..1]\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 61, 20)))

CTD_ANON_125._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'fdir1'), vector3, scope=CTD_ANON_125, documentation='\n                          3-tuple specifying direction of mu1 in the collision local reference frame.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 70, 20)))

CTD_ANON_125._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'slip1'), pyxb.binding.datatypes.double, scope=CTD_ANON_125, documentation='\n                          Force dependent slip direction 1 in collision local frame, between the range of [0..1].\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 79, 20)))

CTD_ANON_125._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'slip2'), pyxb.binding.datatypes.double, scope=CTD_ANON_125, documentation='\n                          Force dependent slip direction 2 in collision local frame, between the range of [0..1].\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 88, 20)))

def _BuildAutomaton_125 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_125
    del _BuildAutomaton_125
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 51, 20))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 60, 20))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 69, 20))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 78, 20))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 87, 20))
    counters.add(cc_4)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_125._UseForTag(pyxb.namespace.ExpandedName(None, 'mu')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 52, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_125._UseForTag(pyxb.namespace.ExpandedName(None, 'mu2')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 61, 20))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_125._UseForTag(pyxb.namespace.ExpandedName(None, 'fdir1')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 70, 20))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_125._UseForTag(pyxb.namespace.ExpandedName(None, 'slip1')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 79, 20))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_125._UseForTag(pyxb.namespace.ExpandedName(None, 'slip2')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 88, 20))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_125._Automaton = _BuildAutomaton_125()




CTD_ANON_126._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'friction'), pyxb.binding.datatypes.double, scope=CTD_ANON_126, documentation='\n                          Coefficient of friction in the range of [0..1].\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 105, 20)))

CTD_ANON_126._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'friction2'), pyxb.binding.datatypes.double, scope=CTD_ANON_126, documentation='\n                          Coefficient of friction in the range of [0..1].\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 114, 20)))

CTD_ANON_126._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'fdir1'), vector3, scope=CTD_ANON_126, documentation='\n                          3-tuple specifying direction of mu1 in the collision local reference frame.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 123, 20)))

CTD_ANON_126._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'rolling_friction'), pyxb.binding.datatypes.double, scope=CTD_ANON_126, documentation='\n                           coefficient of friction in the range of [0..1]\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 132, 20)))

def _BuildAutomaton_126 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_126
    del _BuildAutomaton_126
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 104, 20))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 113, 20))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 122, 20))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 131, 20))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_126._UseForTag(pyxb.namespace.ExpandedName(None, 'friction')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 105, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_126._UseForTag(pyxb.namespace.ExpandedName(None, 'friction2')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 114, 20))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_126._UseForTag(pyxb.namespace.ExpandedName(None, 'fdir1')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 123, 20))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_126._UseForTag(pyxb.namespace.ExpandedName(None, 'rolling_friction')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 132, 20))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_126._Automaton = _BuildAutomaton_126()




CTD_ANON_127._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'collide_without_contact'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_127, documentation='\n                    Flag to disable contact force generation, while still allowing collision checks and contact visualization to occur.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 153, 14)))

CTD_ANON_127._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'collide_without_contact_bitmask'), pyxb.binding.datatypes.unsignedInt, scope=CTD_ANON_127, documentation='\n                    Bitmask for collision filtering when collide_without_contact is on \n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 162, 14)))

CTD_ANON_127._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'collide_bitmask'), pyxb.binding.datatypes.unsignedInt, scope=CTD_ANON_127, documentation='\n                    Bitmask for collision filtering. This will override collide_without_contact\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 171, 14)))

CTD_ANON_127._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'ode'), CTD_ANON_128, scope=CTD_ANON_127, documentation='\n                    ODE contact parameters\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 180, 14)))

CTD_ANON_127._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'bullet'), CTD_ANON_129, scope=CTD_ANON_127, documentation='\n                    Bullet contact parameters\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 247, 14)))

def _BuildAutomaton_127 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_127
    del _BuildAutomaton_127
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 152, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 161, 14))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 170, 14))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 179, 14))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 246, 14))
    counters.add(cc_4)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_127._UseForTag(pyxb.namespace.ExpandedName(None, 'collide_without_contact')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 153, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_127._UseForTag(pyxb.namespace.ExpandedName(None, 'collide_without_contact_bitmask')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 162, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_127._UseForTag(pyxb.namespace.ExpandedName(None, 'collide_bitmask')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 171, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_127._UseForTag(pyxb.namespace.ExpandedName(None, 'ode')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 180, 14))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_127._UseForTag(pyxb.namespace.ExpandedName(None, 'bullet')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 247, 14))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_127._Automaton = _BuildAutomaton_127()




CTD_ANON_128._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'soft_cfm'), pyxb.binding.datatypes.double, scope=CTD_ANON_128, documentation='\n                          Soft constraint force mixing.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 189, 20)))

CTD_ANON_128._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'soft_erp'), pyxb.binding.datatypes.double, scope=CTD_ANON_128, documentation='\n                          Soft error reduction parameter\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 198, 20)))

CTD_ANON_128._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'kp'), pyxb.binding.datatypes.double, scope=CTD_ANON_128, documentation='\n                          dynamically "stiffness"-equivalent coefficient for contact joints\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 207, 20)))

CTD_ANON_128._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'kd'), pyxb.binding.datatypes.double, scope=CTD_ANON_128, documentation='\n                          dynamically "damping"-equivalent coefficient for contact joints\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 216, 20)))

CTD_ANON_128._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'max_vel'), pyxb.binding.datatypes.double, scope=CTD_ANON_128, documentation='\n                          maximum contact correction velocity truncation term.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 225, 20)))

CTD_ANON_128._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'min_depth'), pyxb.binding.datatypes.double, scope=CTD_ANON_128, documentation='\n                          minimum allowable depth before contact correction impulse is applied\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 234, 20)))

def _BuildAutomaton_128 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_128
    del _BuildAutomaton_128
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 188, 20))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 197, 20))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 206, 20))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 215, 20))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 224, 20))
    counters.add(cc_4)
    cc_5 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 233, 20))
    counters.add(cc_5)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_128._UseForTag(pyxb.namespace.ExpandedName(None, 'soft_cfm')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 189, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_128._UseForTag(pyxb.namespace.ExpandedName(None, 'soft_erp')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 198, 20))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_128._UseForTag(pyxb.namespace.ExpandedName(None, 'kp')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 207, 20))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_128._UseForTag(pyxb.namespace.ExpandedName(None, 'kd')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 216, 20))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_128._UseForTag(pyxb.namespace.ExpandedName(None, 'max_vel')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 225, 20))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_5, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_128._UseForTag(pyxb.namespace.ExpandedName(None, 'min_depth')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 234, 20))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_5, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, True) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_5, False) ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_128._Automaton = _BuildAutomaton_128()




CTD_ANON_129._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'soft_cfm'), pyxb.binding.datatypes.double, scope=CTD_ANON_129, documentation='\n                          Soft constraint force mixing.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 256, 20)))

CTD_ANON_129._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'soft_erp'), pyxb.binding.datatypes.double, scope=CTD_ANON_129, documentation='\n                          Soft error reduction parameter\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 265, 20)))

CTD_ANON_129._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'kp'), pyxb.binding.datatypes.double, scope=CTD_ANON_129, documentation='\n                          dynamically "stiffness"-equivalent coefficient for contact joints\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 274, 20)))

CTD_ANON_129._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'kd'), pyxb.binding.datatypes.double, scope=CTD_ANON_129, documentation='\n                          dynamically "damping"-equivalent coefficient for contact joints\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 283, 20)))

CTD_ANON_129._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'split_impulse'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_129, documentation="\n                          Similar to ODE's max_vel implementation.  See http://bulletphysics.org/mediawiki-1.5.8/index.php/BtContactSolverInfo#Split_Impulse for more information.\n                        ", location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 292, 20)))

CTD_ANON_129._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'split_impulse_penetration_threshold'), pyxb.binding.datatypes.double, scope=CTD_ANON_129, documentation="\n                          Similar to ODE's max_vel implementation.  See http://bulletphysics.org/mediawiki-1.5.8/index.php/BtContactSolverInfo#Split_Impulse for more information.\n                        ", location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 301, 20)))

def _BuildAutomaton_129 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_129
    del _BuildAutomaton_129
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 255, 20))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 264, 20))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 273, 20))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 282, 20))
    counters.add(cc_3)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_129._UseForTag(pyxb.namespace.ExpandedName(None, 'soft_cfm')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 256, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_129._UseForTag(pyxb.namespace.ExpandedName(None, 'soft_erp')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 265, 20))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_129._UseForTag(pyxb.namespace.ExpandedName(None, 'kp')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 274, 20))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_129._UseForTag(pyxb.namespace.ExpandedName(None, 'kd')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 283, 20))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_129._UseForTag(pyxb.namespace.ExpandedName(None, 'split_impulse')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 292, 20))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_129._UseForTag(pyxb.namespace.ExpandedName(None, 'split_impulse_penetration_threshold')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 301, 20))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    st_5._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_129._Automaton = _BuildAutomaton_129()




CTD_ANON_130._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'dart'), CTD_ANON_131, scope=CTD_ANON_130, documentation='\n                    soft contact pamameters based on paper:\n             http://www.cc.gatech.edu/graphics/projects/Sumit/homepage/papers/sigasia11/jain_softcontacts_siga11.pdf\n      \n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 322, 14)))

def _BuildAutomaton_130 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_130
    del _BuildAutomaton_130
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 321, 14))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_130._UseForTag(pyxb.namespace.ExpandedName(None, 'dart')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 322, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_130._Automaton = _BuildAutomaton_130()




CTD_ANON_131._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'bone_attachment'), pyxb.binding.datatypes.double, scope=CTD_ANON_131, documentation='\n                          This is variable k_v in the soft contacts paper.  Its unit is N/m.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 333, 20)))

CTD_ANON_131._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'stiffness'), pyxb.binding.datatypes.double, scope=CTD_ANON_131, documentation='\n                          This is variable k_e in the soft contacts paper.  Its unit is N/m.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 342, 20)))

CTD_ANON_131._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'damping'), pyxb.binding.datatypes.double, scope=CTD_ANON_131, documentation='\n                          Viscous damping of point velocity in body frame.  Its unit is N/m/s.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 351, 20)))

CTD_ANON_131._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'flesh_mass_fraction'), pyxb.binding.datatypes.double, scope=CTD_ANON_131, documentation='\n                          Fraction of mass to be distributed among deformable nodes.\n                        ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 360, 20)))

def _BuildAutomaton_131 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_131
    del _BuildAutomaton_131
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_131._UseForTag(pyxb.namespace.ExpandedName(None, 'bone_attachment')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 333, 20))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_131._UseForTag(pyxb.namespace.ExpandedName(None, 'stiffness')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 342, 20))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_131._UseForTag(pyxb.namespace.ExpandedName(None, 'damping')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 351, 20))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_131._UseForTag(pyxb.namespace.ExpandedName(None, 'flesh_mass_fraction')), pyxb.utils.utility.Location('http://sdformat.org/schemas/surface.xsd', 360, 20))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_131._Automaton = _BuildAutomaton_131()




CTD_ANON_132._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'essid'), pyxb.binding.datatypes.string, scope=CTD_ANON_132, documentation='\n              Service set identifier (network name)\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 13, 8)))

CTD_ANON_132._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'frequency'), pyxb.binding.datatypes.double, scope=CTD_ANON_132, documentation='\n              Specifies the frequency of transmission in MHz\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 22, 8)))

CTD_ANON_132._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'min_frequency'), pyxb.binding.datatypes.double, scope=CTD_ANON_132, documentation='\n              Only a frequency range is filtered. Here we set the lower bound (MHz).\n    \n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 31, 8)))

CTD_ANON_132._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'max_frequency'), pyxb.binding.datatypes.double, scope=CTD_ANON_132, documentation='\n              Only a frequency range is filtered. Here we set the upper bound (MHz).\n    \n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 41, 8)))

CTD_ANON_132._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'gain'), pyxb.binding.datatypes.double, scope=CTD_ANON_132, documentation='\n              Specifies the antenna gain in dBi\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 51, 8)))

CTD_ANON_132._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'power'), pyxb.binding.datatypes.double, scope=CTD_ANON_132, documentation='\n              Specifies the transmission power in dBm\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 60, 8)))

CTD_ANON_132._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'sensitivity'), pyxb.binding.datatypes.double, scope=CTD_ANON_132, documentation='\n              Mininum received signal power in dBm\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 69, 8)))

def _BuildAutomaton_132 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_132
    del _BuildAutomaton_132
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 12, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 21, 8))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 30, 8))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 40, 8))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 68, 8))
    counters.add(cc_4)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_132._UseForTag(pyxb.namespace.ExpandedName(None, 'essid')), pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 13, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_132._UseForTag(pyxb.namespace.ExpandedName(None, 'frequency')), pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 22, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_132._UseForTag(pyxb.namespace.ExpandedName(None, 'min_frequency')), pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 31, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_132._UseForTag(pyxb.namespace.ExpandedName(None, 'max_frequency')), pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 41, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_132._UseForTag(pyxb.namespace.ExpandedName(None, 'gain')), pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 51, 8))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_132._UseForTag(pyxb.namespace.ExpandedName(None, 'power')), pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 60, 8))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_132._UseForTag(pyxb.namespace.ExpandedName(None, 'sensitivity')), pyxb.utils.utility.Location('http://sdformat.org/schemas/transceiver.xsd', 69, 8))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_6._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_132._Automaton = _BuildAutomaton_132()




CTD_ANON_133._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'geometry'), CTD_ANON_23, scope=CTD_ANON_133, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/geometry.xsd', 17, 2)))

CTD_ANON_133._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'material'), CTD_ANON_77, scope=CTD_ANON_133, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/material.xsd', 9, 2)))

CTD_ANON_133._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'plugin'), CTD_ANON_94, scope=CTD_ANON_133, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/plugin.xsd', 9, 2)))

CTD_ANON_133._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'cast_shadows'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_133, documentation='\n              If true the visual will cast shadows.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 16, 8)))

CTD_ANON_133._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'laser_retro'), pyxb.binding.datatypes.double, scope=CTD_ANON_133, documentation='\n              will be implemented in the future release.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 25, 8)))

CTD_ANON_133._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'transparency'), pyxb.binding.datatypes.double, scope=CTD_ANON_133, documentation='\n              The amount of transparency( 0=opaque, 1 = fully transparent)\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 34, 8)))

CTD_ANON_133._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'pose'), pose, scope=CTD_ANON_133, documentation='\n              The reference frame of the visual element, relative to the reference frame of the link.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 43, 8)))

CTD_ANON_133._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'meta'), CTD_ANON_134, scope=CTD_ANON_133, documentation='\n              Optional meta information for the visual. The information contained within this element should be used to provide additional feedback to an end user.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 52, 8)))

def _BuildAutomaton_133 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_133
    del _BuildAutomaton_133
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 15, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 24, 8))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 33, 8))
    counters.add(cc_2)
    cc_3 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 42, 8))
    counters.add(cc_3)
    cc_4 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 51, 8))
    counters.add(cc_4)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_133._UseForTag(pyxb.namespace.ExpandedName(None, 'cast_shadows')), pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 16, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_133._UseForTag(pyxb.namespace.ExpandedName(None, 'laser_retro')), pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 25, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_133._UseForTag(pyxb.namespace.ExpandedName(None, 'transparency')), pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 34, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_3, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_133._UseForTag(pyxb.namespace.ExpandedName(None, 'pose')), pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 43, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_4, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_133._UseForTag(pyxb.namespace.ExpandedName(None, 'meta')), pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 52, 8))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_133._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'material')), pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 73, 8))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_133._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'geometry')), pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 74, 8))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_133._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'plugin')), pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 75, 8))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_3, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_3, False) ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, True) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_4, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_4, False) ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    st_7._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_133._Automaton = _BuildAutomaton_133()




CTD_ANON_134._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'layer'), pyxb.binding.datatypes.int, scope=CTD_ANON_134, documentation='\n                    The layer in which this visual is displayed. The layer number is useful for programs, such as Gazebo, that put visuals in different layers for enhanced visualization.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 61, 14)))

def _BuildAutomaton_134 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_134
    del _BuildAutomaton_134
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 60, 14))
    counters.add(cc_0)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_134._UseForTag(pyxb.namespace.ExpandedName(None, 'layer')), pyxb.utils.utility.Location('http://sdformat.org/schemas/visual.xsd', 61, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_134._Automaton = _BuildAutomaton_134()




CTD_ANON_135._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'actor'), CTD_ANON, scope=CTD_ANON_135, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/actor.xsd', 7, 2)))

CTD_ANON_135._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'gui'), CTD_ANON_34, scope=CTD_ANON_135, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/gui.xsd', 5, 2)))

CTD_ANON_135._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'joint'), CTD_ANON_55, scope=CTD_ANON_135, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/joint.xsd', 10, 2)))

CTD_ANON_135._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'light'), CTD_ANON_67, scope=CTD_ANON_135, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/light.xsd', 9, 2)))

CTD_ANON_135._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'model'), CTD_ANON_82, scope=CTD_ANON_135, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/model.xsd', 13, 2)))

CTD_ANON_135._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'physics'), CTD_ANON_84, scope=CTD_ANON_135, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/physics.xsd', 9, 2)))

CTD_ANON_135._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'plugin'), CTD_ANON_94, scope=CTD_ANON_135, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/plugin.xsd', 9, 2)))

CTD_ANON_135._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'population'), CTD_ANON_96, scope=CTD_ANON_135, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/population.xsd', 15, 2)))

CTD_ANON_135._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'road'), CTD_ANON_105, scope=CTD_ANON_135, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/road.xsd', 5, 2)))

CTD_ANON_135._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'scene'), CTD_ANON_107, scope=CTD_ANON_135, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/scene.xsd', 9, 2)))

CTD_ANON_135._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'spherical_coordinates'), CTD_ANON_114, scope=CTD_ANON_135, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/spherical_coordinates.xsd', 4, 2)))

CTD_ANON_135._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(Namespace, 'state'), CTD_ANON_115, scope=CTD_ANON_135, location=pyxb.utils.utility.Location('http://sdformat.org/schemas/state.xsd', 4, 2)))

CTD_ANON_135._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'audio'), CTD_ANON_136, scope=CTD_ANON_135, documentation='\n              Global audio properties.\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 25, 8)))

CTD_ANON_135._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'include'), CTD_ANON_137, scope=CTD_ANON_135, documentation='\n              Include resources from a URI\n            ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 47, 8)))

def _BuildAutomaton_135 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_135
    del _BuildAutomaton_135
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 24, 8))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=None, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 46, 8))
    counters.add(cc_1)
    states = []
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_135._UseForTag(pyxb.namespace.ExpandedName(None, 'audio')), pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 25, 8))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_135._UseForTag(pyxb.namespace.ExpandedName(None, 'include')), pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 47, 8))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_135._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'gui')), pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 95, 8))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_135._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'physics')), pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 96, 8))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_135._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'scene')), pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 97, 8))
    st_4 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_4)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_135._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'light')), pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 98, 8))
    st_5 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_5)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_135._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'model')), pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 99, 8))
    st_6 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_6)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_135._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'actor')), pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 100, 8))
    st_7 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_7)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_135._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'plugin')), pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 101, 8))
    st_8 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_8)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_135._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'joint')), pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 102, 8))
    st_9 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_9)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_135._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'road')), pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 103, 8))
    st_10 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_10)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_135._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'spherical_coordinates')), pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 104, 8))
    st_11 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_11)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_135._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'state')), pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 105, 8))
    st_12 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_12)
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_135._UseForTag(pyxb.namespace.ExpandedName(Namespace, 'population')), pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 106, 8))
    st_13 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_13)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_4, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_5, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_6, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_7, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_8, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_9, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_10, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_11, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_12, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_13, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_3._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_4._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_5._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_6._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_7._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_8._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_9._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_10._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_11._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_12._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    transitions.append(fac.Transition(st_4, [
         ]))
    transitions.append(fac.Transition(st_5, [
         ]))
    transitions.append(fac.Transition(st_6, [
         ]))
    transitions.append(fac.Transition(st_7, [
         ]))
    transitions.append(fac.Transition(st_8, [
         ]))
    transitions.append(fac.Transition(st_9, [
         ]))
    transitions.append(fac.Transition(st_10, [
         ]))
    transitions.append(fac.Transition(st_11, [
         ]))
    transitions.append(fac.Transition(st_12, [
         ]))
    transitions.append(fac.Transition(st_13, [
         ]))
    st_13._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_135._Automaton = _BuildAutomaton_135()




CTD_ANON_136._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'device'), pyxb.binding.datatypes.string, scope=CTD_ANON_136, documentation='\n                    Device to use for audio playback. A value of "default" will use the system\'s default audio device. Otherwise, specify a an audio device file"\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 34, 14)))

def _BuildAutomaton_136 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_136
    del _BuildAutomaton_136
    import pyxb.utils.fac as fac

    counters = set()
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_136._UseForTag(pyxb.namespace.ExpandedName(None, 'device')), pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 34, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    st_0._set_transitionSet(transitions)
    return fac.Automaton(states, counters, False, containing_state=None)
CTD_ANON_136._Automaton = _BuildAutomaton_136()




CTD_ANON_137._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'uri'), pyxb.binding.datatypes.string, scope=CTD_ANON_137, documentation='\n                    URI to a resource, such as a model\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 56, 14)))

CTD_ANON_137._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'pose'), pose, scope=CTD_ANON_137, documentation='\n                    Override the pose of the included model. A position and orientation in the global coordinate frame for the model. Position(x,y,z) and rotation (roll, pitch yaw) in the global coordinate frame.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 65, 14)))

CTD_ANON_137._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'name'), pyxb.binding.datatypes.string, scope=CTD_ANON_137, documentation='\n                    Override the name of the included model.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 74, 14)))

CTD_ANON_137._AddElement(pyxb.binding.basis.element(pyxb.namespace.ExpandedName(None, 'static'), pyxb.binding.datatypes.boolean, scope=CTD_ANON_137, documentation='\n                    Override the static value of the included model.\n                  ', location=pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 83, 14)))

def _BuildAutomaton_137 ():
    # Remove this helper function from the namespace after it is invoked
    global _BuildAutomaton_137
    del _BuildAutomaton_137
    import pyxb.utils.fac as fac

    counters = set()
    cc_0 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 64, 14))
    counters.add(cc_0)
    cc_1 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 73, 14))
    counters.add(cc_1)
    cc_2 = fac.CounterCondition(min=0, max=1, metadata=pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 82, 14))
    counters.add(cc_2)
    states = []
    final_update = set()
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_137._UseForTag(pyxb.namespace.ExpandedName(None, 'uri')), pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 56, 14))
    st_0 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_0)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_0, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_137._UseForTag(pyxb.namespace.ExpandedName(None, 'pose')), pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 65, 14))
    st_1 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_1)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_1, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_137._UseForTag(pyxb.namespace.ExpandedName(None, 'name')), pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 74, 14))
    st_2 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_2)
    final_update = set()
    final_update.add(fac.UpdateInstruction(cc_2, False))
    symbol = pyxb.binding.content.ElementUse(CTD_ANON_137._UseForTag(pyxb.namespace.ExpandedName(None, 'static')), pyxb.utils.utility.Location('http://sdformat.org/schemas/world.xsd', 83, 14))
    st_3 = fac.State(symbol, is_initial=True, final_update=final_update, is_unordered_catenation=False)
    states.append(st_3)
    transitions = []
    transitions.append(fac.Transition(st_0, [
         ]))
    transitions.append(fac.Transition(st_1, [
         ]))
    transitions.append(fac.Transition(st_2, [
         ]))
    transitions.append(fac.Transition(st_3, [
         ]))
    st_0._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, True) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_0, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_0, False) ]))
    st_1._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, True) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_1, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_1, False) ]))
    st_2._set_transitionSet(transitions)
    transitions = []
    transitions.append(fac.Transition(st_0, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_1, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_2, [
        fac.UpdateInstruction(cc_2, False) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, True) ]))
    transitions.append(fac.Transition(st_3, [
        fac.UpdateInstruction(cc_2, False) ]))
    st_3._set_transitionSet(transitions)
    return fac.Automaton(states, counters, True, containing_state=None)
CTD_ANON_137._Automaton = _BuildAutomaton_137()

